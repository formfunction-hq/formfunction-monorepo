schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "ActivityNotification"
"""
type ActivityNotification implements Node {
  """An object relationship"""
  Notification: Notification!
  id: ID!

  """
  This foreign key is a special case to improve performance, since many
  notifications need to query for the associated NFT. Other one-off data should
  remain in Notification.data
  """
  nftId: String

  """
  This foreign key is a special case to improve performance, since many
  notifications need to query for the associated NFT transaction. Other one-off
  data should remain in Notification.data
  """
  nftTransactionId: uuid
  notificationId: uuid!
  timeCreated: timestamptz!
  timeSeen: timestamptz
}

"""
Boolean expression to filter rows from the table "ActivityNotification". All fields are combined with a logical 'AND'.
"""
input ActivityNotification_bool_exp {
  Notification: Notification_bool_exp
  _and: [ActivityNotification_bool_exp!]
  _not: ActivityNotification_bool_exp
  _or: [ActivityNotification_bool_exp!]
  id: uuid_comparison_exp
  nftId: String_comparison_exp
  nftTransactionId: uuid_comparison_exp
  notificationId: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
  timeSeen: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "ActivityNotification"
"""
enum ActivityNotification_constraint {
  """unique or primary key constraint"""
  ActivityNotification_notificationId_key

  """unique or primary key constraint"""
  ActivityNotification_pkey
}

"""
input type for inserting data into table "ActivityNotification"
"""
input ActivityNotification_insert_input {
  Notification: Notification_obj_rel_insert_input
  id: uuid

  """
  This foreign key is a special case to improve performance, since many
  notifications need to query for the associated NFT. Other one-off data should
  remain in Notification.data
  """
  nftId: String

  """
  This foreign key is a special case to improve performance, since many
  notifications need to query for the associated NFT transaction. Other one-off
  data should remain in Notification.data
  """
  nftTransactionId: uuid
  notificationId: uuid
  timeCreated: timestamptz
  timeSeen: timestamptz
}

"""
response of any mutation on the table "ActivityNotification"
"""
type ActivityNotification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ActivityNotification!]!
}

"""
on_conflict condition type for table "ActivityNotification"
"""
input ActivityNotification_on_conflict {
  constraint: ActivityNotification_constraint!
  update_columns: [ActivityNotification_update_column!]! = []
  where: ActivityNotification_bool_exp
}

"""Ordering options when selecting data from "ActivityNotification"."""
input ActivityNotification_order_by {
  Notification: Notification_order_by
  id: order_by
  nftId: order_by
  nftTransactionId: order_by
  notificationId: order_by
  timeCreated: order_by
  timeSeen: order_by
}

"""primary key columns input for table: ActivityNotification"""
input ActivityNotification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "ActivityNotification"
"""
enum ActivityNotification_select_column {
  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  nftTransactionId

  """column name"""
  notificationId

  """column name"""
  timeCreated

  """column name"""
  timeSeen
}

"""
input type for updating data in table "ActivityNotification"
"""
input ActivityNotification_set_input {
  id: uuid

  """
  This foreign key is a special case to improve performance, since many
  notifications need to query for the associated NFT. Other one-off data should
  remain in Notification.data
  """
  nftId: String

  """
  This foreign key is a special case to improve performance, since many
  notifications need to query for the associated NFT transaction. Other one-off
  data should remain in Notification.data
  """
  nftTransactionId: uuid
  notificationId: uuid
  timeCreated: timestamptz
  timeSeen: timestamptz
}

"""
update columns of table "ActivityNotification"
"""
enum ActivityNotification_update_column {
  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  nftTransactionId

  """column name"""
  notificationId

  """column name"""
  timeCreated

  """column name"""
  timeSeen
}

"""
A Relay connection object on "ActivityNotification"
"""
type ActivityNotificationConnection {
  edges: [ActivityNotificationEdge!]!
  pageInfo: PageInfo!
}

type ActivityNotificationEdge {
  cursor: String!
  node: ActivityNotification!
}

"""
columns and relationships of "Airdrop"
"""
type Airdrop implements Node {
  """An object relationship"""
  MasterEditionNft: Nft!
  fromAddress: String!
  id: ID!
  masterEditionMint: String!
  standardEditionMint: String

  """
  Used to store the standard edition mint immediately after minting but possibly
  before the NFT is inserted into our DB for easier retry logic and better reliability.
  """
  standardEditionMintRaw: String
  timeCreated: timestamptz!
  toAddress: String!
  type: AirdropType_enum!
}

"""
Boolean expression to filter rows from the table "Airdrop". All fields are combined with a logical 'AND'.
"""
input Airdrop_bool_exp {
  MasterEditionNft: Nft_bool_exp
  _and: [Airdrop_bool_exp!]
  _not: Airdrop_bool_exp
  _or: [Airdrop_bool_exp!]
  fromAddress: String_comparison_exp
  id: uuid_comparison_exp
  masterEditionMint: String_comparison_exp
  standardEditionMint: String_comparison_exp
  standardEditionMintRaw: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  toAddress: String_comparison_exp
  type: AirdropType_enum_comparison_exp
}

"""
unique or primary key constraints on table "Airdrop"
"""
enum Airdrop_constraint {
  """unique or primary key constraint"""
  Airdrop_pkey

  """unique or primary key constraint"""
  Airdrop_standardEditionMintRaw_key

  """unique or primary key constraint"""
  Airdrop_standardEditionMint_key

  """unique or primary key constraint"""
  Airdrop_toAddress_masterEditionMint_key
}

"""
input type for inserting data into table "Airdrop"
"""
input Airdrop_insert_input {
  MasterEditionNft: Nft_obj_rel_insert_input
  fromAddress: String
  id: uuid
  masterEditionMint: String
  standardEditionMint: String

  """
  Used to store the standard edition mint immediately after minting but possibly
  before the NFT is inserted into our DB for easier retry logic and better reliability.
  """
  standardEditionMintRaw: String
  timeCreated: timestamptz
  toAddress: String
  type: AirdropType_enum
}

"""
response of any mutation on the table "Airdrop"
"""
type Airdrop_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Airdrop!]!
}

"""
on_conflict condition type for table "Airdrop"
"""
input Airdrop_on_conflict {
  constraint: Airdrop_constraint!
  update_columns: [Airdrop_update_column!]! = []
  where: Airdrop_bool_exp
}

"""Ordering options when selecting data from "Airdrop"."""
input Airdrop_order_by {
  MasterEditionNft: Nft_order_by
  fromAddress: order_by
  id: order_by
  masterEditionMint: order_by
  standardEditionMint: order_by
  standardEditionMintRaw: order_by
  timeCreated: order_by
  toAddress: order_by
  type: order_by
}

"""primary key columns input for table: Airdrop"""
input Airdrop_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Airdrop"
"""
enum Airdrop_select_column {
  """column name"""
  fromAddress

  """column name"""
  id

  """column name"""
  masterEditionMint

  """column name"""
  standardEditionMint

  """column name"""
  standardEditionMintRaw

  """column name"""
  timeCreated

  """column name"""
  toAddress

  """column name"""
  type
}

"""
input type for updating data in table "Airdrop"
"""
input Airdrop_set_input {
  fromAddress: String
  id: uuid
  masterEditionMint: String
  standardEditionMint: String

  """
  Used to store the standard edition mint immediately after minting but possibly
  before the NFT is inserted into our DB for easier retry logic and better reliability.
  """
  standardEditionMintRaw: String
  timeCreated: timestamptz
  toAddress: String
  type: AirdropType_enum
}

"""
update columns of table "Airdrop"
"""
enum Airdrop_update_column {
  """column name"""
  fromAddress

  """column name"""
  id

  """column name"""
  masterEditionMint

  """column name"""
  standardEditionMint

  """column name"""
  standardEditionMintRaw

  """column name"""
  timeCreated

  """column name"""
  toAddress

  """column name"""
  type
}

"""
A Relay connection object on "Airdrop"
"""
type AirdropConnection {
  edges: [AirdropEdge!]!
  pageInfo: PageInfo!
}

type AirdropEdge {
  cursor: String!
  node: Airdrop!
}

"""
columns and relationships of "AirdropType"
"""
type AirdropType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "AirdropType". All fields are combined with a logical 'AND'.
"""
input AirdropType_bool_exp {
  _and: [AirdropType_bool_exp!]
  _not: AirdropType_bool_exp
  _or: [AirdropType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "AirdropType"
"""
enum AirdropType_constraint {
  """unique or primary key constraint"""
  AirdropType_pkey
}

enum AirdropType_enum {
  Claim
  Gift
}

"""
Boolean expression to compare columns of type "AirdropType_enum". All fields are combined with logical 'AND'.
"""
input AirdropType_enum_comparison_exp {
  _eq: AirdropType_enum
  _in: [AirdropType_enum!]
  _is_null: Boolean
  _neq: AirdropType_enum
  _nin: [AirdropType_enum!]
}

"""
input type for inserting data into table "AirdropType"
"""
input AirdropType_insert_input {
  value: String
}

"""
response of any mutation on the table "AirdropType"
"""
type AirdropType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [AirdropType!]!
}

"""
on_conflict condition type for table "AirdropType"
"""
input AirdropType_on_conflict {
  constraint: AirdropType_constraint!
  update_columns: [AirdropType_update_column!]! = []
  where: AirdropType_bool_exp
}

"""Ordering options when selecting data from "AirdropType"."""
input AirdropType_order_by {
  value: order_by
}

"""primary key columns input for table: AirdropType"""
input AirdropType_pk_columns_input {
  value: String!
}

"""
select columns of table "AirdropType"
"""
enum AirdropType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "AirdropType"
"""
input AirdropType_set_input {
  value: String
}

"""
update columns of table "AirdropType"
"""
enum AirdropType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "AirdropType"
"""
type AirdropTypeConnection {
  edges: [AirdropTypeEdge!]!
  pageInfo: PageInfo!
}

type AirdropTypeEdge {
  cursor: String!
  node: AirdropType!
}

"""Each row contains an artist's application submission"""
type ArtistSubmission implements Node {
  """An array relationship"""
  Assets(
    """distinct select on columns"""
    distinct_on: [Asset_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Asset_order_by!]

    """filter the rows returned"""
    where: Asset_bool_exp
  ): [Asset!]!

  """An aggregate relationship"""
  Assets_aggregate(
    """distinct select on columns"""
    distinct_on: [Asset_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Asset_order_by!]

    """filter the rows returned"""
    where: Asset_bool_exp
  ): Asset_aggregate!

  """An array relationship connection"""
  Assets_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Asset_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Asset_order_by!]

    """filter the rows returned"""
    where: Asset_bool_exp
  ): AssetConnection!

  """An object relationship"""
  User: User!

  """An array relationship"""
  Votes(
    """distinct select on columns"""
    distinct_on: [Vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Vote_order_by!]

    """filter the rows returned"""
    where: Vote_bool_exp
  ): [Vote!]!

  """An aggregate relationship"""
  Votes_aggregate(
    """distinct select on columns"""
    distinct_on: [Vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Vote_order_by!]

    """filter the rows returned"""
    where: Vote_bool_exp
  ): Vote_aggregate!

  """An array relationship connection"""
  Votes_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Vote_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Vote_order_by!]

    """filter the rows returned"""
    where: Vote_bool_exp
  ): VoteConnection!
  artProcess: String
  artistStatement: String!
  discordHandle: String
  id: ID!
  instagramName: String
  isCopyrightVerified: Boolean!
  status: ArtistSubmissionStatus_enum
  timeCreated: timestamptz
  twitterName: String!
  userId: String!
  websiteUrl: String!
}

"""
aggregated selection of "ArtistSubmission"
"""
type ArtistSubmission_aggregate {
  aggregate: ArtistSubmission_aggregate_fields
  nodes: [ArtistSubmission!]!
}

"""
aggregate fields of "ArtistSubmission"
"""
type ArtistSubmission_aggregate_fields {
  count(columns: [ArtistSubmission_select_column!], distinct: Boolean): Int!
  max: ArtistSubmission_max_fields
  min: ArtistSubmission_min_fields
}

"""
order by aggregate values of table "ArtistSubmission"
"""
input ArtistSubmission_aggregate_order_by {
  count: order_by
  max: ArtistSubmission_max_order_by
  min: ArtistSubmission_min_order_by
}

"""
input type for inserting array relation for remote table "ArtistSubmission"
"""
input ArtistSubmission_arr_rel_insert_input {
  data: [ArtistSubmission_insert_input!]!

  """upsert condition"""
  on_conflict: ArtistSubmission_on_conflict
}

"""
Boolean expression to filter rows from the table "ArtistSubmission". All fields are combined with a logical 'AND'.
"""
input ArtistSubmission_bool_exp {
  Assets: Asset_bool_exp
  User: User_bool_exp
  Votes: Vote_bool_exp
  _and: [ArtistSubmission_bool_exp!]
  _not: ArtistSubmission_bool_exp
  _or: [ArtistSubmission_bool_exp!]
  artProcess: String_comparison_exp
  artistStatement: String_comparison_exp
  discordHandle: String_comparison_exp
  id: uuid_comparison_exp
  instagramName: String_comparison_exp
  isCopyrightVerified: Boolean_comparison_exp
  status: ArtistSubmissionStatus_enum_comparison_exp
  timeCreated: timestamptz_comparison_exp
  twitterName: String_comparison_exp
  userId: String_comparison_exp
  websiteUrl: String_comparison_exp
}

"""
unique or primary key constraints on table "ArtistSubmission"
"""
enum ArtistSubmission_constraint {
  """unique or primary key constraint"""
  ArtistSubmission_pkey
}

"""
input type for inserting data into table "ArtistSubmission"
"""
input ArtistSubmission_insert_input {
  Assets: Asset_arr_rel_insert_input
  User: User_obj_rel_insert_input
  Votes: Vote_arr_rel_insert_input
  artProcess: String
  artistStatement: String
  discordHandle: String
  id: uuid
  instagramName: String
  isCopyrightVerified: Boolean
  status: ArtistSubmissionStatus_enum
  timeCreated: timestamptz
  twitterName: String
  userId: String
  websiteUrl: String
}

"""aggregate max on columns"""
type ArtistSubmission_max_fields {
  artProcess: String
  artistStatement: String
  discordHandle: String
  id: uuid
  instagramName: String
  timeCreated: timestamptz
  twitterName: String
  userId: String
  websiteUrl: String
}

"""
order by max() on columns of table "ArtistSubmission"
"""
input ArtistSubmission_max_order_by {
  artProcess: order_by
  artistStatement: order_by
  discordHandle: order_by
  id: order_by
  instagramName: order_by
  timeCreated: order_by
  twitterName: order_by
  userId: order_by
  websiteUrl: order_by
}

"""aggregate min on columns"""
type ArtistSubmission_min_fields {
  artProcess: String
  artistStatement: String
  discordHandle: String
  id: uuid
  instagramName: String
  timeCreated: timestamptz
  twitterName: String
  userId: String
  websiteUrl: String
}

"""
order by min() on columns of table "ArtistSubmission"
"""
input ArtistSubmission_min_order_by {
  artProcess: order_by
  artistStatement: order_by
  discordHandle: order_by
  id: order_by
  instagramName: order_by
  timeCreated: order_by
  twitterName: order_by
  userId: order_by
  websiteUrl: order_by
}

"""
response of any mutation on the table "ArtistSubmission"
"""
type ArtistSubmission_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ArtistSubmission!]!
}

"""
input type for inserting object relation for remote table "ArtistSubmission"
"""
input ArtistSubmission_obj_rel_insert_input {
  data: ArtistSubmission_insert_input!

  """upsert condition"""
  on_conflict: ArtistSubmission_on_conflict
}

"""
on_conflict condition type for table "ArtistSubmission"
"""
input ArtistSubmission_on_conflict {
  constraint: ArtistSubmission_constraint!
  update_columns: [ArtistSubmission_update_column!]! = []
  where: ArtistSubmission_bool_exp
}

"""Ordering options when selecting data from "ArtistSubmission"."""
input ArtistSubmission_order_by {
  Assets_aggregate: Asset_aggregate_order_by
  User: User_order_by
  Votes_aggregate: Vote_aggregate_order_by
  artProcess: order_by
  artistStatement: order_by
  discordHandle: order_by
  id: order_by
  instagramName: order_by
  isCopyrightVerified: order_by
  status: order_by
  timeCreated: order_by
  twitterName: order_by
  userId: order_by
  websiteUrl: order_by
}

"""primary key columns input for table: ArtistSubmission"""
input ArtistSubmission_pk_columns_input {
  id: uuid!
}

"""
select columns of table "ArtistSubmission"
"""
enum ArtistSubmission_select_column {
  """column name"""
  artProcess

  """column name"""
  artistStatement

  """column name"""
  discordHandle

  """column name"""
  id

  """column name"""
  instagramName

  """column name"""
  isCopyrightVerified

  """column name"""
  status

  """column name"""
  timeCreated

  """column name"""
  twitterName

  """column name"""
  userId

  """column name"""
  websiteUrl
}

"""
input type for updating data in table "ArtistSubmission"
"""
input ArtistSubmission_set_input {
  artProcess: String
  artistStatement: String
  discordHandle: String
  id: uuid
  instagramName: String
  isCopyrightVerified: Boolean
  status: ArtistSubmissionStatus_enum
  timeCreated: timestamptz
  twitterName: String
  userId: String
  websiteUrl: String
}

"""
update columns of table "ArtistSubmission"
"""
enum ArtistSubmission_update_column {
  """column name"""
  artProcess

  """column name"""
  artistStatement

  """column name"""
  discordHandle

  """column name"""
  id

  """column name"""
  instagramName

  """column name"""
  isCopyrightVerified

  """column name"""
  status

  """column name"""
  timeCreated

  """column name"""
  twitterName

  """column name"""
  userId

  """column name"""
  websiteUrl
}

"""
A Relay connection object on "ArtistSubmission"
"""
type ArtistSubmissionConnection {
  edges: [ArtistSubmissionEdge!]!
  pageInfo: PageInfo!
}

type ArtistSubmissionEdge {
  cursor: String!
  node: ArtistSubmission!
}

"""Status of an artist submission"""
type ArtistSubmissionStatus implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "ArtistSubmissionStatus". All fields are combined with a logical 'AND'.
"""
input ArtistSubmissionStatus_bool_exp {
  _and: [ArtistSubmissionStatus_bool_exp!]
  _not: ArtistSubmissionStatus_bool_exp
  _or: [ArtistSubmissionStatus_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "ArtistSubmissionStatus"
"""
enum ArtistSubmissionStatus_constraint {
  """unique or primary key constraint"""
  ArtistSubmissionStatus_pkey
}

enum ArtistSubmissionStatus_enum {
  Approved
  ApprovedWithoutVoting
  Pending
  Rejected
  VoteActive
}

"""
Boolean expression to compare columns of type "ArtistSubmissionStatus_enum". All fields are combined with logical 'AND'.
"""
input ArtistSubmissionStatus_enum_comparison_exp {
  _eq: ArtistSubmissionStatus_enum
  _in: [ArtistSubmissionStatus_enum!]
  _is_null: Boolean
  _neq: ArtistSubmissionStatus_enum
  _nin: [ArtistSubmissionStatus_enum!]
}

"""
input type for inserting data into table "ArtistSubmissionStatus"
"""
input ArtistSubmissionStatus_insert_input {
  value: String
}

"""
response of any mutation on the table "ArtistSubmissionStatus"
"""
type ArtistSubmissionStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ArtistSubmissionStatus!]!
}

"""
on_conflict condition type for table "ArtistSubmissionStatus"
"""
input ArtistSubmissionStatus_on_conflict {
  constraint: ArtistSubmissionStatus_constraint!
  update_columns: [ArtistSubmissionStatus_update_column!]! = []
  where: ArtistSubmissionStatus_bool_exp
}

"""Ordering options when selecting data from "ArtistSubmissionStatus"."""
input ArtistSubmissionStatus_order_by {
  value: order_by
}

"""primary key columns input for table: ArtistSubmissionStatus"""
input ArtistSubmissionStatus_pk_columns_input {
  value: String!
}

"""
select columns of table "ArtistSubmissionStatus"
"""
enum ArtistSubmissionStatus_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "ArtistSubmissionStatus"
"""
input ArtistSubmissionStatus_set_input {
  value: String
}

"""
update columns of table "ArtistSubmissionStatus"
"""
enum ArtistSubmissionStatus_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "ArtistSubmissionStatus"
"""
type ArtistSubmissionStatusConnection {
  edges: [ArtistSubmissionStatusEdge!]!
  pageInfo: PageInfo!
}

type ArtistSubmissionStatusEdge {
  cursor: String!
  node: ArtistSubmissionStatus!
}

"""A single asset (e.g. a photo or a video)"""
type Asset implements Node {
  artistSubmissionId: uuid
  arweaveTxid: String
  campaignGalleryAssetCampaignId: uuid
  contentType: String!
  downloadUrl: String!
  downloadUrlDarkMode: String
  height: Int
  id: ID!
  path: String!
  pathDarkMode: String
  postId: uuid
  premintPreviewAssetCandyMachineId: uuid
  userId: String
  videoPlaybackId: String
  width: Int
}

"""
aggregated selection of "Asset"
"""
type Asset_aggregate {
  aggregate: Asset_aggregate_fields
  nodes: [Asset!]!
}

"""
aggregate fields of "Asset"
"""
type Asset_aggregate_fields {
  avg: Asset_avg_fields
  count(columns: [Asset_select_column!], distinct: Boolean): Int!
  max: Asset_max_fields
  min: Asset_min_fields
  stddev: Asset_stddev_fields
  stddev_pop: Asset_stddev_pop_fields
  stddev_samp: Asset_stddev_samp_fields
  sum: Asset_sum_fields
  var_pop: Asset_var_pop_fields
  var_samp: Asset_var_samp_fields
  variance: Asset_variance_fields
}

"""
order by aggregate values of table "Asset"
"""
input Asset_aggregate_order_by {
  avg: Asset_avg_order_by
  count: order_by
  max: Asset_max_order_by
  min: Asset_min_order_by
  stddev: Asset_stddev_order_by
  stddev_pop: Asset_stddev_pop_order_by
  stddev_samp: Asset_stddev_samp_order_by
  sum: Asset_sum_order_by
  var_pop: Asset_var_pop_order_by
  var_samp: Asset_var_samp_order_by
  variance: Asset_variance_order_by
}

"""
input type for inserting array relation for remote table "Asset"
"""
input Asset_arr_rel_insert_input {
  data: [Asset_insert_input!]!

  """upsert condition"""
  on_conflict: Asset_on_conflict
}

"""aggregate avg on columns"""
type Asset_avg_fields {
  height: Float
  width: Float
}

"""
order by avg() on columns of table "Asset"
"""
input Asset_avg_order_by {
  height: order_by
  width: order_by
}

"""
Boolean expression to filter rows from the table "Asset". All fields are combined with a logical 'AND'.
"""
input Asset_bool_exp {
  _and: [Asset_bool_exp!]
  _not: Asset_bool_exp
  _or: [Asset_bool_exp!]
  artistSubmissionId: uuid_comparison_exp
  arweaveTxid: String_comparison_exp
  campaignGalleryAssetCampaignId: uuid_comparison_exp
  contentType: String_comparison_exp
  downloadUrl: String_comparison_exp
  downloadUrlDarkMode: String_comparison_exp
  height: Int_comparison_exp
  id: uuid_comparison_exp
  path: String_comparison_exp
  pathDarkMode: String_comparison_exp
  postId: uuid_comparison_exp
  premintPreviewAssetCandyMachineId: uuid_comparison_exp
  userId: String_comparison_exp
  videoPlaybackId: String_comparison_exp
  width: Int_comparison_exp
}

"""
unique or primary key constraints on table "Asset"
"""
enum Asset_constraint {
  """unique or primary key constraint"""
  Asset_pkey
}

"""
input type for incrementing numeric columns in table "Asset"
"""
input Asset_inc_input {
  height: Int
  width: Int
}

"""
input type for inserting data into table "Asset"
"""
input Asset_insert_input {
  artistSubmissionId: uuid
  arweaveTxid: String
  campaignGalleryAssetCampaignId: uuid
  contentType: String
  downloadUrl: String
  downloadUrlDarkMode: String
  height: Int
  id: uuid
  path: String
  pathDarkMode: String
  postId: uuid
  premintPreviewAssetCandyMachineId: uuid
  userId: String
  videoPlaybackId: String
  width: Int
}

"""aggregate max on columns"""
type Asset_max_fields {
  artistSubmissionId: uuid
  arweaveTxid: String
  campaignGalleryAssetCampaignId: uuid
  contentType: String
  downloadUrl: String
  downloadUrlDarkMode: String
  height: Int
  id: uuid
  path: String
  pathDarkMode: String
  postId: uuid
  premintPreviewAssetCandyMachineId: uuid
  userId: String
  videoPlaybackId: String
  width: Int
}

"""
order by max() on columns of table "Asset"
"""
input Asset_max_order_by {
  artistSubmissionId: order_by
  arweaveTxid: order_by
  campaignGalleryAssetCampaignId: order_by
  contentType: order_by
  downloadUrl: order_by
  downloadUrlDarkMode: order_by
  height: order_by
  id: order_by
  path: order_by
  pathDarkMode: order_by
  postId: order_by
  premintPreviewAssetCandyMachineId: order_by
  userId: order_by
  videoPlaybackId: order_by
  width: order_by
}

"""aggregate min on columns"""
type Asset_min_fields {
  artistSubmissionId: uuid
  arweaveTxid: String
  campaignGalleryAssetCampaignId: uuid
  contentType: String
  downloadUrl: String
  downloadUrlDarkMode: String
  height: Int
  id: uuid
  path: String
  pathDarkMode: String
  postId: uuid
  premintPreviewAssetCandyMachineId: uuid
  userId: String
  videoPlaybackId: String
  width: Int
}

"""
order by min() on columns of table "Asset"
"""
input Asset_min_order_by {
  artistSubmissionId: order_by
  arweaveTxid: order_by
  campaignGalleryAssetCampaignId: order_by
  contentType: order_by
  downloadUrl: order_by
  downloadUrlDarkMode: order_by
  height: order_by
  id: order_by
  path: order_by
  pathDarkMode: order_by
  postId: order_by
  premintPreviewAssetCandyMachineId: order_by
  userId: order_by
  videoPlaybackId: order_by
  width: order_by
}

"""
response of any mutation on the table "Asset"
"""
type Asset_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Asset!]!
}

"""
input type for inserting object relation for remote table "Asset"
"""
input Asset_obj_rel_insert_input {
  data: Asset_insert_input!

  """upsert condition"""
  on_conflict: Asset_on_conflict
}

"""
on_conflict condition type for table "Asset"
"""
input Asset_on_conflict {
  constraint: Asset_constraint!
  update_columns: [Asset_update_column!]! = []
  where: Asset_bool_exp
}

"""Ordering options when selecting data from "Asset"."""
input Asset_order_by {
  artistSubmissionId: order_by
  arweaveTxid: order_by
  campaignGalleryAssetCampaignId: order_by
  contentType: order_by
  downloadUrl: order_by
  downloadUrlDarkMode: order_by
  height: order_by
  id: order_by
  path: order_by
  pathDarkMode: order_by
  postId: order_by
  premintPreviewAssetCandyMachineId: order_by
  userId: order_by
  videoPlaybackId: order_by
  width: order_by
}

"""primary key columns input for table: Asset"""
input Asset_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Asset"
"""
enum Asset_select_column {
  """column name"""
  artistSubmissionId

  """column name"""
  arweaveTxid

  """column name"""
  campaignGalleryAssetCampaignId

  """column name"""
  contentType

  """column name"""
  downloadUrl

  """column name"""
  downloadUrlDarkMode

  """column name"""
  height

  """column name"""
  id

  """column name"""
  path

  """column name"""
  pathDarkMode

  """column name"""
  postId

  """column name"""
  premintPreviewAssetCandyMachineId

  """column name"""
  userId

  """column name"""
  videoPlaybackId

  """column name"""
  width
}

"""
input type for updating data in table "Asset"
"""
input Asset_set_input {
  artistSubmissionId: uuid
  arweaveTxid: String
  campaignGalleryAssetCampaignId: uuid
  contentType: String
  downloadUrl: String
  downloadUrlDarkMode: String
  height: Int
  id: uuid
  path: String
  pathDarkMode: String
  postId: uuid
  premintPreviewAssetCandyMachineId: uuid
  userId: String
  videoPlaybackId: String
  width: Int
}

"""aggregate stddev on columns"""
type Asset_stddev_fields {
  height: Float
  width: Float
}

"""
order by stddev() on columns of table "Asset"
"""
input Asset_stddev_order_by {
  height: order_by
  width: order_by
}

"""aggregate stddev_pop on columns"""
type Asset_stddev_pop_fields {
  height: Float
  width: Float
}

"""
order by stddev_pop() on columns of table "Asset"
"""
input Asset_stddev_pop_order_by {
  height: order_by
  width: order_by
}

"""aggregate stddev_samp on columns"""
type Asset_stddev_samp_fields {
  height: Float
  width: Float
}

"""
order by stddev_samp() on columns of table "Asset"
"""
input Asset_stddev_samp_order_by {
  height: order_by
  width: order_by
}

"""aggregate sum on columns"""
type Asset_sum_fields {
  height: Int
  width: Int
}

"""
order by sum() on columns of table "Asset"
"""
input Asset_sum_order_by {
  height: order_by
  width: order_by
}

"""
update columns of table "Asset"
"""
enum Asset_update_column {
  """column name"""
  artistSubmissionId

  """column name"""
  arweaveTxid

  """column name"""
  campaignGalleryAssetCampaignId

  """column name"""
  contentType

  """column name"""
  downloadUrl

  """column name"""
  downloadUrlDarkMode

  """column name"""
  height

  """column name"""
  id

  """column name"""
  path

  """column name"""
  pathDarkMode

  """column name"""
  postId

  """column name"""
  premintPreviewAssetCandyMachineId

  """column name"""
  userId

  """column name"""
  videoPlaybackId

  """column name"""
  width
}

"""aggregate var_pop on columns"""
type Asset_var_pop_fields {
  height: Float
  width: Float
}

"""
order by var_pop() on columns of table "Asset"
"""
input Asset_var_pop_order_by {
  height: order_by
  width: order_by
}

"""aggregate var_samp on columns"""
type Asset_var_samp_fields {
  height: Float
  width: Float
}

"""
order by var_samp() on columns of table "Asset"
"""
input Asset_var_samp_order_by {
  height: order_by
  width: order_by
}

"""aggregate variance on columns"""
type Asset_variance_fields {
  height: Float
  width: Float
}

"""
order by variance() on columns of table "Asset"
"""
input Asset_variance_order_by {
  height: order_by
  width: order_by
}

"""
A Relay connection object on "Asset"
"""
type AssetConnection {
  edges: [AssetEdge!]!
  pageInfo: PageInfo!
}

type AssetEdge {
  cursor: String!
  node: Asset!
}

"""Attribute objects which represent NFT metadata attributes"""
type Attribute implements Node {
  id: ID!
  traitType: String!
  value: String!
}

"""
Boolean expression to filter rows from the table "Attribute". All fields are combined with a logical 'AND'.
"""
input Attribute_bool_exp {
  _and: [Attribute_bool_exp!]
  _not: Attribute_bool_exp
  _or: [Attribute_bool_exp!]
  id: uuid_comparison_exp
  traitType: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "Attribute"
"""
enum Attribute_constraint {
  """unique or primary key constraint"""
  Attribute_pkey

  """unique or primary key constraint"""
  Attribute_traitType_value_key
}

"""
input type for inserting data into table "Attribute"
"""
input Attribute_insert_input {
  id: uuid
  traitType: String
  value: String
}

"""
response of any mutation on the table "Attribute"
"""
type Attribute_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Attribute!]!
}

"""
input type for inserting object relation for remote table "Attribute"
"""
input Attribute_obj_rel_insert_input {
  data: Attribute_insert_input!

  """upsert condition"""
  on_conflict: Attribute_on_conflict
}

"""
on_conflict condition type for table "Attribute"
"""
input Attribute_on_conflict {
  constraint: Attribute_constraint!
  update_columns: [Attribute_update_column!]! = []
  where: Attribute_bool_exp
}

"""Ordering options when selecting data from "Attribute"."""
input Attribute_order_by {
  id: order_by
  traitType: order_by
  value: order_by
}

"""primary key columns input for table: Attribute"""
input Attribute_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Attribute"
"""
enum Attribute_select_column {
  """column name"""
  id

  """column name"""
  traitType

  """column name"""
  value
}

"""
input type for updating data in table "Attribute"
"""
input Attribute_set_input {
  id: uuid
  traitType: String
  value: String
}

"""
update columns of table "Attribute"
"""
enum Attribute_update_column {
  """column name"""
  id

  """column name"""
  traitType

  """column name"""
  value
}

"""
A Relay connection object on "Attribute"
"""
type AttributeConnection {
  edges: [AttributeEdge!]!
  pageInfo: PageInfo!
}

type AttributeEdge {
  cursor: String!
  node: Attribute!
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "BonkClaim"
"""
type BonkClaim implements Node {
  claimed: Boolean
  id: ID!
  timeClaimed: timestamptz
  transferTxid: String
  transferTxidBeforeSend: String
  userId: String!
}

"""
Boolean expression to filter rows from the table "BonkClaim". All fields are combined with a logical 'AND'.
"""
input BonkClaim_bool_exp {
  _and: [BonkClaim_bool_exp!]
  _not: BonkClaim_bool_exp
  _or: [BonkClaim_bool_exp!]
  claimed: Boolean_comparison_exp
  id: uuid_comparison_exp
  timeClaimed: timestamptz_comparison_exp
  transferTxid: String_comparison_exp
  transferTxidBeforeSend: String_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "BonkClaim"
"""
enum BonkClaim_constraint {
  """unique or primary key constraint"""
  BonkClaim_id_key

  """unique or primary key constraint"""
  BonkClaim_pkey

  """unique or primary key constraint"""
  BonkClaim_transferTxidBeforeSend_key

  """unique or primary key constraint"""
  BonkClaim_transferTxid_key
}

"""
input type for inserting data into table "BonkClaim"
"""
input BonkClaim_insert_input {
  claimed: Boolean
  id: uuid
  timeClaimed: timestamptz
  transferTxid: String
  transferTxidBeforeSend: String
  userId: String
}

"""
response of any mutation on the table "BonkClaim"
"""
type BonkClaim_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [BonkClaim!]!
}

"""
on_conflict condition type for table "BonkClaim"
"""
input BonkClaim_on_conflict {
  constraint: BonkClaim_constraint!
  update_columns: [BonkClaim_update_column!]! = []
  where: BonkClaim_bool_exp
}

"""Ordering options when selecting data from "BonkClaim"."""
input BonkClaim_order_by {
  claimed: order_by
  id: order_by
  timeClaimed: order_by
  transferTxid: order_by
  transferTxidBeforeSend: order_by
  userId: order_by
}

"""primary key columns input for table: BonkClaim"""
input BonkClaim_pk_columns_input {
  userId: String!
}

"""
select columns of table "BonkClaim"
"""
enum BonkClaim_select_column {
  """column name"""
  claimed

  """column name"""
  id

  """column name"""
  timeClaimed

  """column name"""
  transferTxid

  """column name"""
  transferTxidBeforeSend

  """column name"""
  userId
}

"""
input type for updating data in table "BonkClaim"
"""
input BonkClaim_set_input {
  claimed: Boolean
  id: uuid
  timeClaimed: timestamptz
  transferTxid: String
  transferTxidBeforeSend: String
  userId: String
}

"""
update columns of table "BonkClaim"
"""
enum BonkClaim_update_column {
  """column name"""
  claimed

  """column name"""
  id

  """column name"""
  timeClaimed

  """column name"""
  transferTxid

  """column name"""
  transferTxidBeforeSend

  """column name"""
  userId
}

"""
A Relay connection object on "BonkClaim"
"""
type BonkClaimConnection {
  edges: [BonkClaimEdge!]!
  pageInfo: PageInfo!
}

type BonkClaimEdge {
  cursor: String!
  node: BonkClaim!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "Campaign"
"""
type Campaign implements Node {
  aboutContactInfo: String
  aboutRisksAndChallenges: String
  aboutTheCampaign: String
  aboutTheCreator: String
  aboutTimeline: String
  category: CampaignCategory_enum!
  colorScheme: CampaignColorScheme_enum!
  creatorId: String!
  discordHref: String
  endTime: timestamptz
  fundingTierOrder(
    """JSON select path"""
    path: String
  ): jsonb
  galleryAssetOrder(
    """JSON select path"""
    path: String
  ): jsonb
  goalAmount: bigint!
  goalCurrencyId: uuid
  goalProgressSymbol: String!
  goalType: CampaignGoalType_enum!
  id: ID!
  instagramHref: String
  previewAssetId: uuid!
  slug: String!
  status: CampaignStatus_enum!
  tagline: String!
  timeCreated: timestamptz!
  title: String!
  twitterHref: String
  websiteHref: String
  youtubeVideoHref: String
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input Campaign_append_input {
  fundingTierOrder: jsonb
  galleryAssetOrder: jsonb
}

"""
Boolean expression to filter rows from the table "Campaign". All fields are combined with a logical 'AND'.
"""
input Campaign_bool_exp {
  _and: [Campaign_bool_exp!]
  _not: Campaign_bool_exp
  _or: [Campaign_bool_exp!]
  aboutContactInfo: String_comparison_exp
  aboutRisksAndChallenges: String_comparison_exp
  aboutTheCampaign: String_comparison_exp
  aboutTheCreator: String_comparison_exp
  aboutTimeline: String_comparison_exp
  category: CampaignCategory_enum_comparison_exp
  colorScheme: CampaignColorScheme_enum_comparison_exp
  creatorId: String_comparison_exp
  discordHref: String_comparison_exp
  endTime: timestamptz_comparison_exp
  fundingTierOrder: jsonb_comparison_exp
  galleryAssetOrder: jsonb_comparison_exp
  goalAmount: bigint_comparison_exp
  goalCurrencyId: uuid_comparison_exp
  goalProgressSymbol: String_comparison_exp
  goalType: CampaignGoalType_enum_comparison_exp
  id: uuid_comparison_exp
  instagramHref: String_comparison_exp
  previewAssetId: uuid_comparison_exp
  slug: String_comparison_exp
  status: CampaignStatus_enum_comparison_exp
  tagline: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  title: String_comparison_exp
  twitterHref: String_comparison_exp
  websiteHref: String_comparison_exp
  youtubeVideoHref: String_comparison_exp
}

"""
unique or primary key constraints on table "Campaign"
"""
enum Campaign_constraint {
  """unique or primary key constraint"""
  Campaign_creatorId_slug_key

  """unique or primary key constraint"""
  Campaign_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Campaign_delete_at_path_input {
  fundingTierOrder: [String!]
  galleryAssetOrder: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input Campaign_delete_elem_input {
  fundingTierOrder: Int
  galleryAssetOrder: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Campaign_delete_key_input {
  fundingTierOrder: String
  galleryAssetOrder: String
}

"""
input type for incrementing numeric columns in table "Campaign"
"""
input Campaign_inc_input {
  goalAmount: bigint
}

"""
input type for inserting data into table "Campaign"
"""
input Campaign_insert_input {
  aboutContactInfo: String
  aboutRisksAndChallenges: String
  aboutTheCampaign: String
  aboutTheCreator: String
  aboutTimeline: String
  category: CampaignCategory_enum
  colorScheme: CampaignColorScheme_enum
  creatorId: String
  discordHref: String
  endTime: timestamptz
  fundingTierOrder: jsonb
  galleryAssetOrder: jsonb
  goalAmount: bigint
  goalCurrencyId: uuid
  goalProgressSymbol: String
  goalType: CampaignGoalType_enum
  id: uuid
  instagramHref: String
  previewAssetId: uuid
  slug: String
  status: CampaignStatus_enum
  tagline: String
  timeCreated: timestamptz
  title: String
  twitterHref: String
  websiteHref: String
  youtubeVideoHref: String
}

"""
response of any mutation on the table "Campaign"
"""
type Campaign_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Campaign!]!
}

"""
on_conflict condition type for table "Campaign"
"""
input Campaign_on_conflict {
  constraint: Campaign_constraint!
  update_columns: [Campaign_update_column!]! = []
  where: Campaign_bool_exp
}

"""Ordering options when selecting data from "Campaign"."""
input Campaign_order_by {
  aboutContactInfo: order_by
  aboutRisksAndChallenges: order_by
  aboutTheCampaign: order_by
  aboutTheCreator: order_by
  aboutTimeline: order_by
  category: order_by
  colorScheme: order_by
  creatorId: order_by
  discordHref: order_by
  endTime: order_by
  fundingTierOrder: order_by
  galleryAssetOrder: order_by
  goalAmount: order_by
  goalCurrencyId: order_by
  goalProgressSymbol: order_by
  goalType: order_by
  id: order_by
  instagramHref: order_by
  previewAssetId: order_by
  slug: order_by
  status: order_by
  tagline: order_by
  timeCreated: order_by
  title: order_by
  twitterHref: order_by
  websiteHref: order_by
  youtubeVideoHref: order_by
}

"""primary key columns input for table: Campaign"""
input Campaign_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input Campaign_prepend_input {
  fundingTierOrder: jsonb
  galleryAssetOrder: jsonb
}

"""
select columns of table "Campaign"
"""
enum Campaign_select_column {
  """column name"""
  aboutContactInfo

  """column name"""
  aboutRisksAndChallenges

  """column name"""
  aboutTheCampaign

  """column name"""
  aboutTheCreator

  """column name"""
  aboutTimeline

  """column name"""
  category

  """column name"""
  colorScheme

  """column name"""
  creatorId

  """column name"""
  discordHref

  """column name"""
  endTime

  """column name"""
  fundingTierOrder

  """column name"""
  galleryAssetOrder

  """column name"""
  goalAmount

  """column name"""
  goalCurrencyId

  """column name"""
  goalProgressSymbol

  """column name"""
  goalType

  """column name"""
  id

  """column name"""
  instagramHref

  """column name"""
  previewAssetId

  """column name"""
  slug

  """column name"""
  status

  """column name"""
  tagline

  """column name"""
  timeCreated

  """column name"""
  title

  """column name"""
  twitterHref

  """column name"""
  websiteHref

  """column name"""
  youtubeVideoHref
}

"""
input type for updating data in table "Campaign"
"""
input Campaign_set_input {
  aboutContactInfo: String
  aboutRisksAndChallenges: String
  aboutTheCampaign: String
  aboutTheCreator: String
  aboutTimeline: String
  category: CampaignCategory_enum
  colorScheme: CampaignColorScheme_enum
  creatorId: String
  discordHref: String
  endTime: timestamptz
  fundingTierOrder: jsonb
  galleryAssetOrder: jsonb
  goalAmount: bigint
  goalCurrencyId: uuid
  goalProgressSymbol: String
  goalType: CampaignGoalType_enum
  id: uuid
  instagramHref: String
  previewAssetId: uuid
  slug: String
  status: CampaignStatus_enum
  tagline: String
  timeCreated: timestamptz
  title: String
  twitterHref: String
  websiteHref: String
  youtubeVideoHref: String
}

"""
update columns of table "Campaign"
"""
enum Campaign_update_column {
  """column name"""
  aboutContactInfo

  """column name"""
  aboutRisksAndChallenges

  """column name"""
  aboutTheCampaign

  """column name"""
  aboutTheCreator

  """column name"""
  aboutTimeline

  """column name"""
  category

  """column name"""
  colorScheme

  """column name"""
  creatorId

  """column name"""
  discordHref

  """column name"""
  endTime

  """column name"""
  fundingTierOrder

  """column name"""
  galleryAssetOrder

  """column name"""
  goalAmount

  """column name"""
  goalCurrencyId

  """column name"""
  goalProgressSymbol

  """column name"""
  goalType

  """column name"""
  id

  """column name"""
  instagramHref

  """column name"""
  previewAssetId

  """column name"""
  slug

  """column name"""
  status

  """column name"""
  tagline

  """column name"""
  timeCreated

  """column name"""
  title

  """column name"""
  twitterHref

  """column name"""
  websiteHref

  """column name"""
  youtubeVideoHref
}

"""
columns and relationships of "CampaignBenefit"
"""
type CampaignBenefit implements Node {
  campaignFundingTierId: uuid!
  description: String!
  id: ID!
  timeCreated: timestamptz!
}

"""
Boolean expression to filter rows from the table "CampaignBenefit". All fields are combined with a logical 'AND'.
"""
input CampaignBenefit_bool_exp {
  _and: [CampaignBenefit_bool_exp!]
  _not: CampaignBenefit_bool_exp
  _or: [CampaignBenefit_bool_exp!]
  campaignFundingTierId: uuid_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "CampaignBenefit"
"""
enum CampaignBenefit_constraint {
  """unique or primary key constraint"""
  CampaignBenefit_pkey
}

"""
input type for inserting data into table "CampaignBenefit"
"""
input CampaignBenefit_insert_input {
  campaignFundingTierId: uuid
  description: String
  id: uuid
  timeCreated: timestamptz
}

"""
response of any mutation on the table "CampaignBenefit"
"""
type CampaignBenefit_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignBenefit!]!
}

"""
on_conflict condition type for table "CampaignBenefit"
"""
input CampaignBenefit_on_conflict {
  constraint: CampaignBenefit_constraint!
  update_columns: [CampaignBenefit_update_column!]! = []
  where: CampaignBenefit_bool_exp
}

"""Ordering options when selecting data from "CampaignBenefit"."""
input CampaignBenefit_order_by {
  campaignFundingTierId: order_by
  description: order_by
  id: order_by
  timeCreated: order_by
}

"""primary key columns input for table: CampaignBenefit"""
input CampaignBenefit_pk_columns_input {
  id: uuid!
}

"""
select columns of table "CampaignBenefit"
"""
enum CampaignBenefit_select_column {
  """column name"""
  campaignFundingTierId

  """column name"""
  description

  """column name"""
  id

  """column name"""
  timeCreated
}

"""
input type for updating data in table "CampaignBenefit"
"""
input CampaignBenefit_set_input {
  campaignFundingTierId: uuid
  description: String
  id: uuid
  timeCreated: timestamptz
}

"""
update columns of table "CampaignBenefit"
"""
enum CampaignBenefit_update_column {
  """column name"""
  campaignFundingTierId

  """column name"""
  description

  """column name"""
  id

  """column name"""
  timeCreated
}

"""
A Relay connection object on "CampaignBenefit"
"""
type CampaignBenefitConnection {
  edges: [CampaignBenefitEdge!]!
  pageInfo: PageInfo!
}

type CampaignBenefitEdge {
  cursor: String!
  node: CampaignBenefit!
}

"""
columns and relationships of "CampaignBenefitStatus"
"""
type CampaignBenefitStatus implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "CampaignBenefitStatus". All fields are combined with a logical 'AND'.
"""
input CampaignBenefitStatus_bool_exp {
  _and: [CampaignBenefitStatus_bool_exp!]
  _not: CampaignBenefitStatus_bool_exp
  _or: [CampaignBenefitStatus_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "CampaignBenefitStatus"
"""
enum CampaignBenefitStatus_constraint {
  """unique or primary key constraint"""
  CampaignBenefitStatus_pkey
}

enum CampaignBenefitStatus_enum {
  Granted
  Ongoing
  Pending
}

"""
Boolean expression to compare columns of type "CampaignBenefitStatus_enum". All fields are combined with logical 'AND'.
"""
input CampaignBenefitStatus_enum_comparison_exp {
  _eq: CampaignBenefitStatus_enum
  _in: [CampaignBenefitStatus_enum!]
  _is_null: Boolean
  _neq: CampaignBenefitStatus_enum
  _nin: [CampaignBenefitStatus_enum!]
}

"""
input type for inserting data into table "CampaignBenefitStatus"
"""
input CampaignBenefitStatus_insert_input {
  value: String
}

"""
response of any mutation on the table "CampaignBenefitStatus"
"""
type CampaignBenefitStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignBenefitStatus!]!
}

"""
on_conflict condition type for table "CampaignBenefitStatus"
"""
input CampaignBenefitStatus_on_conflict {
  constraint: CampaignBenefitStatus_constraint!
  update_columns: [CampaignBenefitStatus_update_column!]! = []
  where: CampaignBenefitStatus_bool_exp
}

"""Ordering options when selecting data from "CampaignBenefitStatus"."""
input CampaignBenefitStatus_order_by {
  value: order_by
}

"""primary key columns input for table: CampaignBenefitStatus"""
input CampaignBenefitStatus_pk_columns_input {
  value: String!
}

"""
select columns of table "CampaignBenefitStatus"
"""
enum CampaignBenefitStatus_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "CampaignBenefitStatus"
"""
input CampaignBenefitStatus_set_input {
  value: String
}

"""
update columns of table "CampaignBenefitStatus"
"""
enum CampaignBenefitStatus_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "CampaignBenefitStatus"
"""
type CampaignBenefitStatusConnection {
  edges: [CampaignBenefitStatusEdge!]!
  pageInfo: PageInfo!
}

type CampaignBenefitStatusEdge {
  cursor: String!
  node: CampaignBenefitStatus!
}

"""
columns and relationships of "CampaignBenefitToNft"
"""
type CampaignBenefitToNft implements Node {
  campaignBenefitId: uuid!
  id: ID!
  nftId: String!
  status: CampaignBenefitStatus_enum!
}

"""
Boolean expression to filter rows from the table "CampaignBenefitToNft". All fields are combined with a logical 'AND'.
"""
input CampaignBenefitToNft_bool_exp {
  _and: [CampaignBenefitToNft_bool_exp!]
  _not: CampaignBenefitToNft_bool_exp
  _or: [CampaignBenefitToNft_bool_exp!]
  campaignBenefitId: uuid_comparison_exp
  id: uuid_comparison_exp
  nftId: String_comparison_exp
  status: CampaignBenefitStatus_enum_comparison_exp
}

"""
unique or primary key constraints on table "CampaignBenefitToNft"
"""
enum CampaignBenefitToNft_constraint {
  """unique or primary key constraint"""
  CampaignBenefitToNft_campaignBenefitId_nftId_key

  """unique or primary key constraint"""
  CampaignBenefitToNft_pkey
}

"""
input type for inserting data into table "CampaignBenefitToNft"
"""
input CampaignBenefitToNft_insert_input {
  campaignBenefitId: uuid
  id: uuid
  nftId: String
  status: CampaignBenefitStatus_enum
}

"""
response of any mutation on the table "CampaignBenefitToNft"
"""
type CampaignBenefitToNft_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignBenefitToNft!]!
}

"""
on_conflict condition type for table "CampaignBenefitToNft"
"""
input CampaignBenefitToNft_on_conflict {
  constraint: CampaignBenefitToNft_constraint!
  update_columns: [CampaignBenefitToNft_update_column!]! = []
  where: CampaignBenefitToNft_bool_exp
}

"""Ordering options when selecting data from "CampaignBenefitToNft"."""
input CampaignBenefitToNft_order_by {
  campaignBenefitId: order_by
  id: order_by
  nftId: order_by
  status: order_by
}

"""primary key columns input for table: CampaignBenefitToNft"""
input CampaignBenefitToNft_pk_columns_input {
  id: uuid!
}

"""
select columns of table "CampaignBenefitToNft"
"""
enum CampaignBenefitToNft_select_column {
  """column name"""
  campaignBenefitId

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  status
}

"""
input type for updating data in table "CampaignBenefitToNft"
"""
input CampaignBenefitToNft_set_input {
  campaignBenefitId: uuid
  id: uuid
  nftId: String
  status: CampaignBenefitStatus_enum
}

"""
update columns of table "CampaignBenefitToNft"
"""
enum CampaignBenefitToNft_update_column {
  """column name"""
  campaignBenefitId

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  status
}

"""
A Relay connection object on "CampaignBenefitToNft"
"""
type CampaignBenefitToNftConnection {
  edges: [CampaignBenefitToNftEdge!]!
  pageInfo: PageInfo!
}

type CampaignBenefitToNftEdge {
  cursor: String!
  node: CampaignBenefitToNft!
}

"""
columns and relationships of "CampaignCategory"
"""
type CampaignCategory implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "CampaignCategory". All fields are combined with a logical 'AND'.
"""
input CampaignCategory_bool_exp {
  _and: [CampaignCategory_bool_exp!]
  _not: CampaignCategory_bool_exp
  _or: [CampaignCategory_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "CampaignCategory"
"""
enum CampaignCategory_constraint {
  """unique or primary key constraint"""
  CampaignCategory_pkey
}

enum CampaignCategory_enum {
  Art
  Brand
  Comics
  Culture
  DanceAndTheater
  Design
  Education
  Fashion
  FilmAndVideo
  Food
  Games
  Music
  Photography
  Podcasts
  Product
  Writing
}

"""
Boolean expression to compare columns of type "CampaignCategory_enum". All fields are combined with logical 'AND'.
"""
input CampaignCategory_enum_comparison_exp {
  _eq: CampaignCategory_enum
  _in: [CampaignCategory_enum!]
  _is_null: Boolean
  _neq: CampaignCategory_enum
  _nin: [CampaignCategory_enum!]
}

"""
input type for inserting data into table "CampaignCategory"
"""
input CampaignCategory_insert_input {
  value: String
}

"""
response of any mutation on the table "CampaignCategory"
"""
type CampaignCategory_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignCategory!]!
}

"""
on_conflict condition type for table "CampaignCategory"
"""
input CampaignCategory_on_conflict {
  constraint: CampaignCategory_constraint!
  update_columns: [CampaignCategory_update_column!]! = []
  where: CampaignCategory_bool_exp
}

"""Ordering options when selecting data from "CampaignCategory"."""
input CampaignCategory_order_by {
  value: order_by
}

"""primary key columns input for table: CampaignCategory"""
input CampaignCategory_pk_columns_input {
  value: String!
}

"""
select columns of table "CampaignCategory"
"""
enum CampaignCategory_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "CampaignCategory"
"""
input CampaignCategory_set_input {
  value: String
}

"""
update columns of table "CampaignCategory"
"""
enum CampaignCategory_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "CampaignCategory"
"""
type CampaignCategoryConnection {
  edges: [CampaignCategoryEdge!]!
  pageInfo: PageInfo!
}

type CampaignCategoryEdge {
  cursor: String!
  node: CampaignCategory!
}

"""
columns and relationships of "CampaignColorScheme"
"""
type CampaignColorScheme implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "CampaignColorScheme". All fields are combined with a logical 'AND'.
"""
input CampaignColorScheme_bool_exp {
  _and: [CampaignColorScheme_bool_exp!]
  _not: CampaignColorScheme_bool_exp
  _or: [CampaignColorScheme_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "CampaignColorScheme"
"""
enum CampaignColorScheme_constraint {
  """unique or primary key constraint"""
  CampaignColorScheme_pkey
}

enum CampaignColorScheme_enum {
  AliceBlueSinopia
  AntiFlashWhiteDarkGunmetal
  BrightGrayMediumBlue
  CulturedCadmiumGreen
  GreenishGrayMidnightBlue
  SeashellMaximumRed
}

"""
Boolean expression to compare columns of type "CampaignColorScheme_enum". All fields are combined with logical 'AND'.
"""
input CampaignColorScheme_enum_comparison_exp {
  _eq: CampaignColorScheme_enum
  _in: [CampaignColorScheme_enum!]
  _is_null: Boolean
  _neq: CampaignColorScheme_enum
  _nin: [CampaignColorScheme_enum!]
}

"""
input type for inserting data into table "CampaignColorScheme"
"""
input CampaignColorScheme_insert_input {
  value: String
}

"""
response of any mutation on the table "CampaignColorScheme"
"""
type CampaignColorScheme_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignColorScheme!]!
}

"""
on_conflict condition type for table "CampaignColorScheme"
"""
input CampaignColorScheme_on_conflict {
  constraint: CampaignColorScheme_constraint!
  update_columns: [CampaignColorScheme_update_column!]! = []
  where: CampaignColorScheme_bool_exp
}

"""Ordering options when selecting data from "CampaignColorScheme"."""
input CampaignColorScheme_order_by {
  value: order_by
}

"""primary key columns input for table: CampaignColorScheme"""
input CampaignColorScheme_pk_columns_input {
  value: String!
}

"""
select columns of table "CampaignColorScheme"
"""
enum CampaignColorScheme_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "CampaignColorScheme"
"""
input CampaignColorScheme_set_input {
  value: String
}

"""
update columns of table "CampaignColorScheme"
"""
enum CampaignColorScheme_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "CampaignColorScheme"
"""
type CampaignColorSchemeConnection {
  edges: [CampaignColorSchemeEdge!]!
  pageInfo: PageInfo!
}

type CampaignColorSchemeEdge {
  cursor: String!
  node: CampaignColorScheme!
}

"""
A Relay connection object on "Campaign"
"""
type CampaignConnection {
  edges: [CampaignEdge!]!
  pageInfo: PageInfo!
}

type CampaignEdge {
  cursor: String!
  node: Campaign!
}

"""
columns and relationships of "CampaignFundingTier"
"""
type CampaignFundingTier implements Node {
  campaignId: uuid!
  description: String!
  id: ID!
  nftOrder(
    """JSON select path"""
    path: String
  ): jsonb
  timeCreated: timestamptz!
  title: String!
  type: CampaignFundingTierType_enum!
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input CampaignFundingTier_append_input {
  nftOrder: jsonb
}

"""
Boolean expression to filter rows from the table "CampaignFundingTier". All fields are combined with a logical 'AND'.
"""
input CampaignFundingTier_bool_exp {
  _and: [CampaignFundingTier_bool_exp!]
  _not: CampaignFundingTier_bool_exp
  _or: [CampaignFundingTier_bool_exp!]
  campaignId: uuid_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  nftOrder: jsonb_comparison_exp
  timeCreated: timestamptz_comparison_exp
  title: String_comparison_exp
  type: CampaignFundingTierType_enum_comparison_exp
}

"""
unique or primary key constraints on table "CampaignFundingTier"
"""
enum CampaignFundingTier_constraint {
  """unique or primary key constraint"""
  CampaignFundingTier_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input CampaignFundingTier_delete_at_path_input {
  nftOrder: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input CampaignFundingTier_delete_elem_input {
  nftOrder: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input CampaignFundingTier_delete_key_input {
  nftOrder: String
}

"""
input type for inserting data into table "CampaignFundingTier"
"""
input CampaignFundingTier_insert_input {
  campaignId: uuid
  description: String
  id: uuid
  nftOrder: jsonb
  timeCreated: timestamptz
  title: String
  type: CampaignFundingTierType_enum
}

"""
response of any mutation on the table "CampaignFundingTier"
"""
type CampaignFundingTier_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignFundingTier!]!
}

"""
on_conflict condition type for table "CampaignFundingTier"
"""
input CampaignFundingTier_on_conflict {
  constraint: CampaignFundingTier_constraint!
  update_columns: [CampaignFundingTier_update_column!]! = []
  where: CampaignFundingTier_bool_exp
}

"""Ordering options when selecting data from "CampaignFundingTier"."""
input CampaignFundingTier_order_by {
  campaignId: order_by
  description: order_by
  id: order_by
  nftOrder: order_by
  timeCreated: order_by
  title: order_by
  type: order_by
}

"""primary key columns input for table: CampaignFundingTier"""
input CampaignFundingTier_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input CampaignFundingTier_prepend_input {
  nftOrder: jsonb
}

"""
select columns of table "CampaignFundingTier"
"""
enum CampaignFundingTier_select_column {
  """column name"""
  campaignId

  """column name"""
  description

  """column name"""
  id

  """column name"""
  nftOrder

  """column name"""
  timeCreated

  """column name"""
  title

  """column name"""
  type
}

"""
input type for updating data in table "CampaignFundingTier"
"""
input CampaignFundingTier_set_input {
  campaignId: uuid
  description: String
  id: uuid
  nftOrder: jsonb
  timeCreated: timestamptz
  title: String
  type: CampaignFundingTierType_enum
}

"""
update columns of table "CampaignFundingTier"
"""
enum CampaignFundingTier_update_column {
  """column name"""
  campaignId

  """column name"""
  description

  """column name"""
  id

  """column name"""
  nftOrder

  """column name"""
  timeCreated

  """column name"""
  title

  """column name"""
  type
}

"""
A Relay connection object on "CampaignFundingTier"
"""
type CampaignFundingTierConnection {
  edges: [CampaignFundingTierEdge!]!
  pageInfo: PageInfo!
}

type CampaignFundingTierEdge {
  cursor: String!
  node: CampaignFundingTier!
}

"""
columns and relationships of "CampaignFundingTierType"
"""
type CampaignFundingTierType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "CampaignFundingTierType". All fields are combined with a logical 'AND'.
"""
input CampaignFundingTierType_bool_exp {
  _and: [CampaignFundingTierType_bool_exp!]
  _not: CampaignFundingTierType_bool_exp
  _or: [CampaignFundingTierType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "CampaignFundingTierType"
"""
enum CampaignFundingTierType_constraint {
  """unique or primary key constraint"""
  CampaignFundingTierType_pkey
}

enum CampaignFundingTierType_enum {
  Gacha
  Standard
}

"""
Boolean expression to compare columns of type "CampaignFundingTierType_enum". All fields are combined with logical 'AND'.
"""
input CampaignFundingTierType_enum_comparison_exp {
  _eq: CampaignFundingTierType_enum
  _in: [CampaignFundingTierType_enum!]
  _is_null: Boolean
  _neq: CampaignFundingTierType_enum
  _nin: [CampaignFundingTierType_enum!]
}

"""
input type for inserting data into table "CampaignFundingTierType"
"""
input CampaignFundingTierType_insert_input {
  value: String
}

"""
response of any mutation on the table "CampaignFundingTierType"
"""
type CampaignFundingTierType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignFundingTierType!]!
}

"""
on_conflict condition type for table "CampaignFundingTierType"
"""
input CampaignFundingTierType_on_conflict {
  constraint: CampaignFundingTierType_constraint!
  update_columns: [CampaignFundingTierType_update_column!]! = []
  where: CampaignFundingTierType_bool_exp
}

"""Ordering options when selecting data from "CampaignFundingTierType"."""
input CampaignFundingTierType_order_by {
  value: order_by
}

"""primary key columns input for table: CampaignFundingTierType"""
input CampaignFundingTierType_pk_columns_input {
  value: String!
}

"""
select columns of table "CampaignFundingTierType"
"""
enum CampaignFundingTierType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "CampaignFundingTierType"
"""
input CampaignFundingTierType_set_input {
  value: String
}

"""
update columns of table "CampaignFundingTierType"
"""
enum CampaignFundingTierType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "CampaignFundingTierType"
"""
type CampaignFundingTierTypeConnection {
  edges: [CampaignFundingTierTypeEdge!]!
  pageInfo: PageInfo!
}

type CampaignFundingTierTypeEdge {
  cursor: String!
  node: CampaignFundingTierType!
}

"""
columns and relationships of "CampaignGoalType"
"""
type CampaignGoalType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "CampaignGoalType". All fields are combined with a logical 'AND'.
"""
input CampaignGoalType_bool_exp {
  _and: [CampaignGoalType_bool_exp!]
  _not: CampaignGoalType_bool_exp
  _or: [CampaignGoalType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "CampaignGoalType"
"""
enum CampaignGoalType_constraint {
  """unique or primary key constraint"""
  CampaignGoalType_pkey
}

enum CampaignGoalType_enum {
  Monetary
  SaleCount
}

"""
Boolean expression to compare columns of type "CampaignGoalType_enum". All fields are combined with logical 'AND'.
"""
input CampaignGoalType_enum_comparison_exp {
  _eq: CampaignGoalType_enum
  _in: [CampaignGoalType_enum!]
  _is_null: Boolean
  _neq: CampaignGoalType_enum
  _nin: [CampaignGoalType_enum!]
}

"""
input type for inserting data into table "CampaignGoalType"
"""
input CampaignGoalType_insert_input {
  value: String
}

"""
response of any mutation on the table "CampaignGoalType"
"""
type CampaignGoalType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignGoalType!]!
}

"""
on_conflict condition type for table "CampaignGoalType"
"""
input CampaignGoalType_on_conflict {
  constraint: CampaignGoalType_constraint!
  update_columns: [CampaignGoalType_update_column!]! = []
  where: CampaignGoalType_bool_exp
}

"""Ordering options when selecting data from "CampaignGoalType"."""
input CampaignGoalType_order_by {
  value: order_by
}

"""primary key columns input for table: CampaignGoalType"""
input CampaignGoalType_pk_columns_input {
  value: String!
}

"""
select columns of table "CampaignGoalType"
"""
enum CampaignGoalType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "CampaignGoalType"
"""
input CampaignGoalType_set_input {
  value: String
}

"""
update columns of table "CampaignGoalType"
"""
enum CampaignGoalType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "CampaignGoalType"
"""
type CampaignGoalTypeConnection {
  edges: [CampaignGoalTypeEdge!]!
  pageInfo: PageInfo!
}

type CampaignGoalTypeEdge {
  cursor: String!
  node: CampaignGoalType!
}

"""
columns and relationships of "CampaignStatus"
"""
type CampaignStatus implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "CampaignStatus". All fields are combined with a logical 'AND'.
"""
input CampaignStatus_bool_exp {
  _and: [CampaignStatus_bool_exp!]
  _not: CampaignStatus_bool_exp
  _or: [CampaignStatus_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "CampaignStatus"
"""
enum CampaignStatus_constraint {
  """unique or primary key constraint"""
  CampaignStatus_pkey
}

enum CampaignStatus_enum {
  Approved
  Concluded
  Draft
  Pending
  Published
  Rejected
}

"""
Boolean expression to compare columns of type "CampaignStatus_enum". All fields are combined with logical 'AND'.
"""
input CampaignStatus_enum_comparison_exp {
  _eq: CampaignStatus_enum
  _in: [CampaignStatus_enum!]
  _is_null: Boolean
  _neq: CampaignStatus_enum
  _nin: [CampaignStatus_enum!]
}

"""
input type for inserting data into table "CampaignStatus"
"""
input CampaignStatus_insert_input {
  value: String
}

"""
response of any mutation on the table "CampaignStatus"
"""
type CampaignStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignStatus!]!
}

"""
on_conflict condition type for table "CampaignStatus"
"""
input CampaignStatus_on_conflict {
  constraint: CampaignStatus_constraint!
  update_columns: [CampaignStatus_update_column!]! = []
  where: CampaignStatus_bool_exp
}

"""Ordering options when selecting data from "CampaignStatus"."""
input CampaignStatus_order_by {
  value: order_by
}

"""primary key columns input for table: CampaignStatus"""
input CampaignStatus_pk_columns_input {
  value: String!
}

"""
select columns of table "CampaignStatus"
"""
enum CampaignStatus_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "CampaignStatus"
"""
input CampaignStatus_set_input {
  value: String
}

"""
update columns of table "CampaignStatus"
"""
enum CampaignStatus_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "CampaignStatus"
"""
type CampaignStatusConnection {
  edges: [CampaignStatusEdge!]!
  pageInfo: PageInfo!
}

type CampaignStatusEdge {
  cursor: String!
  node: CampaignStatus!
}

"""
columns and relationships of "CampaignTeamMemberRole"
"""
type CampaignTeamMemberRole implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "CampaignTeamMemberRole". All fields are combined with a logical 'AND'.
"""
input CampaignTeamMemberRole_bool_exp {
  _and: [CampaignTeamMemberRole_bool_exp!]
  _not: CampaignTeamMemberRole_bool_exp
  _or: [CampaignTeamMemberRole_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "CampaignTeamMemberRole"
"""
enum CampaignTeamMemberRole_constraint {
  """unique or primary key constraint"""
  CampaignTeamMemberRole_pkey
}

enum CampaignTeamMemberRole_enum {
  Admin
  Creator
  Member
}

"""
Boolean expression to compare columns of type "CampaignTeamMemberRole_enum". All fields are combined with logical 'AND'.
"""
input CampaignTeamMemberRole_enum_comparison_exp {
  _eq: CampaignTeamMemberRole_enum
  _in: [CampaignTeamMemberRole_enum!]
  _is_null: Boolean
  _neq: CampaignTeamMemberRole_enum
  _nin: [CampaignTeamMemberRole_enum!]
}

"""
input type for inserting data into table "CampaignTeamMemberRole"
"""
input CampaignTeamMemberRole_insert_input {
  value: String
}

"""
response of any mutation on the table "CampaignTeamMemberRole"
"""
type CampaignTeamMemberRole_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignTeamMemberRole!]!
}

"""
on_conflict condition type for table "CampaignTeamMemberRole"
"""
input CampaignTeamMemberRole_on_conflict {
  constraint: CampaignTeamMemberRole_constraint!
  update_columns: [CampaignTeamMemberRole_update_column!]! = []
  where: CampaignTeamMemberRole_bool_exp
}

"""Ordering options when selecting data from "CampaignTeamMemberRole"."""
input CampaignTeamMemberRole_order_by {
  value: order_by
}

"""primary key columns input for table: CampaignTeamMemberRole"""
input CampaignTeamMemberRole_pk_columns_input {
  value: String!
}

"""
select columns of table "CampaignTeamMemberRole"
"""
enum CampaignTeamMemberRole_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "CampaignTeamMemberRole"
"""
input CampaignTeamMemberRole_set_input {
  value: String
}

"""
update columns of table "CampaignTeamMemberRole"
"""
enum CampaignTeamMemberRole_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "CampaignTeamMemberRole"
"""
type CampaignTeamMemberRoleConnection {
  edges: [CampaignTeamMemberRoleEdge!]!
  pageInfo: PageInfo!
}

type CampaignTeamMemberRoleEdge {
  cursor: String!
  node: CampaignTeamMemberRole!
}

"""
columns and relationships of "CampaignToCollaborator"
"""
type CampaignToCollaborator implements Node {
  campaignId: uuid!
  collaboratorId: String!
  id: ID!
  requestId: uuid!
  timeCreated: timestamptz!
}

"""
Boolean expression to filter rows from the table "CampaignToCollaborator". All fields are combined with a logical 'AND'.
"""
input CampaignToCollaborator_bool_exp {
  _and: [CampaignToCollaborator_bool_exp!]
  _not: CampaignToCollaborator_bool_exp
  _or: [CampaignToCollaborator_bool_exp!]
  campaignId: uuid_comparison_exp
  collaboratorId: String_comparison_exp
  id: uuid_comparison_exp
  requestId: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "CampaignToCollaborator"
"""
enum CampaignToCollaborator_constraint {
  """unique or primary key constraint"""
  CampaignToCollaborator_campaignId_collaboratorId_key

  """unique or primary key constraint"""
  CampaignToCollaborator_pkey
}

"""
input type for inserting data into table "CampaignToCollaborator"
"""
input CampaignToCollaborator_insert_input {
  campaignId: uuid
  collaboratorId: String
  id: uuid
  requestId: uuid
  timeCreated: timestamptz
}

"""
response of any mutation on the table "CampaignToCollaborator"
"""
type CampaignToCollaborator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignToCollaborator!]!
}

"""
on_conflict condition type for table "CampaignToCollaborator"
"""
input CampaignToCollaborator_on_conflict {
  constraint: CampaignToCollaborator_constraint!
  update_columns: [CampaignToCollaborator_update_column!]! = []
  where: CampaignToCollaborator_bool_exp
}

"""Ordering options when selecting data from "CampaignToCollaborator"."""
input CampaignToCollaborator_order_by {
  campaignId: order_by
  collaboratorId: order_by
  id: order_by
  requestId: order_by
  timeCreated: order_by
}

"""primary key columns input for table: CampaignToCollaborator"""
input CampaignToCollaborator_pk_columns_input {
  id: uuid!
}

"""
select columns of table "CampaignToCollaborator"
"""
enum CampaignToCollaborator_select_column {
  """column name"""
  campaignId

  """column name"""
  collaboratorId

  """column name"""
  id

  """column name"""
  requestId

  """column name"""
  timeCreated
}

"""
input type for updating data in table "CampaignToCollaborator"
"""
input CampaignToCollaborator_set_input {
  campaignId: uuid
  collaboratorId: String
  id: uuid
  requestId: uuid
  timeCreated: timestamptz
}

"""
update columns of table "CampaignToCollaborator"
"""
enum CampaignToCollaborator_update_column {
  """column name"""
  campaignId

  """column name"""
  collaboratorId

  """column name"""
  id

  """column name"""
  requestId

  """column name"""
  timeCreated
}

"""
A Relay connection object on "CampaignToCollaborator"
"""
type CampaignToCollaboratorConnection {
  edges: [CampaignToCollaboratorEdge!]!
  pageInfo: PageInfo!
}

type CampaignToCollaboratorEdge {
  cursor: String!
  node: CampaignToCollaborator!
}

"""
columns and relationships of "CampaignToHolder"
"""
type CampaignToHolder implements Node {
  campaignId: uuid!
  holderUserId: String!
  id: ID!
  timeCreated: timestamptz!
}

"""
Boolean expression to filter rows from the table "CampaignToHolder". All fields are combined with a logical 'AND'.
"""
input CampaignToHolder_bool_exp {
  _and: [CampaignToHolder_bool_exp!]
  _not: CampaignToHolder_bool_exp
  _or: [CampaignToHolder_bool_exp!]
  campaignId: uuid_comparison_exp
  holderUserId: String_comparison_exp
  id: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "CampaignToHolder"
"""
enum CampaignToHolder_constraint {
  """unique or primary key constraint"""
  CampaignToHolder_id_key

  """unique or primary key constraint"""
  CampaignToHolder_pkey
}

"""
input type for inserting data into table "CampaignToHolder"
"""
input CampaignToHolder_insert_input {
  campaignId: uuid
  holderUserId: String
  id: uuid
  timeCreated: timestamptz
}

"""
response of any mutation on the table "CampaignToHolder"
"""
type CampaignToHolder_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignToHolder!]!
}

"""
on_conflict condition type for table "CampaignToHolder"
"""
input CampaignToHolder_on_conflict {
  constraint: CampaignToHolder_constraint!
  update_columns: [CampaignToHolder_update_column!]! = []
  where: CampaignToHolder_bool_exp
}

"""Ordering options when selecting data from "CampaignToHolder"."""
input CampaignToHolder_order_by {
  campaignId: order_by
  holderUserId: order_by
  id: order_by
  timeCreated: order_by
}

"""primary key columns input for table: CampaignToHolder"""
input CampaignToHolder_pk_columns_input {
  campaignId: uuid!
  holderUserId: String!
}

"""
select columns of table "CampaignToHolder"
"""
enum CampaignToHolder_select_column {
  """column name"""
  campaignId

  """column name"""
  holderUserId

  """column name"""
  id

  """column name"""
  timeCreated
}

"""
input type for updating data in table "CampaignToHolder"
"""
input CampaignToHolder_set_input {
  campaignId: uuid
  holderUserId: String
  id: uuid
  timeCreated: timestamptz
}

"""
update columns of table "CampaignToHolder"
"""
enum CampaignToHolder_update_column {
  """column name"""
  campaignId

  """column name"""
  holderUserId

  """column name"""
  id

  """column name"""
  timeCreated
}

"""
A Relay connection object on "CampaignToHolder"
"""
type CampaignToHolderConnection {
  edges: [CampaignToHolderEdge!]!
  pageInfo: PageInfo!
}

type CampaignToHolderEdge {
  cursor: String!
  node: CampaignToHolder!
}

"""
columns and relationships of "CampaignToTeamMember"
"""
type CampaignToTeamMember implements Node {
  campaignId: uuid!
  id: ID!
  memberId: String!
  requestId: uuid!
  role: CampaignTeamMemberRole_enum!
  timeCreated: timestamptz!
}

"""
Boolean expression to filter rows from the table "CampaignToTeamMember". All fields are combined with a logical 'AND'.
"""
input CampaignToTeamMember_bool_exp {
  _and: [CampaignToTeamMember_bool_exp!]
  _not: CampaignToTeamMember_bool_exp
  _or: [CampaignToTeamMember_bool_exp!]
  campaignId: uuid_comparison_exp
  id: uuid_comparison_exp
  memberId: String_comparison_exp
  requestId: uuid_comparison_exp
  role: CampaignTeamMemberRole_enum_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "CampaignToTeamMember"
"""
enum CampaignToTeamMember_constraint {
  """unique or primary key constraint"""
  CampaignToTeamMember_campaignId_memberId_key

  """unique or primary key constraint"""
  CampaignToTeamMember_pkey

  """unique or primary key constraint"""
  CampaignToTeamMember_requestId_key
}

"""
input type for inserting data into table "CampaignToTeamMember"
"""
input CampaignToTeamMember_insert_input {
  campaignId: uuid
  id: uuid
  memberId: String
  requestId: uuid
  role: CampaignTeamMemberRole_enum
  timeCreated: timestamptz
}

"""
response of any mutation on the table "CampaignToTeamMember"
"""
type CampaignToTeamMember_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CampaignToTeamMember!]!
}

"""
on_conflict condition type for table "CampaignToTeamMember"
"""
input CampaignToTeamMember_on_conflict {
  constraint: CampaignToTeamMember_constraint!
  update_columns: [CampaignToTeamMember_update_column!]! = []
  where: CampaignToTeamMember_bool_exp
}

"""Ordering options when selecting data from "CampaignToTeamMember"."""
input CampaignToTeamMember_order_by {
  campaignId: order_by
  id: order_by
  memberId: order_by
  requestId: order_by
  role: order_by
  timeCreated: order_by
}

"""primary key columns input for table: CampaignToTeamMember"""
input CampaignToTeamMember_pk_columns_input {
  id: uuid!
}

"""
select columns of table "CampaignToTeamMember"
"""
enum CampaignToTeamMember_select_column {
  """column name"""
  campaignId

  """column name"""
  id

  """column name"""
  memberId

  """column name"""
  requestId

  """column name"""
  role

  """column name"""
  timeCreated
}

"""
input type for updating data in table "CampaignToTeamMember"
"""
input CampaignToTeamMember_set_input {
  campaignId: uuid
  id: uuid
  memberId: String
  requestId: uuid
  role: CampaignTeamMemberRole_enum
  timeCreated: timestamptz
}

"""
update columns of table "CampaignToTeamMember"
"""
enum CampaignToTeamMember_update_column {
  """column name"""
  campaignId

  """column name"""
  id

  """column name"""
  memberId

  """column name"""
  requestId

  """column name"""
  role

  """column name"""
  timeCreated
}

"""
A Relay connection object on "CampaignToTeamMember"
"""
type CampaignToTeamMemberConnection {
  edges: [CampaignToTeamMemberEdge!]!
  pageInfo: PageInfo!
}

type CampaignToTeamMemberEdge {
  cursor: String!
  node: CampaignToTeamMember!
}

"""
columns and relationships of "CandyMachine"
"""
type CandyMachine implements Node {
  allowlistPrice: bigint
  allowlistSaleStartTime: timestamptz
  allowlistTokenMint: String
  antiBotProtectionEnabled: Boolean!

  """Authority chosen by CM project"""
  creatorAuthorityId: String!
  creatorWallets(
    """JSON select path"""
    path: String
  ): jsonb!
  currencyId: uuid!

  """Formfunction authority of the onchain Candy Machine"""
  formfnAuthorityId: String!
  id: ID!
  limitPerAddress: Int!
  maxSupply: Int!
  mintPreviewAssetId: uuid
  omniMintWallets(
    """JSON select path"""
    path: String
  ): jsonb!
  platformFeeBasisPoints: Int!
  premintPrice: bigint
  price: bigint!
  publicKey: String!
  publicSaleEndTime: timestamptz!
  publicSaleStartTime: timestamptz!
  seriesId: String!
  timeCreated: timestamptz!
  totalAmountMinted: Int!
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input CandyMachine_append_input {
  creatorWallets: jsonb
  omniMintWallets: jsonb
}

"""
Boolean expression to filter rows from the table "CandyMachine". All fields are combined with a logical 'AND'.
"""
input CandyMachine_bool_exp {
  _and: [CandyMachine_bool_exp!]
  _not: CandyMachine_bool_exp
  _or: [CandyMachine_bool_exp!]
  allowlistPrice: bigint_comparison_exp
  allowlistSaleStartTime: timestamptz_comparison_exp
  allowlistTokenMint: String_comparison_exp
  antiBotProtectionEnabled: Boolean_comparison_exp
  creatorAuthorityId: String_comparison_exp
  creatorWallets: jsonb_comparison_exp
  currencyId: uuid_comparison_exp
  formfnAuthorityId: String_comparison_exp
  id: uuid_comparison_exp
  limitPerAddress: Int_comparison_exp
  maxSupply: Int_comparison_exp
  mintPreviewAssetId: uuid_comparison_exp
  omniMintWallets: jsonb_comparison_exp
  platformFeeBasisPoints: Int_comparison_exp
  premintPrice: bigint_comparison_exp
  price: bigint_comparison_exp
  publicKey: String_comparison_exp
  publicSaleEndTime: timestamptz_comparison_exp
  publicSaleStartTime: timestamptz_comparison_exp
  seriesId: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  totalAmountMinted: Int_comparison_exp
}

"""
unique or primary key constraints on table "CandyMachine"
"""
enum CandyMachine_constraint {
  """unique or primary key constraint"""
  CandyMachine_mint_key

  """unique or primary key constraint"""
  CandyMachine_pkey

  """unique or primary key constraint"""
  CandyMachine_seriesId_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input CandyMachine_delete_at_path_input {
  creatorWallets: [String!]
  omniMintWallets: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input CandyMachine_delete_elem_input {
  creatorWallets: Int
  omniMintWallets: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input CandyMachine_delete_key_input {
  creatorWallets: String
  omniMintWallets: String
}

"""
input type for incrementing numeric columns in table "CandyMachine"
"""
input CandyMachine_inc_input {
  allowlistPrice: bigint
  limitPerAddress: Int
  maxSupply: Int
  platformFeeBasisPoints: Int
  premintPrice: bigint
  price: bigint
  totalAmountMinted: Int
}

"""
input type for inserting data into table "CandyMachine"
"""
input CandyMachine_insert_input {
  allowlistPrice: bigint
  allowlistSaleStartTime: timestamptz
  allowlistTokenMint: String
  antiBotProtectionEnabled: Boolean

  """Authority chosen by CM project"""
  creatorAuthorityId: String
  creatorWallets: jsonb
  currencyId: uuid

  """Formfunction authority of the onchain Candy Machine"""
  formfnAuthorityId: String
  id: uuid
  limitPerAddress: Int
  maxSupply: Int
  mintPreviewAssetId: uuid
  omniMintWallets: jsonb
  platformFeeBasisPoints: Int
  premintPrice: bigint
  price: bigint
  publicKey: String
  publicSaleEndTime: timestamptz
  publicSaleStartTime: timestamptz
  seriesId: String
  timeCreated: timestamptz
  totalAmountMinted: Int
}

"""
response of any mutation on the table "CandyMachine"
"""
type CandyMachine_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CandyMachine!]!
}

"""
on_conflict condition type for table "CandyMachine"
"""
input CandyMachine_on_conflict {
  constraint: CandyMachine_constraint!
  update_columns: [CandyMachine_update_column!]! = []
  where: CandyMachine_bool_exp
}

"""Ordering options when selecting data from "CandyMachine"."""
input CandyMachine_order_by {
  allowlistPrice: order_by
  allowlistSaleStartTime: order_by
  allowlistTokenMint: order_by
  antiBotProtectionEnabled: order_by
  creatorAuthorityId: order_by
  creatorWallets: order_by
  currencyId: order_by
  formfnAuthorityId: order_by
  id: order_by
  limitPerAddress: order_by
  maxSupply: order_by
  mintPreviewAssetId: order_by
  omniMintWallets: order_by
  platformFeeBasisPoints: order_by
  premintPrice: order_by
  price: order_by
  publicKey: order_by
  publicSaleEndTime: order_by
  publicSaleStartTime: order_by
  seriesId: order_by
  timeCreated: order_by
  totalAmountMinted: order_by
}

"""primary key columns input for table: CandyMachine"""
input CandyMachine_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input CandyMachine_prepend_input {
  creatorWallets: jsonb
  omniMintWallets: jsonb
}

"""
select columns of table "CandyMachine"
"""
enum CandyMachine_select_column {
  """column name"""
  allowlistPrice

  """column name"""
  allowlistSaleStartTime

  """column name"""
  allowlistTokenMint

  """column name"""
  antiBotProtectionEnabled

  """column name"""
  creatorAuthorityId

  """column name"""
  creatorWallets

  """column name"""
  currencyId

  """column name"""
  formfnAuthorityId

  """column name"""
  id

  """column name"""
  limitPerAddress

  """column name"""
  maxSupply

  """column name"""
  mintPreviewAssetId

  """column name"""
  omniMintWallets

  """column name"""
  platformFeeBasisPoints

  """column name"""
  premintPrice

  """column name"""
  price

  """column name"""
  publicKey

  """column name"""
  publicSaleEndTime

  """column name"""
  publicSaleStartTime

  """column name"""
  seriesId

  """column name"""
  timeCreated

  """column name"""
  totalAmountMinted
}

"""
input type for updating data in table "CandyMachine"
"""
input CandyMachine_set_input {
  allowlistPrice: bigint
  allowlistSaleStartTime: timestamptz
  allowlistTokenMint: String
  antiBotProtectionEnabled: Boolean

  """Authority chosen by CM project"""
  creatorAuthorityId: String
  creatorWallets: jsonb
  currencyId: uuid

  """Formfunction authority of the onchain Candy Machine"""
  formfnAuthorityId: String
  id: uuid
  limitPerAddress: Int
  maxSupply: Int
  mintPreviewAssetId: uuid
  omniMintWallets: jsonb
  platformFeeBasisPoints: Int
  premintPrice: bigint
  price: bigint
  publicKey: String
  publicSaleEndTime: timestamptz
  publicSaleStartTime: timestamptz
  seriesId: String
  timeCreated: timestamptz
  totalAmountMinted: Int
}

"""
update columns of table "CandyMachine"
"""
enum CandyMachine_update_column {
  """column name"""
  allowlistPrice

  """column name"""
  allowlistSaleStartTime

  """column name"""
  allowlistTokenMint

  """column name"""
  antiBotProtectionEnabled

  """column name"""
  creatorAuthorityId

  """column name"""
  creatorWallets

  """column name"""
  currencyId

  """column name"""
  formfnAuthorityId

  """column name"""
  id

  """column name"""
  limitPerAddress

  """column name"""
  maxSupply

  """column name"""
  mintPreviewAssetId

  """column name"""
  omniMintWallets

  """column name"""
  platformFeeBasisPoints

  """column name"""
  premintPrice

  """column name"""
  price

  """column name"""
  publicKey

  """column name"""
  publicSaleEndTime

  """column name"""
  publicSaleStartTime

  """column name"""
  seriesId

  """column name"""
  timeCreated

  """column name"""
  totalAmountMinted
}

"""
A Relay connection object on "CandyMachine"
"""
type CandyMachineConnection {
  edges: [CandyMachineEdge!]!
  pageInfo: PageInfo!
}

type CandyMachineEdge {
  cursor: String!
  node: CandyMachine!
}

"""
columns and relationships of "CandyMachineMerkleAllowlistInfo"
"""
type CandyMachineMerkleAllowlistInfo implements Node {
  amountAllowed: Int!
  candyMachineId: uuid!
  id: ID!
  proof: String!
  rootIndex: Int!
  timeCreated: timestamptz!
  userId: String!
}

"""
Boolean expression to filter rows from the table
"CandyMachineMerkleAllowlistInfo". All fields are combined with a logical 'AND'.
"""
input CandyMachineMerkleAllowlistInfo_bool_exp {
  _and: [CandyMachineMerkleAllowlistInfo_bool_exp!]
  _not: CandyMachineMerkleAllowlistInfo_bool_exp
  _or: [CandyMachineMerkleAllowlistInfo_bool_exp!]
  amountAllowed: Int_comparison_exp
  candyMachineId: uuid_comparison_exp
  id: uuid_comparison_exp
  proof: String_comparison_exp
  rootIndex: Int_comparison_exp
  timeCreated: timestamptz_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "CandyMachineMerkleAllowlistInfo"
"""
enum CandyMachineMerkleAllowlistInfo_constraint {
  """unique or primary key constraint"""
  CandyMachineMerkleAllowlistInfo_id_key

  """unique or primary key constraint"""
  CandyMachineMerkleAllowlistInfo_pkey

  """unique or primary key constraint"""
  CandyMachineMerkleAllowlistInfo_userId_candyMachineId_key
}

"""
input type for incrementing numeric columns in table "CandyMachineMerkleAllowlistInfo"
"""
input CandyMachineMerkleAllowlistInfo_inc_input {
  amountAllowed: Int
  rootIndex: Int
}

"""
input type for inserting data into table "CandyMachineMerkleAllowlistInfo"
"""
input CandyMachineMerkleAllowlistInfo_insert_input {
  amountAllowed: Int
  candyMachineId: uuid
  id: uuid
  proof: String
  rootIndex: Int
  timeCreated: timestamptz
  userId: String
}

"""
response of any mutation on the table "CandyMachineMerkleAllowlistInfo"
"""
type CandyMachineMerkleAllowlistInfo_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CandyMachineMerkleAllowlistInfo!]!
}

"""
on_conflict condition type for table "CandyMachineMerkleAllowlistInfo"
"""
input CandyMachineMerkleAllowlistInfo_on_conflict {
  constraint: CandyMachineMerkleAllowlistInfo_constraint!
  update_columns: [CandyMachineMerkleAllowlistInfo_update_column!]! = []
  where: CandyMachineMerkleAllowlistInfo_bool_exp
}

"""
Ordering options when selecting data from "CandyMachineMerkleAllowlistInfo".
"""
input CandyMachineMerkleAllowlistInfo_order_by {
  amountAllowed: order_by
  candyMachineId: order_by
  id: order_by
  proof: order_by
  rootIndex: order_by
  timeCreated: order_by
  userId: order_by
}

"""primary key columns input for table: CandyMachineMerkleAllowlistInfo"""
input CandyMachineMerkleAllowlistInfo_pk_columns_input {
  candyMachineId: uuid!
  userId: String!
}

"""
select columns of table "CandyMachineMerkleAllowlistInfo"
"""
enum CandyMachineMerkleAllowlistInfo_select_column {
  """column name"""
  amountAllowed

  """column name"""
  candyMachineId

  """column name"""
  id

  """column name"""
  proof

  """column name"""
  rootIndex

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
input type for updating data in table "CandyMachineMerkleAllowlistInfo"
"""
input CandyMachineMerkleAllowlistInfo_set_input {
  amountAllowed: Int
  candyMachineId: uuid
  id: uuid
  proof: String
  rootIndex: Int
  timeCreated: timestamptz
  userId: String
}

"""
update columns of table "CandyMachineMerkleAllowlistInfo"
"""
enum CandyMachineMerkleAllowlistInfo_update_column {
  """column name"""
  amountAllowed

  """column name"""
  candyMachineId

  """column name"""
  id

  """column name"""
  proof

  """column name"""
  rootIndex

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
A Relay connection object on "CandyMachineMerkleAllowlistInfo"
"""
type CandyMachineMerkleAllowlistInfoConnection {
  edges: [CandyMachineMerkleAllowlistInfoEdge!]!
  pageInfo: PageInfo!
}

type CandyMachineMerkleAllowlistInfoEdge {
  cursor: String!
  node: CandyMachineMerkleAllowlistInfo!
}

"""
Tracks eligible claims for participation NFT distributions to auction bidders.
"""
type Claim implements Node {
  """An object relationship"""
  NftTransaction: NftTransaction
  auctionNftId: String!
  claimTransactionId: uuid
  id: ID!
  proof: String
  timeCreated: timestamptz!
  timeLastReminded: timestamptz
  userId: String!
}

"""
Boolean expression to filter rows from the table "Claim". All fields are combined with a logical 'AND'.
"""
input Claim_bool_exp {
  NftTransaction: NftTransaction_bool_exp
  _and: [Claim_bool_exp!]
  _not: Claim_bool_exp
  _or: [Claim_bool_exp!]
  auctionNftId: String_comparison_exp
  claimTransactionId: uuid_comparison_exp
  id: uuid_comparison_exp
  proof: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  timeLastReminded: timestamptz_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "Claim"
"""
enum Claim_constraint {
  """unique or primary key constraint"""
  Claim_claimTransactionId_key

  """unique or primary key constraint"""
  Claim_id_key

  """unique or primary key constraint"""
  Claim_pkey

  """unique or primary key constraint"""
  Claim_userId_auctionNftId_key
}

"""
input type for inserting data into table "Claim"
"""
input Claim_insert_input {
  NftTransaction: NftTransaction_obj_rel_insert_input
  auctionNftId: String
  claimTransactionId: uuid
  id: uuid
  proof: String
  timeCreated: timestamptz
  timeLastReminded: timestamptz
  userId: String
}

"""
response of any mutation on the table "Claim"
"""
type Claim_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Claim!]!
}

"""
on_conflict condition type for table "Claim"
"""
input Claim_on_conflict {
  constraint: Claim_constraint!
  update_columns: [Claim_update_column!]! = []
  where: Claim_bool_exp
}

"""Ordering options when selecting data from "Claim"."""
input Claim_order_by {
  NftTransaction: NftTransaction_order_by
  auctionNftId: order_by
  claimTransactionId: order_by
  id: order_by
  proof: order_by
  timeCreated: order_by
  timeLastReminded: order_by
  userId: order_by
}

"""primary key columns input for table: Claim"""
input Claim_pk_columns_input {
  auctionNftId: String!
  userId: String!
}

"""
select columns of table "Claim"
"""
enum Claim_select_column {
  """column name"""
  auctionNftId

  """column name"""
  claimTransactionId

  """column name"""
  id

  """column name"""
  proof

  """column name"""
  timeCreated

  """column name"""
  timeLastReminded

  """column name"""
  userId
}

"""
input type for updating data in table "Claim"
"""
input Claim_set_input {
  auctionNftId: String
  claimTransactionId: uuid
  id: uuid
  proof: String
  timeCreated: timestamptz
  timeLastReminded: timestamptz
  userId: String
}

"""
update columns of table "Claim"
"""
enum Claim_update_column {
  """column name"""
  auctionNftId

  """column name"""
  claimTransactionId

  """column name"""
  id

  """column name"""
  proof

  """column name"""
  timeCreated

  """column name"""
  timeLastReminded

  """column name"""
  userId
}

"""
A Relay connection object on "Claim"
"""
type ClaimConnection {
  edges: [ClaimEdge!]!
  pageInfo: PageInfo!
}

type ClaimEdge {
  cursor: String!
  node: Claim!
}

"""
columns and relationships of "CollectorSurvey"
"""
type CollectorSurvey implements Node {
  freeform: String
  id: ID!
  recommend: Int!
  seanEllis: String!
  userId: String!
  why1: String!
  why2: String!
}

"""
Boolean expression to filter rows from the table "CollectorSurvey". All fields are combined with a logical 'AND'.
"""
input CollectorSurvey_bool_exp {
  _and: [CollectorSurvey_bool_exp!]
  _not: CollectorSurvey_bool_exp
  _or: [CollectorSurvey_bool_exp!]
  freeform: String_comparison_exp
  id: uuid_comparison_exp
  recommend: Int_comparison_exp
  seanEllis: String_comparison_exp
  userId: String_comparison_exp
  why1: String_comparison_exp
  why2: String_comparison_exp
}

"""
unique or primary key constraints on table "CollectorSurvey"
"""
enum CollectorSurvey_constraint {
  """unique or primary key constraint"""
  CollectorSurvey_pkey

  """unique or primary key constraint"""
  CollectorSurvey_userId_key
}

"""
input type for incrementing numeric columns in table "CollectorSurvey"
"""
input CollectorSurvey_inc_input {
  recommend: Int
}

"""
input type for inserting data into table "CollectorSurvey"
"""
input CollectorSurvey_insert_input {
  freeform: String
  id: uuid
  recommend: Int
  seanEllis: String
  userId: String
  why1: String
  why2: String
}

"""
response of any mutation on the table "CollectorSurvey"
"""
type CollectorSurvey_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CollectorSurvey!]!
}

"""
on_conflict condition type for table "CollectorSurvey"
"""
input CollectorSurvey_on_conflict {
  constraint: CollectorSurvey_constraint!
  update_columns: [CollectorSurvey_update_column!]! = []
  where: CollectorSurvey_bool_exp
}

"""Ordering options when selecting data from "CollectorSurvey"."""
input CollectorSurvey_order_by {
  freeform: order_by
  id: order_by
  recommend: order_by
  seanEllis: order_by
  userId: order_by
  why1: order_by
  why2: order_by
}

"""primary key columns input for table: CollectorSurvey"""
input CollectorSurvey_pk_columns_input {
  id: uuid!
}

"""
select columns of table "CollectorSurvey"
"""
enum CollectorSurvey_select_column {
  """column name"""
  freeform

  """column name"""
  id

  """column name"""
  recommend

  """column name"""
  seanEllis

  """column name"""
  userId

  """column name"""
  why1

  """column name"""
  why2
}

"""
input type for updating data in table "CollectorSurvey"
"""
input CollectorSurvey_set_input {
  freeform: String
  id: uuid
  recommend: Int
  seanEllis: String
  userId: String
  why1: String
  why2: String
}

"""
update columns of table "CollectorSurvey"
"""
enum CollectorSurvey_update_column {
  """column name"""
  freeform

  """column name"""
  id

  """column name"""
  recommend

  """column name"""
  seanEllis

  """column name"""
  userId

  """column name"""
  why1

  """column name"""
  why2
}

"""
A Relay connection object on "CollectorSurvey"
"""
type CollectorSurveyConnection {
  edges: [CollectorSurveyEdge!]!
  pageInfo: PageInfo!
}

type CollectorSurveyEdge {
  cursor: String!
  node: CollectorSurvey!
}

"""
columns and relationships of "Comment"
"""
type Comment implements Node {
  comment: String!
  commenterId: String!
  id: ID!
  parentCommentId: uuid
  postId: uuid!
  timeCreated: timestamptz!
}

"""
Boolean expression to filter rows from the table "Comment". All fields are combined with a logical 'AND'.
"""
input Comment_bool_exp {
  _and: [Comment_bool_exp!]
  _not: Comment_bool_exp
  _or: [Comment_bool_exp!]
  comment: String_comparison_exp
  commenterId: String_comparison_exp
  id: uuid_comparison_exp
  parentCommentId: uuid_comparison_exp
  postId: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "Comment"
"""
enum Comment_constraint {
  """unique or primary key constraint"""
  Comment_pkey
}

"""
input type for inserting data into table "Comment"
"""
input Comment_insert_input {
  comment: String
  commenterId: String
  id: uuid
  parentCommentId: uuid
  postId: uuid
  timeCreated: timestamptz
}

"""
response of any mutation on the table "Comment"
"""
type Comment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Comment!]!
}

"""
on_conflict condition type for table "Comment"
"""
input Comment_on_conflict {
  constraint: Comment_constraint!
  update_columns: [Comment_update_column!]! = []
  where: Comment_bool_exp
}

"""Ordering options when selecting data from "Comment"."""
input Comment_order_by {
  comment: order_by
  commenterId: order_by
  id: order_by
  parentCommentId: order_by
  postId: order_by
  timeCreated: order_by
}

"""primary key columns input for table: Comment"""
input Comment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Comment"
"""
enum Comment_select_column {
  """column name"""
  comment

  """column name"""
  commenterId

  """column name"""
  id

  """column name"""
  parentCommentId

  """column name"""
  postId

  """column name"""
  timeCreated
}

"""
input type for updating data in table "Comment"
"""
input Comment_set_input {
  comment: String
  commenterId: String
  id: uuid
  parentCommentId: uuid
  postId: uuid
  timeCreated: timestamptz
}

"""
update columns of table "Comment"
"""
enum Comment_update_column {
  """column name"""
  comment

  """column name"""
  commenterId

  """column name"""
  id

  """column name"""
  parentCommentId

  """column name"""
  postId

  """column name"""
  timeCreated
}

"""
A Relay connection object on "Comment"
"""
type CommentConnection {
  edges: [CommentEdge!]!
  pageInfo: PageInfo!
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

"""
columns and relationships of "CreatorInvite"
"""
type CreatorInvite implements Node {
  expirationTime: timestamptz
  id: ID!
  inviteLinkExpirationTime: timestamptz
  inviteLinkTimeCreated: timestamptz
  inviteLinkToken: String
  issueReason: CreatorInviteIssueReason_enum!
  ownerId: String!
  receiverEmail: String
  receiverId: String
  timeAccepted: timestamptz
  timeCreated: timestamptz!
}

"""
Boolean expression to filter rows from the table "CreatorInvite". All fields are combined with a logical 'AND'.
"""
input CreatorInvite_bool_exp {
  _and: [CreatorInvite_bool_exp!]
  _not: CreatorInvite_bool_exp
  _or: [CreatorInvite_bool_exp!]
  expirationTime: timestamptz_comparison_exp
  id: uuid_comparison_exp
  inviteLinkExpirationTime: timestamptz_comparison_exp
  inviteLinkTimeCreated: timestamptz_comparison_exp
  inviteLinkToken: String_comparison_exp
  issueReason: CreatorInviteIssueReason_enum_comparison_exp
  ownerId: String_comparison_exp
  receiverEmail: String_comparison_exp
  receiverId: String_comparison_exp
  timeAccepted: timestamptz_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "CreatorInvite"
"""
enum CreatorInvite_constraint {
  """unique or primary key constraint"""
  CreatorInvite_id_key

  """unique or primary key constraint"""
  CreatorInvite_inviteLinkToken_key

  """unique or primary key constraint"""
  CreatorInvite_pkey
}

"""
input type for inserting data into table "CreatorInvite"
"""
input CreatorInvite_insert_input {
  expirationTime: timestamptz
  id: uuid
  inviteLinkExpirationTime: timestamptz
  inviteLinkTimeCreated: timestamptz
  inviteLinkToken: String
  issueReason: CreatorInviteIssueReason_enum
  ownerId: String
  receiverEmail: String
  receiverId: String
  timeAccepted: timestamptz
  timeCreated: timestamptz
}

"""
response of any mutation on the table "CreatorInvite"
"""
type CreatorInvite_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CreatorInvite!]!
}

"""
on_conflict condition type for table "CreatorInvite"
"""
input CreatorInvite_on_conflict {
  constraint: CreatorInvite_constraint!
  update_columns: [CreatorInvite_update_column!]! = []
  where: CreatorInvite_bool_exp
}

"""Ordering options when selecting data from "CreatorInvite"."""
input CreatorInvite_order_by {
  expirationTime: order_by
  id: order_by
  inviteLinkExpirationTime: order_by
  inviteLinkTimeCreated: order_by
  inviteLinkToken: order_by
  issueReason: order_by
  ownerId: order_by
  receiverEmail: order_by
  receiverId: order_by
  timeAccepted: order_by
  timeCreated: order_by
}

"""primary key columns input for table: CreatorInvite"""
input CreatorInvite_pk_columns_input {
  id: uuid!
}

"""
select columns of table "CreatorInvite"
"""
enum CreatorInvite_select_column {
  """column name"""
  expirationTime

  """column name"""
  id

  """column name"""
  inviteLinkExpirationTime

  """column name"""
  inviteLinkTimeCreated

  """column name"""
  inviteLinkToken

  """column name"""
  issueReason

  """column name"""
  ownerId

  """column name"""
  receiverEmail

  """column name"""
  receiverId

  """column name"""
  timeAccepted

  """column name"""
  timeCreated
}

"""
input type for updating data in table "CreatorInvite"
"""
input CreatorInvite_set_input {
  expirationTime: timestamptz
  id: uuid
  inviteLinkExpirationTime: timestamptz
  inviteLinkTimeCreated: timestamptz
  inviteLinkToken: String
  issueReason: CreatorInviteIssueReason_enum
  ownerId: String
  receiverEmail: String
  receiverId: String
  timeAccepted: timestamptz
  timeCreated: timestamptz
}

"""
update columns of table "CreatorInvite"
"""
enum CreatorInvite_update_column {
  """column name"""
  expirationTime

  """column name"""
  id

  """column name"""
  inviteLinkExpirationTime

  """column name"""
  inviteLinkTimeCreated

  """column name"""
  inviteLinkToken

  """column name"""
  issueReason

  """column name"""
  ownerId

  """column name"""
  receiverEmail

  """column name"""
  receiverId

  """column name"""
  timeAccepted

  """column name"""
  timeCreated
}

"""
A Relay connection object on "CreatorInvite"
"""
type CreatorInviteConnection {
  edges: [CreatorInviteEdge!]!
  pageInfo: PageInfo!
}

type CreatorInviteEdge {
  cursor: String!
  node: CreatorInvite!
}

"""
columns and relationships of "CreatorInviteIssueReason"
"""
type CreatorInviteIssueReason implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "CreatorInviteIssueReason". All fields are combined with a logical 'AND'.
"""
input CreatorInviteIssueReason_bool_exp {
  _and: [CreatorInviteIssueReason_bool_exp!]
  _not: CreatorInviteIssueReason_bool_exp
  _or: [CreatorInviteIssueReason_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "CreatorInviteIssueReason"
"""
enum CreatorInviteIssueReason_constraint {
  """unique or primary key constraint"""
  CreatorInviteIssueReason_pkey
}

enum CreatorInviteIssueReason_enum {
  AdvocateProgram
}

"""
Boolean expression to compare columns of type "CreatorInviteIssueReason_enum". All fields are combined with logical 'AND'.
"""
input CreatorInviteIssueReason_enum_comparison_exp {
  _eq: CreatorInviteIssueReason_enum
  _in: [CreatorInviteIssueReason_enum!]
  _is_null: Boolean
  _neq: CreatorInviteIssueReason_enum
  _nin: [CreatorInviteIssueReason_enum!]
}

"""
input type for inserting data into table "CreatorInviteIssueReason"
"""
input CreatorInviteIssueReason_insert_input {
  value: String
}

"""
response of any mutation on the table "CreatorInviteIssueReason"
"""
type CreatorInviteIssueReason_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CreatorInviteIssueReason!]!
}

"""
on_conflict condition type for table "CreatorInviteIssueReason"
"""
input CreatorInviteIssueReason_on_conflict {
  constraint: CreatorInviteIssueReason_constraint!
  update_columns: [CreatorInviteIssueReason_update_column!]! = []
  where: CreatorInviteIssueReason_bool_exp
}

"""Ordering options when selecting data from "CreatorInviteIssueReason"."""
input CreatorInviteIssueReason_order_by {
  value: order_by
}

"""primary key columns input for table: CreatorInviteIssueReason"""
input CreatorInviteIssueReason_pk_columns_input {
  value: String!
}

"""
select columns of table "CreatorInviteIssueReason"
"""
enum CreatorInviteIssueReason_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "CreatorInviteIssueReason"
"""
input CreatorInviteIssueReason_set_input {
  value: String
}

"""
update columns of table "CreatorInviteIssueReason"
"""
enum CreatorInviteIssueReason_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "CreatorInviteIssueReason"
"""
type CreatorInviteIssueReasonConnection {
  edges: [CreatorInviteIssueReasonEdge!]!
  pageInfo: PageInfo!
}

type CreatorInviteIssueReasonEdge {
  cursor: String!
  node: CreatorInviteIssueReason!
}

"""Holds information about each creator's creator story"""
type CreatorStory implements Node {
  colorScheme: Int!
  goals: String
  headline: String
  id: ID!
  inspiration: String
  process: String
  userId: String!
}

"""
Boolean expression to filter rows from the table "CreatorStory". All fields are combined with a logical 'AND'.
"""
input CreatorStory_bool_exp {
  _and: [CreatorStory_bool_exp!]
  _not: CreatorStory_bool_exp
  _or: [CreatorStory_bool_exp!]
  colorScheme: Int_comparison_exp
  goals: String_comparison_exp
  headline: String_comparison_exp
  id: uuid_comparison_exp
  inspiration: String_comparison_exp
  process: String_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "CreatorStory"
"""
enum CreatorStory_constraint {
  """unique or primary key constraint"""
  CreatorStory_pkey

  """unique or primary key constraint"""
  CreatorStory_userId_key
}

"""
input type for incrementing numeric columns in table "CreatorStory"
"""
input CreatorStory_inc_input {
  colorScheme: Int
}

"""
input type for inserting data into table "CreatorStory"
"""
input CreatorStory_insert_input {
  colorScheme: Int
  goals: String
  headline: String
  id: uuid
  inspiration: String
  process: String
  userId: String
}

"""
response of any mutation on the table "CreatorStory"
"""
type CreatorStory_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CreatorStory!]!
}

"""
input type for inserting object relation for remote table "CreatorStory"
"""
input CreatorStory_obj_rel_insert_input {
  data: CreatorStory_insert_input!

  """upsert condition"""
  on_conflict: CreatorStory_on_conflict
}

"""
on_conflict condition type for table "CreatorStory"
"""
input CreatorStory_on_conflict {
  constraint: CreatorStory_constraint!
  update_columns: [CreatorStory_update_column!]! = []
  where: CreatorStory_bool_exp
}

"""Ordering options when selecting data from "CreatorStory"."""
input CreatorStory_order_by {
  colorScheme: order_by
  goals: order_by
  headline: order_by
  id: order_by
  inspiration: order_by
  process: order_by
  userId: order_by
}

"""primary key columns input for table: CreatorStory"""
input CreatorStory_pk_columns_input {
  id: uuid!
}

"""
select columns of table "CreatorStory"
"""
enum CreatorStory_select_column {
  """column name"""
  colorScheme

  """column name"""
  goals

  """column name"""
  headline

  """column name"""
  id

  """column name"""
  inspiration

  """column name"""
  process

  """column name"""
  userId
}

"""
input type for updating data in table "CreatorStory"
"""
input CreatorStory_set_input {
  colorScheme: Int
  goals: String
  headline: String
  id: uuid
  inspiration: String
  process: String
  userId: String
}

"""
update columns of table "CreatorStory"
"""
enum CreatorStory_update_column {
  """column name"""
  colorScheme

  """column name"""
  goals

  """column name"""
  headline

  """column name"""
  id

  """column name"""
  inspiration

  """column name"""
  process

  """column name"""
  userId
}

"""
A Relay connection object on "CreatorStory"
"""
type CreatorStoryConnection {
  edges: [CreatorStoryEdge!]!
  pageInfo: PageInfo!
}

type CreatorStoryEdge {
  cursor: String!
  node: CreatorStory!
}

"""
columns and relationships of "CreatorSurvey"
"""
type CreatorSurvey implements Node {
  competition: String
  id: ID!
  impact: String!
  improvements: String!
  isFofuBetterThanWeb2: Boolean!
  isFofuMainRevenue: Boolean!
  positiveDifference: String!
  problems: String!
  recommend: Int!
  seanEllis: String
  userId: String!
  usesWeb2Platforms: Boolean!
}

"""
Boolean expression to filter rows from the table "CreatorSurvey". All fields are combined with a logical 'AND'.
"""
input CreatorSurvey_bool_exp {
  _and: [CreatorSurvey_bool_exp!]
  _not: CreatorSurvey_bool_exp
  _or: [CreatorSurvey_bool_exp!]
  competition: String_comparison_exp
  id: uuid_comparison_exp
  impact: String_comparison_exp
  improvements: String_comparison_exp
  isFofuBetterThanWeb2: Boolean_comparison_exp
  isFofuMainRevenue: Boolean_comparison_exp
  positiveDifference: String_comparison_exp
  problems: String_comparison_exp
  recommend: Int_comparison_exp
  seanEllis: String_comparison_exp
  userId: String_comparison_exp
  usesWeb2Platforms: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "CreatorSurvey"
"""
enum CreatorSurvey_constraint {
  """unique or primary key constraint"""
  CreatorSurvey_pkey

  """unique or primary key constraint"""
  CreatorSurvey_userId_key
}

"""
input type for incrementing numeric columns in table "CreatorSurvey"
"""
input CreatorSurvey_inc_input {
  recommend: Int
}

"""
input type for inserting data into table "CreatorSurvey"
"""
input CreatorSurvey_insert_input {
  competition: String
  id: uuid
  impact: String
  improvements: String
  isFofuBetterThanWeb2: Boolean
  isFofuMainRevenue: Boolean
  positiveDifference: String
  problems: String
  recommend: Int
  seanEllis: String
  userId: String
  usesWeb2Platforms: Boolean
}

"""
response of any mutation on the table "CreatorSurvey"
"""
type CreatorSurvey_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CreatorSurvey!]!
}

"""
on_conflict condition type for table "CreatorSurvey"
"""
input CreatorSurvey_on_conflict {
  constraint: CreatorSurvey_constraint!
  update_columns: [CreatorSurvey_update_column!]! = []
  where: CreatorSurvey_bool_exp
}

"""Ordering options when selecting data from "CreatorSurvey"."""
input CreatorSurvey_order_by {
  competition: order_by
  id: order_by
  impact: order_by
  improvements: order_by
  isFofuBetterThanWeb2: order_by
  isFofuMainRevenue: order_by
  positiveDifference: order_by
  problems: order_by
  recommend: order_by
  seanEllis: order_by
  userId: order_by
  usesWeb2Platforms: order_by
}

"""primary key columns input for table: CreatorSurvey"""
input CreatorSurvey_pk_columns_input {
  id: uuid!
}

"""
select columns of table "CreatorSurvey"
"""
enum CreatorSurvey_select_column {
  """column name"""
  competition

  """column name"""
  id

  """column name"""
  impact

  """column name"""
  improvements

  """column name"""
  isFofuBetterThanWeb2

  """column name"""
  isFofuMainRevenue

  """column name"""
  positiveDifference

  """column name"""
  problems

  """column name"""
  recommend

  """column name"""
  seanEllis

  """column name"""
  userId

  """column name"""
  usesWeb2Platforms
}

"""
input type for updating data in table "CreatorSurvey"
"""
input CreatorSurvey_set_input {
  competition: String
  id: uuid
  impact: String
  improvements: String
  isFofuBetterThanWeb2: Boolean
  isFofuMainRevenue: Boolean
  positiveDifference: String
  problems: String
  recommend: Int
  seanEllis: String
  userId: String
  usesWeb2Platforms: Boolean
}

"""
update columns of table "CreatorSurvey"
"""
enum CreatorSurvey_update_column {
  """column name"""
  competition

  """column name"""
  id

  """column name"""
  impact

  """column name"""
  improvements

  """column name"""
  isFofuBetterThanWeb2

  """column name"""
  isFofuMainRevenue

  """column name"""
  positiveDifference

  """column name"""
  problems

  """column name"""
  recommend

  """column name"""
  seanEllis

  """column name"""
  userId

  """column name"""
  usesWeb2Platforms
}

"""
A Relay connection object on "CreatorSurvey"
"""
type CreatorSurveyConnection {
  edges: [CreatorSurveyEdge!]!
  pageInfo: PageInfo!
}

type CreatorSurveyEdge {
  cursor: String!
  node: CreatorSurvey!
}

"""
columns and relationships of "Currency"
"""
type Currency implements Node {
  decimals: Int!
  iconSrc: String
  id: ID!
  mint: String!
  name: CurrencyName_enum!

  """Short symbol used for currency, e.g., $, """
  shortSymbol: String
  solRate: numeric

  """Symbol used for currency, e.g., SOL, USDC, USD"""
  symbol: String!
  usdRate: numeric
}

"""
Boolean expression to filter rows from the table "Currency". All fields are combined with a logical 'AND'.
"""
input Currency_bool_exp {
  _and: [Currency_bool_exp!]
  _not: Currency_bool_exp
  _or: [Currency_bool_exp!]
  decimals: Int_comparison_exp
  iconSrc: String_comparison_exp
  id: uuid_comparison_exp
  mint: String_comparison_exp
  name: CurrencyName_enum_comparison_exp
  shortSymbol: String_comparison_exp
  solRate: numeric_comparison_exp
  symbol: String_comparison_exp
  usdRate: numeric_comparison_exp
}

"""
unique or primary key constraints on table "Currency"
"""
enum Currency_constraint {
  """unique or primary key constraint"""
  Currency_mint_key

  """unique or primary key constraint"""
  Currency_name_key

  """unique or primary key constraint"""
  Currency_pkey

  """unique or primary key constraint"""
  Currency_symbol_key
}

"""
input type for incrementing numeric columns in table "Currency"
"""
input Currency_inc_input {
  decimals: Int
  solRate: numeric
  usdRate: numeric
}

"""
input type for inserting data into table "Currency"
"""
input Currency_insert_input {
  decimals: Int
  iconSrc: String
  id: uuid
  mint: String
  name: CurrencyName_enum

  """Short symbol used for currency, e.g., $, """
  shortSymbol: String
  solRate: numeric

  """Symbol used for currency, e.g., SOL, USDC, USD"""
  symbol: String
  usdRate: numeric
}

"""
response of any mutation on the table "Currency"
"""
type Currency_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Currency!]!
}

"""
on_conflict condition type for table "Currency"
"""
input Currency_on_conflict {
  constraint: Currency_constraint!
  update_columns: [Currency_update_column!]! = []
  where: Currency_bool_exp
}

"""Ordering options when selecting data from "Currency"."""
input Currency_order_by {
  decimals: order_by
  iconSrc: order_by
  id: order_by
  mint: order_by
  name: order_by
  shortSymbol: order_by
  solRate: order_by
  symbol: order_by
  usdRate: order_by
}

"""primary key columns input for table: Currency"""
input Currency_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Currency"
"""
enum Currency_select_column {
  """column name"""
  decimals

  """column name"""
  iconSrc

  """column name"""
  id

  """column name"""
  mint

  """column name"""
  name

  """column name"""
  shortSymbol

  """column name"""
  solRate

  """column name"""
  symbol

  """column name"""
  usdRate
}

"""
input type for updating data in table "Currency"
"""
input Currency_set_input {
  decimals: Int
  iconSrc: String
  id: uuid
  mint: String
  name: CurrencyName_enum

  """Short symbol used for currency, e.g., $, """
  shortSymbol: String
  solRate: numeric

  """Symbol used for currency, e.g., SOL, USDC, USD"""
  symbol: String
  usdRate: numeric
}

"""
update columns of table "Currency"
"""
enum Currency_update_column {
  """column name"""
  decimals

  """column name"""
  iconSrc

  """column name"""
  id

  """column name"""
  mint

  """column name"""
  name

  """column name"""
  shortSymbol

  """column name"""
  solRate

  """column name"""
  symbol

  """column name"""
  usdRate
}

"""
A Relay connection object on "Currency"
"""
type CurrencyConnection {
  edges: [CurrencyEdge!]!
  pageInfo: PageInfo!
}

type CurrencyEdge {
  cursor: String!
  node: Currency!
}

"""
columns and relationships of "CurrencyName"
"""
type CurrencyName implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "CurrencyName". All fields are combined with a logical 'AND'.
"""
input CurrencyName_bool_exp {
  _and: [CurrencyName_bool_exp!]
  _not: CurrencyName_bool_exp
  _or: [CurrencyName_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "CurrencyName"
"""
enum CurrencyName_constraint {
  """unique or primary key constraint"""
  CurrencyName_pkey
}

enum CurrencyName_enum {
  Ash
  Bonk
  FamousFoxFederation
  Particles
  SkeletonCrew
  Solana
  UsdCoin
}

"""
Boolean expression to compare columns of type "CurrencyName_enum". All fields are combined with logical 'AND'.
"""
input CurrencyName_enum_comparison_exp {
  _eq: CurrencyName_enum
  _in: [CurrencyName_enum!]
  _is_null: Boolean
  _neq: CurrencyName_enum
  _nin: [CurrencyName_enum!]
}

"""
input type for inserting data into table "CurrencyName"
"""
input CurrencyName_insert_input {
  value: String
}

"""
response of any mutation on the table "CurrencyName"
"""
type CurrencyName_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [CurrencyName!]!
}

"""
on_conflict condition type for table "CurrencyName"
"""
input CurrencyName_on_conflict {
  constraint: CurrencyName_constraint!
  update_columns: [CurrencyName_update_column!]! = []
  where: CurrencyName_bool_exp
}

"""Ordering options when selecting data from "CurrencyName"."""
input CurrencyName_order_by {
  value: order_by
}

"""primary key columns input for table: CurrencyName"""
input CurrencyName_pk_columns_input {
  value: String!
}

"""
select columns of table "CurrencyName"
"""
enum CurrencyName_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "CurrencyName"
"""
input CurrencyName_set_input {
  value: String
}

"""
update columns of table "CurrencyName"
"""
enum CurrencyName_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "CurrencyName"
"""
type CurrencyNameConnection {
  edges: [CurrencyNameEdge!]!
  pageInfo: PageInfo!
}

type CurrencyNameEdge {
  cursor: String!
  node: CurrencyName!
}

"""
Keeps track of txids deleted from NftTransaction and NftTransactionRaw, so that we can ignore them in syncAuctionTxs
"""
type DeletedNftTransaction implements Node {
  id: ID!
  txid: String!
}

"""
Boolean expression to filter rows from the table "DeletedNftTransaction". All fields are combined with a logical 'AND'.
"""
input DeletedNftTransaction_bool_exp {
  _and: [DeletedNftTransaction_bool_exp!]
  _not: DeletedNftTransaction_bool_exp
  _or: [DeletedNftTransaction_bool_exp!]
  txid: String_comparison_exp
}

"""
unique or primary key constraints on table "DeletedNftTransaction"
"""
enum DeletedNftTransaction_constraint {
  """unique or primary key constraint"""
  DeletedNftTransaction_pkey
}

"""
input type for inserting data into table "DeletedNftTransaction"
"""
input DeletedNftTransaction_insert_input {
  txid: String
}

"""
response of any mutation on the table "DeletedNftTransaction"
"""
type DeletedNftTransaction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [DeletedNftTransaction!]!
}

"""
on_conflict condition type for table "DeletedNftTransaction"
"""
input DeletedNftTransaction_on_conflict {
  constraint: DeletedNftTransaction_constraint!
  update_columns: [DeletedNftTransaction_update_column!]! = []
  where: DeletedNftTransaction_bool_exp
}

"""Ordering options when selecting data from "DeletedNftTransaction"."""
input DeletedNftTransaction_order_by {
  txid: order_by
}

"""primary key columns input for table: DeletedNftTransaction"""
input DeletedNftTransaction_pk_columns_input {
  txid: String!
}

"""
select columns of table "DeletedNftTransaction"
"""
enum DeletedNftTransaction_select_column {
  """column name"""
  txid
}

"""
input type for updating data in table "DeletedNftTransaction"
"""
input DeletedNftTransaction_set_input {
  txid: String
}

"""
update columns of table "DeletedNftTransaction"
"""
enum DeletedNftTransaction_update_column {
  """column name"""
  txid
}

"""
A Relay connection object on "DeletedNftTransaction"
"""
type DeletedNftTransactionConnection {
  edges: [DeletedNftTransactionEdge!]!
  pageInfo: PageInfo!
}

type DeletedNftTransactionEdge {
  cursor: String!
  node: DeletedNftTransaction!
}

"""Table used for development/testing"""
type Dev implements Node {
  date: timestamptz
  id: ID!
  name: String!
}

"""
Boolean expression to filter rows from the table "Dev". All fields are combined with a logical 'AND'.
"""
input Dev_bool_exp {
  _and: [Dev_bool_exp!]
  _not: Dev_bool_exp
  _or: [Dev_bool_exp!]
  date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "Dev"
"""
enum Dev_constraint {
  """unique or primary key constraint"""
  Dev_pkey
}

"""
input type for inserting data into table "Dev"
"""
input Dev_insert_input {
  date: timestamptz
  id: uuid
  name: String
}

"""
response of any mutation on the table "Dev"
"""
type Dev_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Dev!]!
}

"""
on_conflict condition type for table "Dev"
"""
input Dev_on_conflict {
  constraint: Dev_constraint!
  update_columns: [Dev_update_column!]! = []
  where: Dev_bool_exp
}

"""Ordering options when selecting data from "Dev"."""
input Dev_order_by {
  date: order_by
  id: order_by
  name: order_by
}

"""primary key columns input for table: Dev"""
input Dev_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Dev"
"""
enum Dev_select_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "Dev"
"""
input Dev_set_input {
  date: timestamptz
  id: uuid
  name: String
}

"""
update columns of table "Dev"
"""
enum Dev_update_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  name
}

"""
A Relay connection object on "Dev"
"""
type DevConnection {
  edges: [DevEdge!]!
  pageInfo: PageInfo!
}

type DevEdge {
  cursor: String!
  node: Dev!
}

"""
Records Discord account information for users to facilitate automatic Discord role provisioning
"""
type DiscordAuth implements Node {
  """An array relationship"""
  DiscordAuthToDiscordRoles(
    """distinct select on columns"""
    distinct_on: [DiscordAuthToDiscordRole_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [DiscordAuthToDiscordRole_order_by!]

    """filter the rows returned"""
    where: DiscordAuthToDiscordRole_bool_exp
  ): [DiscordAuthToDiscordRole!]!

  """An aggregate relationship"""
  DiscordAuthToDiscordRoles_aggregate(
    """distinct select on columns"""
    distinct_on: [DiscordAuthToDiscordRole_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [DiscordAuthToDiscordRole_order_by!]

    """filter the rows returned"""
    where: DiscordAuthToDiscordRole_bool_exp
  ): DiscordAuthToDiscordRole_aggregate!

  """An array relationship connection"""
  DiscordAuthToDiscordRoles_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [DiscordAuthToDiscordRole_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [DiscordAuthToDiscordRole_order_by!]

    """filter the rows returned"""
    where: DiscordAuthToDiscordRole_bool_exp
  ): DiscordAuthToDiscordRoleConnection!

  """
  This is an expiring token which represents a request to connect a Discord
  account, of the format <unix-expiration>-<nanoid()> which is used to
  associated an authorization request with the initiating user
  """
  authorizationNonce: String
  discordHandle: String
  discordUserId: String
  hasConnectedDiscordAccount: Boolean!
  hasJoinedDiscordServer: Boolean
  id: ID!
  timeCreated: timestamptz!
  userId: String!
}

"""
Boolean expression to filter rows from the table "DiscordAuth". All fields are combined with a logical 'AND'.
"""
input DiscordAuth_bool_exp {
  DiscordAuthToDiscordRoles: DiscordAuthToDiscordRole_bool_exp
  _and: [DiscordAuth_bool_exp!]
  _not: DiscordAuth_bool_exp
  _or: [DiscordAuth_bool_exp!]
  authorizationNonce: String_comparison_exp
  discordHandle: String_comparison_exp
  discordUserId: String_comparison_exp
  hasConnectedDiscordAccount: Boolean_comparison_exp
  hasJoinedDiscordServer: Boolean_comparison_exp
  id: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "DiscordAuth"
"""
enum DiscordAuth_constraint {
  """unique or primary key constraint"""
  DiscordAuth_authorizationNonce_key

  """unique or primary key constraint"""
  DiscordAuth_discordUserId_key

  """unique or primary key constraint"""
  DiscordAuth_pkey

  """unique or primary key constraint"""
  DiscordAuth_userId_key
}

"""
input type for inserting data into table "DiscordAuth"
"""
input DiscordAuth_insert_input {
  DiscordAuthToDiscordRoles: DiscordAuthToDiscordRole_arr_rel_insert_input

  """
  This is an expiring token which represents a request to connect a Discord
  account, of the format <unix-expiration>-<nanoid()> which is used to
  associated an authorization request with the initiating user
  """
  authorizationNonce: String
  discordHandle: String
  discordUserId: String
  hasConnectedDiscordAccount: Boolean
  hasJoinedDiscordServer: Boolean
  id: uuid
  timeCreated: timestamptz
  userId: String
}

"""
response of any mutation on the table "DiscordAuth"
"""
type DiscordAuth_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [DiscordAuth!]!
}

"""
input type for inserting object relation for remote table "DiscordAuth"
"""
input DiscordAuth_obj_rel_insert_input {
  data: DiscordAuth_insert_input!

  """upsert condition"""
  on_conflict: DiscordAuth_on_conflict
}

"""
on_conflict condition type for table "DiscordAuth"
"""
input DiscordAuth_on_conflict {
  constraint: DiscordAuth_constraint!
  update_columns: [DiscordAuth_update_column!]! = []
  where: DiscordAuth_bool_exp
}

"""Ordering options when selecting data from "DiscordAuth"."""
input DiscordAuth_order_by {
  DiscordAuthToDiscordRoles_aggregate: DiscordAuthToDiscordRole_aggregate_order_by
  authorizationNonce: order_by
  discordHandle: order_by
  discordUserId: order_by
  hasConnectedDiscordAccount: order_by
  hasJoinedDiscordServer: order_by
  id: order_by
  timeCreated: order_by
  userId: order_by
}

"""primary key columns input for table: DiscordAuth"""
input DiscordAuth_pk_columns_input {
  id: uuid!
}

"""
select columns of table "DiscordAuth"
"""
enum DiscordAuth_select_column {
  """column name"""
  authorizationNonce

  """column name"""
  discordHandle

  """column name"""
  discordUserId

  """column name"""
  hasConnectedDiscordAccount

  """column name"""
  hasJoinedDiscordServer

  """column name"""
  id

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
input type for updating data in table "DiscordAuth"
"""
input DiscordAuth_set_input {
  """
  This is an expiring token which represents a request to connect a Discord
  account, of the format <unix-expiration>-<nanoid()> which is used to
  associated an authorization request with the initiating user
  """
  authorizationNonce: String
  discordHandle: String
  discordUserId: String
  hasConnectedDiscordAccount: Boolean
  hasJoinedDiscordServer: Boolean
  id: uuid
  timeCreated: timestamptz
  userId: String
}

"""
update columns of table "DiscordAuth"
"""
enum DiscordAuth_update_column {
  """column name"""
  authorizationNonce

  """column name"""
  discordHandle

  """column name"""
  discordUserId

  """column name"""
  hasConnectedDiscordAccount

  """column name"""
  hasJoinedDiscordServer

  """column name"""
  id

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
A Relay connection object on "DiscordAuth"
"""
type DiscordAuthConnection {
  edges: [DiscordAuthEdge!]!
  pageInfo: PageInfo!
}

type DiscordAuthEdge {
  cursor: String!
  node: DiscordAuth!
}

"""Tracks many to many relationship from DiscordAuth to DiscordRoles"""
type DiscordAuthToDiscordRole implements Node {
  """An object relationship"""
  DiscordAuth: DiscordAuth!

  """An object relationship"""
  DiscordRole: DiscordRole!
  discordAuthId: uuid!
  discordRoleId: String!
  id: ID!
  timeCreated: timestamptz!
}

"""
aggregated selection of "DiscordAuthToDiscordRole"
"""
type DiscordAuthToDiscordRole_aggregate {
  aggregate: DiscordAuthToDiscordRole_aggregate_fields
  nodes: [DiscordAuthToDiscordRole!]!
}

"""
aggregate fields of "DiscordAuthToDiscordRole"
"""
type DiscordAuthToDiscordRole_aggregate_fields {
  count(columns: [DiscordAuthToDiscordRole_select_column!], distinct: Boolean): Int!
  max: DiscordAuthToDiscordRole_max_fields
  min: DiscordAuthToDiscordRole_min_fields
}

"""
order by aggregate values of table "DiscordAuthToDiscordRole"
"""
input DiscordAuthToDiscordRole_aggregate_order_by {
  count: order_by
  max: DiscordAuthToDiscordRole_max_order_by
  min: DiscordAuthToDiscordRole_min_order_by
}

"""
input type for inserting array relation for remote table "DiscordAuthToDiscordRole"
"""
input DiscordAuthToDiscordRole_arr_rel_insert_input {
  data: [DiscordAuthToDiscordRole_insert_input!]!

  """upsert condition"""
  on_conflict: DiscordAuthToDiscordRole_on_conflict
}

"""
Boolean expression to filter rows from the table "DiscordAuthToDiscordRole". All fields are combined with a logical 'AND'.
"""
input DiscordAuthToDiscordRole_bool_exp {
  DiscordAuth: DiscordAuth_bool_exp
  DiscordRole: DiscordRole_bool_exp
  _and: [DiscordAuthToDiscordRole_bool_exp!]
  _not: DiscordAuthToDiscordRole_bool_exp
  _or: [DiscordAuthToDiscordRole_bool_exp!]
  discordAuthId: uuid_comparison_exp
  discordRoleId: String_comparison_exp
  id: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "DiscordAuthToDiscordRole"
"""
enum DiscordAuthToDiscordRole_constraint {
  """unique or primary key constraint"""
  DiscordAuthToDiscordRole_id_key

  """unique or primary key constraint"""
  DiscordAuthToDiscordRole_pkey
}

"""
input type for inserting data into table "DiscordAuthToDiscordRole"
"""
input DiscordAuthToDiscordRole_insert_input {
  DiscordAuth: DiscordAuth_obj_rel_insert_input
  DiscordRole: DiscordRole_obj_rel_insert_input
  discordAuthId: uuid
  discordRoleId: String
  id: uuid
  timeCreated: timestamptz
}

"""aggregate max on columns"""
type DiscordAuthToDiscordRole_max_fields {
  discordAuthId: uuid
  discordRoleId: String
  id: uuid
  timeCreated: timestamptz
}

"""
order by max() on columns of table "DiscordAuthToDiscordRole"
"""
input DiscordAuthToDiscordRole_max_order_by {
  discordAuthId: order_by
  discordRoleId: order_by
  id: order_by
  timeCreated: order_by
}

"""aggregate min on columns"""
type DiscordAuthToDiscordRole_min_fields {
  discordAuthId: uuid
  discordRoleId: String
  id: uuid
  timeCreated: timestamptz
}

"""
order by min() on columns of table "DiscordAuthToDiscordRole"
"""
input DiscordAuthToDiscordRole_min_order_by {
  discordAuthId: order_by
  discordRoleId: order_by
  id: order_by
  timeCreated: order_by
}

"""
response of any mutation on the table "DiscordAuthToDiscordRole"
"""
type DiscordAuthToDiscordRole_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [DiscordAuthToDiscordRole!]!
}

"""
on_conflict condition type for table "DiscordAuthToDiscordRole"
"""
input DiscordAuthToDiscordRole_on_conflict {
  constraint: DiscordAuthToDiscordRole_constraint!
  update_columns: [DiscordAuthToDiscordRole_update_column!]! = []
  where: DiscordAuthToDiscordRole_bool_exp
}

"""Ordering options when selecting data from "DiscordAuthToDiscordRole"."""
input DiscordAuthToDiscordRole_order_by {
  DiscordAuth: DiscordAuth_order_by
  DiscordRole: DiscordRole_order_by
  discordAuthId: order_by
  discordRoleId: order_by
  id: order_by
  timeCreated: order_by
}

"""primary key columns input for table: DiscordAuthToDiscordRole"""
input DiscordAuthToDiscordRole_pk_columns_input {
  discordAuthId: uuid!
  discordRoleId: String!
}

"""
select columns of table "DiscordAuthToDiscordRole"
"""
enum DiscordAuthToDiscordRole_select_column {
  """column name"""
  discordAuthId

  """column name"""
  discordRoleId

  """column name"""
  id

  """column name"""
  timeCreated
}

"""
input type for updating data in table "DiscordAuthToDiscordRole"
"""
input DiscordAuthToDiscordRole_set_input {
  discordAuthId: uuid
  discordRoleId: String
  id: uuid
  timeCreated: timestamptz
}

"""
update columns of table "DiscordAuthToDiscordRole"
"""
enum DiscordAuthToDiscordRole_update_column {
  """column name"""
  discordAuthId

  """column name"""
  discordRoleId

  """column name"""
  id

  """column name"""
  timeCreated
}

"""
A Relay connection object on "DiscordAuthToDiscordRole"
"""
type DiscordAuthToDiscordRoleConnection {
  edges: [DiscordAuthToDiscordRoleEdge!]!
  pageInfo: PageInfo!
}

type DiscordAuthToDiscordRoleEdge {
  cursor: String!
  node: DiscordAuthToDiscordRole!
}

"""These represent roles in the Formfunction Discord server"""
type DiscordRole implements Node {
  id: ID!
  name: String!
}

"""
Boolean expression to filter rows from the table "DiscordRole". All fields are combined with a logical 'AND'.
"""
input DiscordRole_bool_exp {
  _and: [DiscordRole_bool_exp!]
  _not: DiscordRole_bool_exp
  _or: [DiscordRole_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "DiscordRole"
"""
enum DiscordRole_constraint {
  """unique or primary key constraint"""
  DiscordRole_name_key

  """unique or primary key constraint"""
  DiscordRole_pkey
}

"""
input type for inserting data into table "DiscordRole"
"""
input DiscordRole_insert_input {
  id: String
  name: String
}

"""
response of any mutation on the table "DiscordRole"
"""
type DiscordRole_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [DiscordRole!]!
}

"""
input type for inserting object relation for remote table "DiscordRole"
"""
input DiscordRole_obj_rel_insert_input {
  data: DiscordRole_insert_input!

  """upsert condition"""
  on_conflict: DiscordRole_on_conflict
}

"""
on_conflict condition type for table "DiscordRole"
"""
input DiscordRole_on_conflict {
  constraint: DiscordRole_constraint!
  update_columns: [DiscordRole_update_column!]! = []
  where: DiscordRole_bool_exp
}

"""Ordering options when selecting data from "DiscordRole"."""
input DiscordRole_order_by {
  id: order_by
  name: order_by
}

"""primary key columns input for table: DiscordRole"""
input DiscordRole_pk_columns_input {
  id: String!
}

"""
select columns of table "DiscordRole"
"""
enum DiscordRole_select_column {
  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "DiscordRole"
"""
input DiscordRole_set_input {
  id: String
  name: String
}

"""
update columns of table "DiscordRole"
"""
enum DiscordRole_update_column {
  """column name"""
  id

  """column name"""
  name
}

"""
A Relay connection object on "DiscordRole"
"""
type DiscordRoleConnection {
  edges: [DiscordRoleEdge!]!
  pageInfo: PageInfo!
}

type DiscordRoleEdge {
  cursor: String!
  node: DiscordRole!
}

"""
columns and relationships of "EditionsMerkleAllowlistInfo"
"""
type EditionsMerkleAllowlistInfo implements Node {
  amountAllowed: Int!
  id: ID!
  nftId: String!
  proof: String!
  rootIndex: Int!
  timeCreated: timestamptz!
  userId: String!
}

"""
Boolean expression to filter rows from the table "EditionsMerkleAllowlistInfo".
All fields are combined with a logical 'AND'.
"""
input EditionsMerkleAllowlistInfo_bool_exp {
  _and: [EditionsMerkleAllowlistInfo_bool_exp!]
  _not: EditionsMerkleAllowlistInfo_bool_exp
  _or: [EditionsMerkleAllowlistInfo_bool_exp!]
  amountAllowed: Int_comparison_exp
  id: uuid_comparison_exp
  nftId: String_comparison_exp
  proof: String_comparison_exp
  rootIndex: Int_comparison_exp
  timeCreated: timestamptz_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "EditionsMerkleAllowlistInfo"
"""
enum EditionsMerkleAllowlistInfo_constraint {
  """unique or primary key constraint"""
  EditionsMerkleAllowlistInfo_pkey

  """unique or primary key constraint"""
  EditionsMerkleAllowlistInfo_userId_nftId_key
}

"""
input type for incrementing numeric columns in table "EditionsMerkleAllowlistInfo"
"""
input EditionsMerkleAllowlistInfo_inc_input {
  amountAllowed: Int
  rootIndex: Int
}

"""
input type for inserting data into table "EditionsMerkleAllowlistInfo"
"""
input EditionsMerkleAllowlistInfo_insert_input {
  amountAllowed: Int
  id: uuid
  nftId: String
  proof: String
  rootIndex: Int
  timeCreated: timestamptz
  userId: String
}

"""
response of any mutation on the table "EditionsMerkleAllowlistInfo"
"""
type EditionsMerkleAllowlistInfo_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [EditionsMerkleAllowlistInfo!]!
}

"""
on_conflict condition type for table "EditionsMerkleAllowlistInfo"
"""
input EditionsMerkleAllowlistInfo_on_conflict {
  constraint: EditionsMerkleAllowlistInfo_constraint!
  update_columns: [EditionsMerkleAllowlistInfo_update_column!]! = []
  where: EditionsMerkleAllowlistInfo_bool_exp
}

"""
Ordering options when selecting data from "EditionsMerkleAllowlistInfo".
"""
input EditionsMerkleAllowlistInfo_order_by {
  amountAllowed: order_by
  id: order_by
  nftId: order_by
  proof: order_by
  rootIndex: order_by
  timeCreated: order_by
  userId: order_by
}

"""primary key columns input for table: EditionsMerkleAllowlistInfo"""
input EditionsMerkleAllowlistInfo_pk_columns_input {
  id: uuid!
}

"""
select columns of table "EditionsMerkleAllowlistInfo"
"""
enum EditionsMerkleAllowlistInfo_select_column {
  """column name"""
  amountAllowed

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  proof

  """column name"""
  rootIndex

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
input type for updating data in table "EditionsMerkleAllowlistInfo"
"""
input EditionsMerkleAllowlistInfo_set_input {
  amountAllowed: Int
  id: uuid
  nftId: String
  proof: String
  rootIndex: Int
  timeCreated: timestamptz
  userId: String
}

"""
update columns of table "EditionsMerkleAllowlistInfo"
"""
enum EditionsMerkleAllowlistInfo_update_column {
  """column name"""
  amountAllowed

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  proof

  """column name"""
  rootIndex

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
A Relay connection object on "EditionsMerkleAllowlistInfo"
"""
type EditionsMerkleAllowlistInfoConnection {
  edges: [EditionsMerkleAllowlistInfoEdge!]!
  pageInfo: PageInfo!
}

type EditionsMerkleAllowlistInfoEdge {
  cursor: String!
  node: EditionsMerkleAllowlistInfo!
}

"""For storing exchange rates of various currencies"""
type ExchangeRates implements Node {
  id: ID!
  name: String!
  timeCreated: timestamptz!
  timeUpdated: timestamptz!
  toUsdRate: numeric!
}

"""
Boolean expression to filter rows from the table "ExchangeRates". All fields are combined with a logical 'AND'.
"""
input ExchangeRates_bool_exp {
  _and: [ExchangeRates_bool_exp!]
  _not: ExchangeRates_bool_exp
  _or: [ExchangeRates_bool_exp!]
  name: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  timeUpdated: timestamptz_comparison_exp
  toUsdRate: numeric_comparison_exp
}

"""
unique or primary key constraints on table "ExchangeRates"
"""
enum ExchangeRates_constraint {
  """unique or primary key constraint"""
  ExchangeRates_pkey
}

"""
input type for incrementing numeric columns in table "ExchangeRates"
"""
input ExchangeRates_inc_input {
  toUsdRate: numeric
}

"""
input type for inserting data into table "ExchangeRates"
"""
input ExchangeRates_insert_input {
  name: String
  timeCreated: timestamptz
  timeUpdated: timestamptz
  toUsdRate: numeric
}

"""
response of any mutation on the table "ExchangeRates"
"""
type ExchangeRates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ExchangeRates!]!
}

"""
on_conflict condition type for table "ExchangeRates"
"""
input ExchangeRates_on_conflict {
  constraint: ExchangeRates_constraint!
  update_columns: [ExchangeRates_update_column!]! = []
  where: ExchangeRates_bool_exp
}

"""Ordering options when selecting data from "ExchangeRates"."""
input ExchangeRates_order_by {
  name: order_by
  timeCreated: order_by
  timeUpdated: order_by
  toUsdRate: order_by
}

"""primary key columns input for table: ExchangeRates"""
input ExchangeRates_pk_columns_input {
  name: String!
}

"""
select columns of table "ExchangeRates"
"""
enum ExchangeRates_select_column {
  """column name"""
  name

  """column name"""
  timeCreated

  """column name"""
  timeUpdated

  """column name"""
  toUsdRate
}

"""
input type for updating data in table "ExchangeRates"
"""
input ExchangeRates_set_input {
  name: String
  timeCreated: timestamptz
  timeUpdated: timestamptz
  toUsdRate: numeric
}

"""
update columns of table "ExchangeRates"
"""
enum ExchangeRates_update_column {
  """column name"""
  name

  """column name"""
  timeCreated

  """column name"""
  timeUpdated

  """column name"""
  toUsdRate
}

"""
A Relay connection object on "ExchangeRates"
"""
type ExchangeRatesConnection {
  edges: [ExchangeRatesEdge!]!
  pageInfo: PageInfo!
}

type ExchangeRatesEdge {
  cursor: String!
  node: ExchangeRates!
}

"""
Holds access tokens for users that have authenticated their IG accounts
"""
type InstagramAuth implements Node {
  accessToken: String
  id: ID!
  timeCreated: timestamptz!
  userId: String!
}

"""
Boolean expression to filter rows from the table "InstagramAuth". All fields are combined with a logical 'AND'.
"""
input InstagramAuth_bool_exp {
  _and: [InstagramAuth_bool_exp!]
  _not: InstagramAuth_bool_exp
  _or: [InstagramAuth_bool_exp!]
  accessToken: String_comparison_exp
  id: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "InstagramAuth"
"""
enum InstagramAuth_constraint {
  """unique or primary key constraint"""
  InstagramAuth_accessToken_key

  """unique or primary key constraint"""
  InstagramAuth_id_key

  """unique or primary key constraint"""
  InstagramAuth_pkey
}

"""
input type for inserting data into table "InstagramAuth"
"""
input InstagramAuth_insert_input {
  accessToken: String
  id: uuid
  timeCreated: timestamptz
  userId: String
}

"""
response of any mutation on the table "InstagramAuth"
"""
type InstagramAuth_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [InstagramAuth!]!
}

"""
on_conflict condition type for table "InstagramAuth"
"""
input InstagramAuth_on_conflict {
  constraint: InstagramAuth_constraint!
  update_columns: [InstagramAuth_update_column!]! = []
  where: InstagramAuth_bool_exp
}

"""Ordering options when selecting data from "InstagramAuth"."""
input InstagramAuth_order_by {
  accessToken: order_by
  id: order_by
  timeCreated: order_by
  userId: order_by
}

"""primary key columns input for table: InstagramAuth"""
input InstagramAuth_pk_columns_input {
  userId: String!
}

"""
select columns of table "InstagramAuth"
"""
enum InstagramAuth_select_column {
  """column name"""
  accessToken

  """column name"""
  id

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
input type for updating data in table "InstagramAuth"
"""
input InstagramAuth_set_input {
  accessToken: String
  id: uuid
  timeCreated: timestamptz
  userId: String
}

"""
update columns of table "InstagramAuth"
"""
enum InstagramAuth_update_column {
  """column name"""
  accessToken

  """column name"""
  id

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
A Relay connection object on "InstagramAuth"
"""
type InstagramAuthConnection {
  edges: [InstagramAuthEdge!]!
  pageInfo: PageInfo!
}

type InstagramAuthEdge {
  cursor: String!
  node: InstagramAuth!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "ActivityNotification"
  """
  delete_ActivityNotification(
    """filter the rows which have to be deleted"""
    where: ActivityNotification_bool_exp!
  ): ActivityNotification_mutation_response

  """
  delete single row from the table: "ActivityNotification"
  """
  delete_ActivityNotification_by_pk(id: uuid!): ActivityNotification

  """
  delete data from the table: "Airdrop"
  """
  delete_Airdrop(
    """filter the rows which have to be deleted"""
    where: Airdrop_bool_exp!
  ): Airdrop_mutation_response

  """
  delete data from the table: "AirdropType"
  """
  delete_AirdropType(
    """filter the rows which have to be deleted"""
    where: AirdropType_bool_exp!
  ): AirdropType_mutation_response

  """
  delete single row from the table: "AirdropType"
  """
  delete_AirdropType_by_pk(value: String!): AirdropType

  """
  delete single row from the table: "Airdrop"
  """
  delete_Airdrop_by_pk(id: uuid!): Airdrop

  """
  delete data from the table: "ArtistSubmission"
  """
  delete_ArtistSubmission(
    """filter the rows which have to be deleted"""
    where: ArtistSubmission_bool_exp!
  ): ArtistSubmission_mutation_response

  """
  delete data from the table: "ArtistSubmissionStatus"
  """
  delete_ArtistSubmissionStatus(
    """filter the rows which have to be deleted"""
    where: ArtistSubmissionStatus_bool_exp!
  ): ArtistSubmissionStatus_mutation_response

  """
  delete single row from the table: "ArtistSubmissionStatus"
  """
  delete_ArtistSubmissionStatus_by_pk(value: String!): ArtistSubmissionStatus

  """
  delete single row from the table: "ArtistSubmission"
  """
  delete_ArtistSubmission_by_pk(id: uuid!): ArtistSubmission

  """
  delete data from the table: "Asset"
  """
  delete_Asset(
    """filter the rows which have to be deleted"""
    where: Asset_bool_exp!
  ): Asset_mutation_response

  """
  delete single row from the table: "Asset"
  """
  delete_Asset_by_pk(id: uuid!): Asset

  """
  delete data from the table: "Attribute"
  """
  delete_Attribute(
    """filter the rows which have to be deleted"""
    where: Attribute_bool_exp!
  ): Attribute_mutation_response

  """
  delete single row from the table: "Attribute"
  """
  delete_Attribute_by_pk(id: uuid!): Attribute

  """
  delete data from the table: "BonkClaim"
  """
  delete_BonkClaim(
    """filter the rows which have to be deleted"""
    where: BonkClaim_bool_exp!
  ): BonkClaim_mutation_response

  """
  delete single row from the table: "BonkClaim"
  """
  delete_BonkClaim_by_pk(userId: String!): BonkClaim

  """
  delete data from the table: "Campaign"
  """
  delete_Campaign(
    """filter the rows which have to be deleted"""
    where: Campaign_bool_exp!
  ): Campaign_mutation_response

  """
  delete data from the table: "CampaignBenefit"
  """
  delete_CampaignBenefit(
    """filter the rows which have to be deleted"""
    where: CampaignBenefit_bool_exp!
  ): CampaignBenefit_mutation_response

  """
  delete data from the table: "CampaignBenefitStatus"
  """
  delete_CampaignBenefitStatus(
    """filter the rows which have to be deleted"""
    where: CampaignBenefitStatus_bool_exp!
  ): CampaignBenefitStatus_mutation_response

  """
  delete single row from the table: "CampaignBenefitStatus"
  """
  delete_CampaignBenefitStatus_by_pk(value: String!): CampaignBenefitStatus

  """
  delete data from the table: "CampaignBenefitToNft"
  """
  delete_CampaignBenefitToNft(
    """filter the rows which have to be deleted"""
    where: CampaignBenefitToNft_bool_exp!
  ): CampaignBenefitToNft_mutation_response

  """
  delete single row from the table: "CampaignBenefitToNft"
  """
  delete_CampaignBenefitToNft_by_pk(id: uuid!): CampaignBenefitToNft

  """
  delete single row from the table: "CampaignBenefit"
  """
  delete_CampaignBenefit_by_pk(id: uuid!): CampaignBenefit

  """
  delete data from the table: "CampaignCategory"
  """
  delete_CampaignCategory(
    """filter the rows which have to be deleted"""
    where: CampaignCategory_bool_exp!
  ): CampaignCategory_mutation_response

  """
  delete single row from the table: "CampaignCategory"
  """
  delete_CampaignCategory_by_pk(value: String!): CampaignCategory

  """
  delete data from the table: "CampaignColorScheme"
  """
  delete_CampaignColorScheme(
    """filter the rows which have to be deleted"""
    where: CampaignColorScheme_bool_exp!
  ): CampaignColorScheme_mutation_response

  """
  delete single row from the table: "CampaignColorScheme"
  """
  delete_CampaignColorScheme_by_pk(value: String!): CampaignColorScheme

  """
  delete data from the table: "CampaignFundingTier"
  """
  delete_CampaignFundingTier(
    """filter the rows which have to be deleted"""
    where: CampaignFundingTier_bool_exp!
  ): CampaignFundingTier_mutation_response

  """
  delete data from the table: "CampaignFundingTierType"
  """
  delete_CampaignFundingTierType(
    """filter the rows which have to be deleted"""
    where: CampaignFundingTierType_bool_exp!
  ): CampaignFundingTierType_mutation_response

  """
  delete single row from the table: "CampaignFundingTierType"
  """
  delete_CampaignFundingTierType_by_pk(value: String!): CampaignFundingTierType

  """
  delete single row from the table: "CampaignFundingTier"
  """
  delete_CampaignFundingTier_by_pk(id: uuid!): CampaignFundingTier

  """
  delete data from the table: "CampaignGoalType"
  """
  delete_CampaignGoalType(
    """filter the rows which have to be deleted"""
    where: CampaignGoalType_bool_exp!
  ): CampaignGoalType_mutation_response

  """
  delete single row from the table: "CampaignGoalType"
  """
  delete_CampaignGoalType_by_pk(value: String!): CampaignGoalType

  """
  delete data from the table: "CampaignStatus"
  """
  delete_CampaignStatus(
    """filter the rows which have to be deleted"""
    where: CampaignStatus_bool_exp!
  ): CampaignStatus_mutation_response

  """
  delete single row from the table: "CampaignStatus"
  """
  delete_CampaignStatus_by_pk(value: String!): CampaignStatus

  """
  delete data from the table: "CampaignTeamMemberRole"
  """
  delete_CampaignTeamMemberRole(
    """filter the rows which have to be deleted"""
    where: CampaignTeamMemberRole_bool_exp!
  ): CampaignTeamMemberRole_mutation_response

  """
  delete single row from the table: "CampaignTeamMemberRole"
  """
  delete_CampaignTeamMemberRole_by_pk(value: String!): CampaignTeamMemberRole

  """
  delete data from the table: "CampaignToCollaborator"
  """
  delete_CampaignToCollaborator(
    """filter the rows which have to be deleted"""
    where: CampaignToCollaborator_bool_exp!
  ): CampaignToCollaborator_mutation_response

  """
  delete single row from the table: "CampaignToCollaborator"
  """
  delete_CampaignToCollaborator_by_pk(id: uuid!): CampaignToCollaborator

  """
  delete data from the table: "CampaignToHolder"
  """
  delete_CampaignToHolder(
    """filter the rows which have to be deleted"""
    where: CampaignToHolder_bool_exp!
  ): CampaignToHolder_mutation_response

  """
  delete single row from the table: "CampaignToHolder"
  """
  delete_CampaignToHolder_by_pk(campaignId: uuid!, holderUserId: String!): CampaignToHolder

  """
  delete data from the table: "CampaignToTeamMember"
  """
  delete_CampaignToTeamMember(
    """filter the rows which have to be deleted"""
    where: CampaignToTeamMember_bool_exp!
  ): CampaignToTeamMember_mutation_response

  """
  delete single row from the table: "CampaignToTeamMember"
  """
  delete_CampaignToTeamMember_by_pk(id: uuid!): CampaignToTeamMember

  """
  delete single row from the table: "Campaign"
  """
  delete_Campaign_by_pk(id: uuid!): Campaign

  """
  delete data from the table: "CandyMachine"
  """
  delete_CandyMachine(
    """filter the rows which have to be deleted"""
    where: CandyMachine_bool_exp!
  ): CandyMachine_mutation_response

  """
  delete data from the table: "CandyMachineMerkleAllowlistInfo"
  """
  delete_CandyMachineMerkleAllowlistInfo(
    """filter the rows which have to be deleted"""
    where: CandyMachineMerkleAllowlistInfo_bool_exp!
  ): CandyMachineMerkleAllowlistInfo_mutation_response

  """
  delete single row from the table: "CandyMachineMerkleAllowlistInfo"
  """
  delete_CandyMachineMerkleAllowlistInfo_by_pk(candyMachineId: uuid!, userId: String!): CandyMachineMerkleAllowlistInfo

  """
  delete single row from the table: "CandyMachine"
  """
  delete_CandyMachine_by_pk(id: uuid!): CandyMachine

  """
  delete data from the table: "Claim"
  """
  delete_Claim(
    """filter the rows which have to be deleted"""
    where: Claim_bool_exp!
  ): Claim_mutation_response

  """
  delete single row from the table: "Claim"
  """
  delete_Claim_by_pk(auctionNftId: String!, userId: String!): Claim

  """
  delete data from the table: "CollectorSurvey"
  """
  delete_CollectorSurvey(
    """filter the rows which have to be deleted"""
    where: CollectorSurvey_bool_exp!
  ): CollectorSurvey_mutation_response

  """
  delete single row from the table: "CollectorSurvey"
  """
  delete_CollectorSurvey_by_pk(id: uuid!): CollectorSurvey

  """
  delete data from the table: "Comment"
  """
  delete_Comment(
    """filter the rows which have to be deleted"""
    where: Comment_bool_exp!
  ): Comment_mutation_response

  """
  delete single row from the table: "Comment"
  """
  delete_Comment_by_pk(id: uuid!): Comment

  """
  delete data from the table: "CreatorInvite"
  """
  delete_CreatorInvite(
    """filter the rows which have to be deleted"""
    where: CreatorInvite_bool_exp!
  ): CreatorInvite_mutation_response

  """
  delete data from the table: "CreatorInviteIssueReason"
  """
  delete_CreatorInviteIssueReason(
    """filter the rows which have to be deleted"""
    where: CreatorInviteIssueReason_bool_exp!
  ): CreatorInviteIssueReason_mutation_response

  """
  delete single row from the table: "CreatorInviteIssueReason"
  """
  delete_CreatorInviteIssueReason_by_pk(value: String!): CreatorInviteIssueReason

  """
  delete single row from the table: "CreatorInvite"
  """
  delete_CreatorInvite_by_pk(id: uuid!): CreatorInvite

  """
  delete data from the table: "CreatorStory"
  """
  delete_CreatorStory(
    """filter the rows which have to be deleted"""
    where: CreatorStory_bool_exp!
  ): CreatorStory_mutation_response

  """
  delete single row from the table: "CreatorStory"
  """
  delete_CreatorStory_by_pk(id: uuid!): CreatorStory

  """
  delete data from the table: "CreatorSurvey"
  """
  delete_CreatorSurvey(
    """filter the rows which have to be deleted"""
    where: CreatorSurvey_bool_exp!
  ): CreatorSurvey_mutation_response

  """
  delete single row from the table: "CreatorSurvey"
  """
  delete_CreatorSurvey_by_pk(id: uuid!): CreatorSurvey

  """
  delete data from the table: "Currency"
  """
  delete_Currency(
    """filter the rows which have to be deleted"""
    where: Currency_bool_exp!
  ): Currency_mutation_response

  """
  delete data from the table: "CurrencyName"
  """
  delete_CurrencyName(
    """filter the rows which have to be deleted"""
    where: CurrencyName_bool_exp!
  ): CurrencyName_mutation_response

  """
  delete single row from the table: "CurrencyName"
  """
  delete_CurrencyName_by_pk(value: String!): CurrencyName

  """
  delete single row from the table: "Currency"
  """
  delete_Currency_by_pk(id: uuid!): Currency

  """
  delete data from the table: "DeletedNftTransaction"
  """
  delete_DeletedNftTransaction(
    """filter the rows which have to be deleted"""
    where: DeletedNftTransaction_bool_exp!
  ): DeletedNftTransaction_mutation_response

  """
  delete single row from the table: "DeletedNftTransaction"
  """
  delete_DeletedNftTransaction_by_pk(txid: String!): DeletedNftTransaction

  """
  delete data from the table: "Dev"
  """
  delete_Dev(
    """filter the rows which have to be deleted"""
    where: Dev_bool_exp!
  ): Dev_mutation_response

  """
  delete single row from the table: "Dev"
  """
  delete_Dev_by_pk(id: uuid!): Dev

  """
  delete data from the table: "DiscordAuth"
  """
  delete_DiscordAuth(
    """filter the rows which have to be deleted"""
    where: DiscordAuth_bool_exp!
  ): DiscordAuth_mutation_response

  """
  delete data from the table: "DiscordAuthToDiscordRole"
  """
  delete_DiscordAuthToDiscordRole(
    """filter the rows which have to be deleted"""
    where: DiscordAuthToDiscordRole_bool_exp!
  ): DiscordAuthToDiscordRole_mutation_response

  """
  delete single row from the table: "DiscordAuthToDiscordRole"
  """
  delete_DiscordAuthToDiscordRole_by_pk(discordAuthId: uuid!, discordRoleId: String!): DiscordAuthToDiscordRole

  """
  delete single row from the table: "DiscordAuth"
  """
  delete_DiscordAuth_by_pk(id: uuid!): DiscordAuth

  """
  delete data from the table: "DiscordRole"
  """
  delete_DiscordRole(
    """filter the rows which have to be deleted"""
    where: DiscordRole_bool_exp!
  ): DiscordRole_mutation_response

  """
  delete single row from the table: "DiscordRole"
  """
  delete_DiscordRole_by_pk(id: String!): DiscordRole

  """
  delete data from the table: "EditionsMerkleAllowlistInfo"
  """
  delete_EditionsMerkleAllowlistInfo(
    """filter the rows which have to be deleted"""
    where: EditionsMerkleAllowlistInfo_bool_exp!
  ): EditionsMerkleAllowlistInfo_mutation_response

  """
  delete single row from the table: "EditionsMerkleAllowlistInfo"
  """
  delete_EditionsMerkleAllowlistInfo_by_pk(id: uuid!): EditionsMerkleAllowlistInfo

  """
  delete data from the table: "ExchangeRates"
  """
  delete_ExchangeRates(
    """filter the rows which have to be deleted"""
    where: ExchangeRates_bool_exp!
  ): ExchangeRates_mutation_response

  """
  delete single row from the table: "ExchangeRates"
  """
  delete_ExchangeRates_by_pk(name: String!): ExchangeRates

  """
  delete data from the table: "InstagramAuth"
  """
  delete_InstagramAuth(
    """filter the rows which have to be deleted"""
    where: InstagramAuth_bool_exp!
  ): InstagramAuth_mutation_response

  """
  delete single row from the table: "InstagramAuth"
  """
  delete_InstagramAuth_by_pk(userId: String!): InstagramAuth

  """
  delete data from the table: "Nft"
  """
  delete_Nft(
    """filter the rows which have to be deleted"""
    where: Nft_bool_exp!
  ): Nft_mutation_response

  """
  delete data from the table: "NftDisclosure"
  """
  delete_NftDisclosure(
    """filter the rows which have to be deleted"""
    where: NftDisclosure_bool_exp!
  ): NftDisclosure_mutation_response

  """
  delete data from the table: "NftDisclosureType"
  """
  delete_NftDisclosureType(
    """filter the rows which have to be deleted"""
    where: NftDisclosureType_bool_exp!
  ): NftDisclosureType_mutation_response

  """
  delete single row from the table: "NftDisclosureType"
  """
  delete_NftDisclosureType_by_pk(value: String!): NftDisclosureType

  """
  delete single row from the table: "NftDisclosure"
  """
  delete_NftDisclosure_by_pk(nftId: String!, type: NftDisclosureType_enum!): NftDisclosure

  """
  delete data from the table: "NftListing"
  """
  delete_NftListing(
    """filter the rows which have to be deleted"""
    where: NftListing_bool_exp!
  ): NftListing_mutation_response

  """
  delete single row from the table: "NftListing"
  """
  delete_NftListing_by_pk(nftId: String!): NftListing

  """
  delete data from the table: "NftMetadata"
  """
  delete_NftMetadata(
    """filter the rows which have to be deleted"""
    where: NftMetadata_bool_exp!
  ): NftMetadata_mutation_response

  """
  delete single row from the table: "NftMetadata"
  """
  delete_NftMetadata_by_pk(id: String!): NftMetadata

  """
  delete data from the table: "NftStatus"
  """
  delete_NftStatus(
    """filter the rows which have to be deleted"""
    where: NftStatus_bool_exp!
  ): NftStatus_mutation_response

  """
  delete single row from the table: "NftStatus"
  """
  delete_NftStatus_by_pk(value: String!): NftStatus

  """
  delete data from the table: "NftToAttribute"
  """
  delete_NftToAttribute(
    """filter the rows which have to be deleted"""
    where: NftToAttribute_bool_exp!
  ): NftToAttribute_mutation_response

  """
  delete single row from the table: "NftToAttribute"
  """
  delete_NftToAttribute_by_pk(attributeId: uuid!, nftId: String!): NftToAttribute

  """
  delete data from the table: "NftToCollaborator"
  """
  delete_NftToCollaborator(
    """filter the rows which have to be deleted"""
    where: NftToCollaborator_bool_exp!
  ): NftToCollaborator_mutation_response

  """
  delete single row from the table: "NftToCollaborator"
  """
  delete_NftToCollaborator_by_pk(collaboratorId: String!, nftId: String!): NftToCollaborator

  """
  delete data from the table: "NftToTag"
  """
  delete_NftToTag(
    """filter the rows which have to be deleted"""
    where: NftToTag_bool_exp!
  ): NftToTag_mutation_response

  """
  delete single row from the table: "NftToTag"
  """
  delete_NftToTag_by_pk(nftId: String!, tagId: uuid!): NftToTag

  """
  delete data from the table: "NftTransaction"
  """
  delete_NftTransaction(
    """filter the rows which have to be deleted"""
    where: NftTransaction_bool_exp!
  ): NftTransaction_mutation_response

  """
  delete data from the table: "NftTransactionRaw"
  """
  delete_NftTransactionRaw(
    """filter the rows which have to be deleted"""
    where: NftTransactionRaw_bool_exp!
  ): NftTransactionRaw_mutation_response

  """
  delete single row from the table: "NftTransactionRaw"
  """
  delete_NftTransactionRaw_by_pk(txid: String!): NftTransactionRaw

  """
  delete data from the table: "NftTransactionSource"
  """
  delete_NftTransactionSource(
    """filter the rows which have to be deleted"""
    where: NftTransactionSource_bool_exp!
  ): NftTransactionSource_mutation_response

  """
  delete single row from the table: "NftTransactionSource"
  """
  delete_NftTransactionSource_by_pk(value: String!): NftTransactionSource

  """
  delete data from the table: "NftTransactionType"
  """
  delete_NftTransactionType(
    """filter the rows which have to be deleted"""
    where: NftTransactionType_bool_exp!
  ): NftTransactionType_mutation_response

  """
  delete single row from the table: "NftTransactionType"
  """
  delete_NftTransactionType_by_pk(value: String!): NftTransactionType

  """
  delete single row from the table: "NftTransaction"
  """
  delete_NftTransaction_by_pk(id: uuid!): NftTransaction

  """
  delete single row from the table: "Nft"
  """
  delete_Nft_by_pk(id: String!): Nft

  """
  delete data from the table: "Notification"
  """
  delete_Notification(
    """filter the rows which have to be deleted"""
    where: Notification_bool_exp!
  ): Notification_mutation_response

  """
  delete data from the table: "NotificationChannel"
  """
  delete_NotificationChannel(
    """filter the rows which have to be deleted"""
    where: NotificationChannel_bool_exp!
  ): NotificationChannel_mutation_response

  """
  delete single row from the table: "NotificationChannel"
  """
  delete_NotificationChannel_by_pk(value: String!): NotificationChannel

  """
  delete data from the table: "NotificationType"
  """
  delete_NotificationType(
    """filter the rows which have to be deleted"""
    where: NotificationType_bool_exp!
  ): NotificationType_mutation_response

  """
  delete single row from the table: "NotificationType"
  """
  delete_NotificationType_by_pk(value: String!): NotificationType

  """
  delete data from the table: "NotificationUserPreference"
  """
  delete_NotificationUserPreference(
    """filter the rows which have to be deleted"""
    where: NotificationUserPreference_bool_exp!
  ): NotificationUserPreference_mutation_response

  """
  delete single row from the table: "NotificationUserPreference"
  """
  delete_NotificationUserPreference_by_pk(notificationChannel: NotificationChannel_enum!, notificationType: NotificationType_enum!, userId: String!): NotificationUserPreference

  """
  delete single row from the table: "Notification"
  """
  delete_Notification_by_pk(id: uuid!): Notification

  """
  delete data from the table: "Offer"
  """
  delete_Offer(
    """filter the rows which have to be deleted"""
    where: Offer_bool_exp!
  ): Offer_mutation_response

  """
  delete single row from the table: "Offer"
  """
  delete_Offer_by_pk(nftTransactionId: uuid!): Offer

  """
  delete data from the table: "Photo"
  """
  delete_Photo(
    """filter the rows which have to be deleted"""
    where: Photo_bool_exp!
  ): Photo_mutation_response

  """
  delete single row from the table: "Photo"
  """
  delete_Photo_by_pk(id: uuid!): Photo

  """
  delete data from the table: "Poll"
  """
  delete_Poll(
    """filter the rows which have to be deleted"""
    where: Poll_bool_exp!
  ): Poll_mutation_response

  """
  delete data from the table: "PollOption"
  """
  delete_PollOption(
    """filter the rows which have to be deleted"""
    where: PollOption_bool_exp!
  ): PollOption_mutation_response

  """
  delete single row from the table: "PollOption"
  """
  delete_PollOption_by_pk(id: uuid!): PollOption

  """
  delete data from the table: "PollResponse"
  """
  delete_PollResponse(
    """filter the rows which have to be deleted"""
    where: PollResponse_bool_exp!
  ): PollResponse_mutation_response

  """
  delete single row from the table: "PollResponse"
  """
  delete_PollResponse_by_pk(id: uuid!): PollResponse

  """
  delete single row from the table: "Poll"
  """
  delete_Poll_by_pk(id: uuid!): Poll

  """
  delete data from the table: "Post"
  """
  delete_Post(
    """filter the rows which have to be deleted"""
    where: Post_bool_exp!
  ): Post_mutation_response

  """
  delete data from the table: "PostVisibility"
  """
  delete_PostVisibility(
    """filter the rows which have to be deleted"""
    where: PostVisibility_bool_exp!
  ): PostVisibility_mutation_response

  """
  delete single row from the table: "PostVisibility"
  """
  delete_PostVisibility_by_pk(value: String!): PostVisibility

  """
  delete single row from the table: "Post"
  """
  delete_Post_by_pk(id: uuid!): Post

  """
  delete data from the table: "PriceFunctionType"
  """
  delete_PriceFunctionType(
    """filter the rows which have to be deleted"""
    where: PriceFunctionType_bool_exp!
  ): PriceFunctionType_mutation_response

  """
  delete single row from the table: "PriceFunctionType"
  """
  delete_PriceFunctionType_by_pk(value: String!): PriceFunctionType

  """
  delete data from the table: "Reaction"
  """
  delete_Reaction(
    """filter the rows which have to be deleted"""
    where: Reaction_bool_exp!
  ): Reaction_mutation_response

  """
  delete data from the table: "ReactionType"
  """
  delete_ReactionType(
    """filter the rows which have to be deleted"""
    where: ReactionType_bool_exp!
  ): ReactionType_mutation_response

  """
  delete single row from the table: "ReactionType"
  """
  delete_ReactionType_by_pk(value: String!): ReactionType

  """
  delete single row from the table: "Reaction"
  """
  delete_Reaction_by_pk(id: uuid!): Reaction

  """
  delete data from the table: "Request"
  """
  delete_Request(
    """filter the rows which have to be deleted"""
    where: Request_bool_exp!
  ): Request_mutation_response

  """
  delete data from the table: "RequestStatus"
  """
  delete_RequestStatus(
    """filter the rows which have to be deleted"""
    where: RequestStatus_bool_exp!
  ): RequestStatus_mutation_response

  """
  delete single row from the table: "RequestStatus"
  """
  delete_RequestStatus_by_pk(value: String!): RequestStatus

  """
  delete single row from the table: "Request"
  """
  delete_Request_by_pk(id: uuid!): Request

  """
  delete data from the table: "Series"
  """
  delete_Series(
    """filter the rows which have to be deleted"""
    where: Series_bool_exp!
  ): Series_mutation_response

  """
  delete data from the table: "SeriesType"
  """
  delete_SeriesType(
    """filter the rows which have to be deleted"""
    where: SeriesType_bool_exp!
  ): SeriesType_mutation_response

  """
  delete single row from the table: "SeriesType"
  """
  delete_SeriesType_by_pk(value: String!): SeriesType

  """
  delete single row from the table: "Series"
  """
  delete_Series_by_pk(id: String!): Series

  """
  delete data from the table: "Spotlight"
  """
  delete_Spotlight(
    """filter the rows which have to be deleted"""
    where: Spotlight_bool_exp!
  ): Spotlight_mutation_response

  """
  delete data from the table: "SpotlightHeroUnitLayout"
  """
  delete_SpotlightHeroUnitLayout(
    """filter the rows which have to be deleted"""
    where: SpotlightHeroUnitLayout_bool_exp!
  ): SpotlightHeroUnitLayout_mutation_response

  """
  delete single row from the table: "SpotlightHeroUnitLayout"
  """
  delete_SpotlightHeroUnitLayout_by_pk(value: String!): SpotlightHeroUnitLayout

  """
  delete data from the table: "SpotlightType"
  """
  delete_SpotlightType(
    """filter the rows which have to be deleted"""
    where: SpotlightType_bool_exp!
  ): SpotlightType_mutation_response

  """
  delete single row from the table: "SpotlightType"
  """
  delete_SpotlightType_by_pk(value: String!): SpotlightType

  """
  delete single row from the table: "Spotlight"
  """
  delete_Spotlight_by_pk(id: uuid!): Spotlight

  """
  delete data from the table: "Tag"
  """
  delete_Tag(
    """filter the rows which have to be deleted"""
    where: Tag_bool_exp!
  ): Tag_mutation_response

  """
  delete single row from the table: "Tag"
  """
  delete_Tag_by_pk(id: uuid!): Tag

  """
  delete data from the table: "TooniesShippingInfo"
  """
  delete_TooniesShippingInfo(
    """filter the rows which have to be deleted"""
    where: TooniesShippingInfo_bool_exp!
  ): TooniesShippingInfo_mutation_response

  """
  delete single row from the table: "TooniesShippingInfo"
  """
  delete_TooniesShippingInfo_by_pk(id: uuid!): TooniesShippingInfo

  """
  delete data from the table: "TwitterAuth"
  """
  delete_TwitterAuth(
    """filter the rows which have to be deleted"""
    where: TwitterAuth_bool_exp!
  ): TwitterAuth_mutation_response

  """
  delete single row from the table: "TwitterAuth"
  """
  delete_TwitterAuth_by_pk(userId: String!): TwitterAuth

  """
  delete data from the table: "Unlockable"
  """
  delete_Unlockable(
    """filter the rows which have to be deleted"""
    where: Unlockable_bool_exp!
  ): Unlockable_mutation_response

  """
  delete data from the table: "UnlockableWinner"
  """
  delete_UnlockableWinner(
    """filter the rows which have to be deleted"""
    where: UnlockableWinner_bool_exp!
  ): UnlockableWinner_mutation_response

  """
  delete single row from the table: "UnlockableWinner"
  """
  delete_UnlockableWinner_by_pk(unlockableId: uuid!, userId: String!): UnlockableWinner

  """
  delete single row from the table: "Unlockable"
  """
  delete_Unlockable_by_pk(id: uuid!): Unlockable

  """
  delete data from the table: "User"
  """
  delete_User(
    """filter the rows which have to be deleted"""
    where: User_bool_exp!
  ): User_mutation_response

  """
  delete data from the table: "UserFollows"
  """
  delete_UserFollows(
    """filter the rows which have to be deleted"""
    where: UserFollows_bool_exp!
  ): UserFollows_mutation_response

  """
  delete single row from the table: "UserFollows"
  """
  delete_UserFollows_by_pk(id: uuid!): UserFollows

  """
  delete single row from the table: "User"
  """
  delete_User_by_pk(id: String!): User

  """
  delete data from the table: "Video"
  """
  delete_Video(
    """filter the rows which have to be deleted"""
    where: Video_bool_exp!
  ): Video_mutation_response

  """
  delete single row from the table: "Video"
  """
  delete_Video_by_pk(id: uuid!): Video

  """
  delete data from the table: "Vote"
  """
  delete_Vote(
    """filter the rows which have to be deleted"""
    where: Vote_bool_exp!
  ): Vote_mutation_response

  """
  delete data from the table: "VoteReason"
  """
  delete_VoteReason(
    """filter the rows which have to be deleted"""
    where: VoteReason_bool_exp!
  ): VoteReason_mutation_response

  """
  delete single row from the table: "VoteReason"
  """
  delete_VoteReason_by_pk(value: String!): VoteReason

  """
  delete data from the table: "VoteType"
  """
  delete_VoteType(
    """filter the rows which have to be deleted"""
    where: VoteType_bool_exp!
  ): VoteType_mutation_response

  """
  delete single row from the table: "VoteType"
  """
  delete_VoteType_by_pk(value: String!): VoteType

  """
  delete single row from the table: "Vote"
  """
  delete_Vote_by_pk(id: uuid!): Vote

  """
  delete data from the table: "Whitelist"
  """
  delete_Whitelist(
    """filter the rows which have to be deleted"""
    where: Whitelist_bool_exp!
  ): Whitelist_mutation_response

  """
  delete single row from the table: "Whitelist"
  """
  delete_Whitelist_by_pk(address: String!): Whitelist

  """
  delete data from the table: "top_collector_stats"
  """
  delete_top_collector_stats(
    """filter the rows which have to be deleted"""
    where: top_collector_stats_bool_exp!
  ): top_collector_stats_mutation_response

  """
  delete data from the table: "top_creator_stats"
  """
  delete_top_creator_stats(
    """filter the rows which have to be deleted"""
    where: top_creator_stats_bool_exp!
  ): top_creator_stats_mutation_response

  """
  insert data into the table: "ActivityNotification"
  """
  insert_ActivityNotification(
    """the rows to be inserted"""
    objects: [ActivityNotification_insert_input!]!

    """upsert condition"""
    on_conflict: ActivityNotification_on_conflict
  ): ActivityNotification_mutation_response

  """
  insert a single row into the table: "ActivityNotification"
  """
  insert_ActivityNotification_one(
    """the row to be inserted"""
    object: ActivityNotification_insert_input!

    """upsert condition"""
    on_conflict: ActivityNotification_on_conflict
  ): ActivityNotification

  """
  insert data into the table: "Airdrop"
  """
  insert_Airdrop(
    """the rows to be inserted"""
    objects: [Airdrop_insert_input!]!

    """upsert condition"""
    on_conflict: Airdrop_on_conflict
  ): Airdrop_mutation_response

  """
  insert data into the table: "AirdropType"
  """
  insert_AirdropType(
    """the rows to be inserted"""
    objects: [AirdropType_insert_input!]!

    """upsert condition"""
    on_conflict: AirdropType_on_conflict
  ): AirdropType_mutation_response

  """
  insert a single row into the table: "AirdropType"
  """
  insert_AirdropType_one(
    """the row to be inserted"""
    object: AirdropType_insert_input!

    """upsert condition"""
    on_conflict: AirdropType_on_conflict
  ): AirdropType

  """
  insert a single row into the table: "Airdrop"
  """
  insert_Airdrop_one(
    """the row to be inserted"""
    object: Airdrop_insert_input!

    """upsert condition"""
    on_conflict: Airdrop_on_conflict
  ): Airdrop

  """
  insert data into the table: "ArtistSubmission"
  """
  insert_ArtistSubmission(
    """the rows to be inserted"""
    objects: [ArtistSubmission_insert_input!]!

    """upsert condition"""
    on_conflict: ArtistSubmission_on_conflict
  ): ArtistSubmission_mutation_response

  """
  insert data into the table: "ArtistSubmissionStatus"
  """
  insert_ArtistSubmissionStatus(
    """the rows to be inserted"""
    objects: [ArtistSubmissionStatus_insert_input!]!

    """upsert condition"""
    on_conflict: ArtistSubmissionStatus_on_conflict
  ): ArtistSubmissionStatus_mutation_response

  """
  insert a single row into the table: "ArtistSubmissionStatus"
  """
  insert_ArtistSubmissionStatus_one(
    """the row to be inserted"""
    object: ArtistSubmissionStatus_insert_input!

    """upsert condition"""
    on_conflict: ArtistSubmissionStatus_on_conflict
  ): ArtistSubmissionStatus

  """
  insert a single row into the table: "ArtistSubmission"
  """
  insert_ArtistSubmission_one(
    """the row to be inserted"""
    object: ArtistSubmission_insert_input!

    """upsert condition"""
    on_conflict: ArtistSubmission_on_conflict
  ): ArtistSubmission

  """
  insert data into the table: "Asset"
  """
  insert_Asset(
    """the rows to be inserted"""
    objects: [Asset_insert_input!]!

    """upsert condition"""
    on_conflict: Asset_on_conflict
  ): Asset_mutation_response

  """
  insert a single row into the table: "Asset"
  """
  insert_Asset_one(
    """the row to be inserted"""
    object: Asset_insert_input!

    """upsert condition"""
    on_conflict: Asset_on_conflict
  ): Asset

  """
  insert data into the table: "Attribute"
  """
  insert_Attribute(
    """the rows to be inserted"""
    objects: [Attribute_insert_input!]!

    """upsert condition"""
    on_conflict: Attribute_on_conflict
  ): Attribute_mutation_response

  """
  insert a single row into the table: "Attribute"
  """
  insert_Attribute_one(
    """the row to be inserted"""
    object: Attribute_insert_input!

    """upsert condition"""
    on_conflict: Attribute_on_conflict
  ): Attribute

  """
  insert data into the table: "BonkClaim"
  """
  insert_BonkClaim(
    """the rows to be inserted"""
    objects: [BonkClaim_insert_input!]!

    """upsert condition"""
    on_conflict: BonkClaim_on_conflict
  ): BonkClaim_mutation_response

  """
  insert a single row into the table: "BonkClaim"
  """
  insert_BonkClaim_one(
    """the row to be inserted"""
    object: BonkClaim_insert_input!

    """upsert condition"""
    on_conflict: BonkClaim_on_conflict
  ): BonkClaim

  """
  insert data into the table: "Campaign"
  """
  insert_Campaign(
    """the rows to be inserted"""
    objects: [Campaign_insert_input!]!

    """upsert condition"""
    on_conflict: Campaign_on_conflict
  ): Campaign_mutation_response

  """
  insert data into the table: "CampaignBenefit"
  """
  insert_CampaignBenefit(
    """the rows to be inserted"""
    objects: [CampaignBenefit_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignBenefit_on_conflict
  ): CampaignBenefit_mutation_response

  """
  insert data into the table: "CampaignBenefitStatus"
  """
  insert_CampaignBenefitStatus(
    """the rows to be inserted"""
    objects: [CampaignBenefitStatus_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignBenefitStatus_on_conflict
  ): CampaignBenefitStatus_mutation_response

  """
  insert a single row into the table: "CampaignBenefitStatus"
  """
  insert_CampaignBenefitStatus_one(
    """the row to be inserted"""
    object: CampaignBenefitStatus_insert_input!

    """upsert condition"""
    on_conflict: CampaignBenefitStatus_on_conflict
  ): CampaignBenefitStatus

  """
  insert data into the table: "CampaignBenefitToNft"
  """
  insert_CampaignBenefitToNft(
    """the rows to be inserted"""
    objects: [CampaignBenefitToNft_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignBenefitToNft_on_conflict
  ): CampaignBenefitToNft_mutation_response

  """
  insert a single row into the table: "CampaignBenefitToNft"
  """
  insert_CampaignBenefitToNft_one(
    """the row to be inserted"""
    object: CampaignBenefitToNft_insert_input!

    """upsert condition"""
    on_conflict: CampaignBenefitToNft_on_conflict
  ): CampaignBenefitToNft

  """
  insert a single row into the table: "CampaignBenefit"
  """
  insert_CampaignBenefit_one(
    """the row to be inserted"""
    object: CampaignBenefit_insert_input!

    """upsert condition"""
    on_conflict: CampaignBenefit_on_conflict
  ): CampaignBenefit

  """
  insert data into the table: "CampaignCategory"
  """
  insert_CampaignCategory(
    """the rows to be inserted"""
    objects: [CampaignCategory_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignCategory_on_conflict
  ): CampaignCategory_mutation_response

  """
  insert a single row into the table: "CampaignCategory"
  """
  insert_CampaignCategory_one(
    """the row to be inserted"""
    object: CampaignCategory_insert_input!

    """upsert condition"""
    on_conflict: CampaignCategory_on_conflict
  ): CampaignCategory

  """
  insert data into the table: "CampaignColorScheme"
  """
  insert_CampaignColorScheme(
    """the rows to be inserted"""
    objects: [CampaignColorScheme_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignColorScheme_on_conflict
  ): CampaignColorScheme_mutation_response

  """
  insert a single row into the table: "CampaignColorScheme"
  """
  insert_CampaignColorScheme_one(
    """the row to be inserted"""
    object: CampaignColorScheme_insert_input!

    """upsert condition"""
    on_conflict: CampaignColorScheme_on_conflict
  ): CampaignColorScheme

  """
  insert data into the table: "CampaignFundingTier"
  """
  insert_CampaignFundingTier(
    """the rows to be inserted"""
    objects: [CampaignFundingTier_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignFundingTier_on_conflict
  ): CampaignFundingTier_mutation_response

  """
  insert data into the table: "CampaignFundingTierType"
  """
  insert_CampaignFundingTierType(
    """the rows to be inserted"""
    objects: [CampaignFundingTierType_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignFundingTierType_on_conflict
  ): CampaignFundingTierType_mutation_response

  """
  insert a single row into the table: "CampaignFundingTierType"
  """
  insert_CampaignFundingTierType_one(
    """the row to be inserted"""
    object: CampaignFundingTierType_insert_input!

    """upsert condition"""
    on_conflict: CampaignFundingTierType_on_conflict
  ): CampaignFundingTierType

  """
  insert a single row into the table: "CampaignFundingTier"
  """
  insert_CampaignFundingTier_one(
    """the row to be inserted"""
    object: CampaignFundingTier_insert_input!

    """upsert condition"""
    on_conflict: CampaignFundingTier_on_conflict
  ): CampaignFundingTier

  """
  insert data into the table: "CampaignGoalType"
  """
  insert_CampaignGoalType(
    """the rows to be inserted"""
    objects: [CampaignGoalType_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignGoalType_on_conflict
  ): CampaignGoalType_mutation_response

  """
  insert a single row into the table: "CampaignGoalType"
  """
  insert_CampaignGoalType_one(
    """the row to be inserted"""
    object: CampaignGoalType_insert_input!

    """upsert condition"""
    on_conflict: CampaignGoalType_on_conflict
  ): CampaignGoalType

  """
  insert data into the table: "CampaignStatus"
  """
  insert_CampaignStatus(
    """the rows to be inserted"""
    objects: [CampaignStatus_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignStatus_on_conflict
  ): CampaignStatus_mutation_response

  """
  insert a single row into the table: "CampaignStatus"
  """
  insert_CampaignStatus_one(
    """the row to be inserted"""
    object: CampaignStatus_insert_input!

    """upsert condition"""
    on_conflict: CampaignStatus_on_conflict
  ): CampaignStatus

  """
  insert data into the table: "CampaignTeamMemberRole"
  """
  insert_CampaignTeamMemberRole(
    """the rows to be inserted"""
    objects: [CampaignTeamMemberRole_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignTeamMemberRole_on_conflict
  ): CampaignTeamMemberRole_mutation_response

  """
  insert a single row into the table: "CampaignTeamMemberRole"
  """
  insert_CampaignTeamMemberRole_one(
    """the row to be inserted"""
    object: CampaignTeamMemberRole_insert_input!

    """upsert condition"""
    on_conflict: CampaignTeamMemberRole_on_conflict
  ): CampaignTeamMemberRole

  """
  insert data into the table: "CampaignToCollaborator"
  """
  insert_CampaignToCollaborator(
    """the rows to be inserted"""
    objects: [CampaignToCollaborator_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignToCollaborator_on_conflict
  ): CampaignToCollaborator_mutation_response

  """
  insert a single row into the table: "CampaignToCollaborator"
  """
  insert_CampaignToCollaborator_one(
    """the row to be inserted"""
    object: CampaignToCollaborator_insert_input!

    """upsert condition"""
    on_conflict: CampaignToCollaborator_on_conflict
  ): CampaignToCollaborator

  """
  insert data into the table: "CampaignToHolder"
  """
  insert_CampaignToHolder(
    """the rows to be inserted"""
    objects: [CampaignToHolder_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignToHolder_on_conflict
  ): CampaignToHolder_mutation_response

  """
  insert a single row into the table: "CampaignToHolder"
  """
  insert_CampaignToHolder_one(
    """the row to be inserted"""
    object: CampaignToHolder_insert_input!

    """upsert condition"""
    on_conflict: CampaignToHolder_on_conflict
  ): CampaignToHolder

  """
  insert data into the table: "CampaignToTeamMember"
  """
  insert_CampaignToTeamMember(
    """the rows to be inserted"""
    objects: [CampaignToTeamMember_insert_input!]!

    """upsert condition"""
    on_conflict: CampaignToTeamMember_on_conflict
  ): CampaignToTeamMember_mutation_response

  """
  insert a single row into the table: "CampaignToTeamMember"
  """
  insert_CampaignToTeamMember_one(
    """the row to be inserted"""
    object: CampaignToTeamMember_insert_input!

    """upsert condition"""
    on_conflict: CampaignToTeamMember_on_conflict
  ): CampaignToTeamMember

  """
  insert a single row into the table: "Campaign"
  """
  insert_Campaign_one(
    """the row to be inserted"""
    object: Campaign_insert_input!

    """upsert condition"""
    on_conflict: Campaign_on_conflict
  ): Campaign

  """
  insert data into the table: "CandyMachine"
  """
  insert_CandyMachine(
    """the rows to be inserted"""
    objects: [CandyMachine_insert_input!]!

    """upsert condition"""
    on_conflict: CandyMachine_on_conflict
  ): CandyMachine_mutation_response

  """
  insert data into the table: "CandyMachineMerkleAllowlistInfo"
  """
  insert_CandyMachineMerkleAllowlistInfo(
    """the rows to be inserted"""
    objects: [CandyMachineMerkleAllowlistInfo_insert_input!]!

    """upsert condition"""
    on_conflict: CandyMachineMerkleAllowlistInfo_on_conflict
  ): CandyMachineMerkleAllowlistInfo_mutation_response

  """
  insert a single row into the table: "CandyMachineMerkleAllowlistInfo"
  """
  insert_CandyMachineMerkleAllowlistInfo_one(
    """the row to be inserted"""
    object: CandyMachineMerkleAllowlistInfo_insert_input!

    """upsert condition"""
    on_conflict: CandyMachineMerkleAllowlistInfo_on_conflict
  ): CandyMachineMerkleAllowlistInfo

  """
  insert a single row into the table: "CandyMachine"
  """
  insert_CandyMachine_one(
    """the row to be inserted"""
    object: CandyMachine_insert_input!

    """upsert condition"""
    on_conflict: CandyMachine_on_conflict
  ): CandyMachine

  """
  insert data into the table: "Claim"
  """
  insert_Claim(
    """the rows to be inserted"""
    objects: [Claim_insert_input!]!

    """upsert condition"""
    on_conflict: Claim_on_conflict
  ): Claim_mutation_response

  """
  insert a single row into the table: "Claim"
  """
  insert_Claim_one(
    """the row to be inserted"""
    object: Claim_insert_input!

    """upsert condition"""
    on_conflict: Claim_on_conflict
  ): Claim

  """
  insert data into the table: "CollectorSurvey"
  """
  insert_CollectorSurvey(
    """the rows to be inserted"""
    objects: [CollectorSurvey_insert_input!]!

    """upsert condition"""
    on_conflict: CollectorSurvey_on_conflict
  ): CollectorSurvey_mutation_response

  """
  insert a single row into the table: "CollectorSurvey"
  """
  insert_CollectorSurvey_one(
    """the row to be inserted"""
    object: CollectorSurvey_insert_input!

    """upsert condition"""
    on_conflict: CollectorSurvey_on_conflict
  ): CollectorSurvey

  """
  insert data into the table: "Comment"
  """
  insert_Comment(
    """the rows to be inserted"""
    objects: [Comment_insert_input!]!

    """upsert condition"""
    on_conflict: Comment_on_conflict
  ): Comment_mutation_response

  """
  insert a single row into the table: "Comment"
  """
  insert_Comment_one(
    """the row to be inserted"""
    object: Comment_insert_input!

    """upsert condition"""
    on_conflict: Comment_on_conflict
  ): Comment

  """
  insert data into the table: "CreatorInvite"
  """
  insert_CreatorInvite(
    """the rows to be inserted"""
    objects: [CreatorInvite_insert_input!]!

    """upsert condition"""
    on_conflict: CreatorInvite_on_conflict
  ): CreatorInvite_mutation_response

  """
  insert data into the table: "CreatorInviteIssueReason"
  """
  insert_CreatorInviteIssueReason(
    """the rows to be inserted"""
    objects: [CreatorInviteIssueReason_insert_input!]!

    """upsert condition"""
    on_conflict: CreatorInviteIssueReason_on_conflict
  ): CreatorInviteIssueReason_mutation_response

  """
  insert a single row into the table: "CreatorInviteIssueReason"
  """
  insert_CreatorInviteIssueReason_one(
    """the row to be inserted"""
    object: CreatorInviteIssueReason_insert_input!

    """upsert condition"""
    on_conflict: CreatorInviteIssueReason_on_conflict
  ): CreatorInviteIssueReason

  """
  insert a single row into the table: "CreatorInvite"
  """
  insert_CreatorInvite_one(
    """the row to be inserted"""
    object: CreatorInvite_insert_input!

    """upsert condition"""
    on_conflict: CreatorInvite_on_conflict
  ): CreatorInvite

  """
  insert data into the table: "CreatorStory"
  """
  insert_CreatorStory(
    """the rows to be inserted"""
    objects: [CreatorStory_insert_input!]!

    """upsert condition"""
    on_conflict: CreatorStory_on_conflict
  ): CreatorStory_mutation_response

  """
  insert a single row into the table: "CreatorStory"
  """
  insert_CreatorStory_one(
    """the row to be inserted"""
    object: CreatorStory_insert_input!

    """upsert condition"""
    on_conflict: CreatorStory_on_conflict
  ): CreatorStory

  """
  insert data into the table: "CreatorSurvey"
  """
  insert_CreatorSurvey(
    """the rows to be inserted"""
    objects: [CreatorSurvey_insert_input!]!

    """upsert condition"""
    on_conflict: CreatorSurvey_on_conflict
  ): CreatorSurvey_mutation_response

  """
  insert a single row into the table: "CreatorSurvey"
  """
  insert_CreatorSurvey_one(
    """the row to be inserted"""
    object: CreatorSurvey_insert_input!

    """upsert condition"""
    on_conflict: CreatorSurvey_on_conflict
  ): CreatorSurvey

  """
  insert data into the table: "Currency"
  """
  insert_Currency(
    """the rows to be inserted"""
    objects: [Currency_insert_input!]!

    """upsert condition"""
    on_conflict: Currency_on_conflict
  ): Currency_mutation_response

  """
  insert data into the table: "CurrencyName"
  """
  insert_CurrencyName(
    """the rows to be inserted"""
    objects: [CurrencyName_insert_input!]!

    """upsert condition"""
    on_conflict: CurrencyName_on_conflict
  ): CurrencyName_mutation_response

  """
  insert a single row into the table: "CurrencyName"
  """
  insert_CurrencyName_one(
    """the row to be inserted"""
    object: CurrencyName_insert_input!

    """upsert condition"""
    on_conflict: CurrencyName_on_conflict
  ): CurrencyName

  """
  insert a single row into the table: "Currency"
  """
  insert_Currency_one(
    """the row to be inserted"""
    object: Currency_insert_input!

    """upsert condition"""
    on_conflict: Currency_on_conflict
  ): Currency

  """
  insert data into the table: "DeletedNftTransaction"
  """
  insert_DeletedNftTransaction(
    """the rows to be inserted"""
    objects: [DeletedNftTransaction_insert_input!]!

    """upsert condition"""
    on_conflict: DeletedNftTransaction_on_conflict
  ): DeletedNftTransaction_mutation_response

  """
  insert a single row into the table: "DeletedNftTransaction"
  """
  insert_DeletedNftTransaction_one(
    """the row to be inserted"""
    object: DeletedNftTransaction_insert_input!

    """upsert condition"""
    on_conflict: DeletedNftTransaction_on_conflict
  ): DeletedNftTransaction

  """
  insert data into the table: "Dev"
  """
  insert_Dev(
    """the rows to be inserted"""
    objects: [Dev_insert_input!]!

    """upsert condition"""
    on_conflict: Dev_on_conflict
  ): Dev_mutation_response

  """
  insert a single row into the table: "Dev"
  """
  insert_Dev_one(
    """the row to be inserted"""
    object: Dev_insert_input!

    """upsert condition"""
    on_conflict: Dev_on_conflict
  ): Dev

  """
  insert data into the table: "DiscordAuth"
  """
  insert_DiscordAuth(
    """the rows to be inserted"""
    objects: [DiscordAuth_insert_input!]!

    """upsert condition"""
    on_conflict: DiscordAuth_on_conflict
  ): DiscordAuth_mutation_response

  """
  insert data into the table: "DiscordAuthToDiscordRole"
  """
  insert_DiscordAuthToDiscordRole(
    """the rows to be inserted"""
    objects: [DiscordAuthToDiscordRole_insert_input!]!

    """upsert condition"""
    on_conflict: DiscordAuthToDiscordRole_on_conflict
  ): DiscordAuthToDiscordRole_mutation_response

  """
  insert a single row into the table: "DiscordAuthToDiscordRole"
  """
  insert_DiscordAuthToDiscordRole_one(
    """the row to be inserted"""
    object: DiscordAuthToDiscordRole_insert_input!

    """upsert condition"""
    on_conflict: DiscordAuthToDiscordRole_on_conflict
  ): DiscordAuthToDiscordRole

  """
  insert a single row into the table: "DiscordAuth"
  """
  insert_DiscordAuth_one(
    """the row to be inserted"""
    object: DiscordAuth_insert_input!

    """upsert condition"""
    on_conflict: DiscordAuth_on_conflict
  ): DiscordAuth

  """
  insert data into the table: "DiscordRole"
  """
  insert_DiscordRole(
    """the rows to be inserted"""
    objects: [DiscordRole_insert_input!]!

    """upsert condition"""
    on_conflict: DiscordRole_on_conflict
  ): DiscordRole_mutation_response

  """
  insert a single row into the table: "DiscordRole"
  """
  insert_DiscordRole_one(
    """the row to be inserted"""
    object: DiscordRole_insert_input!

    """upsert condition"""
    on_conflict: DiscordRole_on_conflict
  ): DiscordRole

  """
  insert data into the table: "EditionsMerkleAllowlistInfo"
  """
  insert_EditionsMerkleAllowlistInfo(
    """the rows to be inserted"""
    objects: [EditionsMerkleAllowlistInfo_insert_input!]!

    """upsert condition"""
    on_conflict: EditionsMerkleAllowlistInfo_on_conflict
  ): EditionsMerkleAllowlistInfo_mutation_response

  """
  insert a single row into the table: "EditionsMerkleAllowlistInfo"
  """
  insert_EditionsMerkleAllowlistInfo_one(
    """the row to be inserted"""
    object: EditionsMerkleAllowlistInfo_insert_input!

    """upsert condition"""
    on_conflict: EditionsMerkleAllowlistInfo_on_conflict
  ): EditionsMerkleAllowlistInfo

  """
  insert data into the table: "ExchangeRates"
  """
  insert_ExchangeRates(
    """the rows to be inserted"""
    objects: [ExchangeRates_insert_input!]!

    """upsert condition"""
    on_conflict: ExchangeRates_on_conflict
  ): ExchangeRates_mutation_response

  """
  insert a single row into the table: "ExchangeRates"
  """
  insert_ExchangeRates_one(
    """the row to be inserted"""
    object: ExchangeRates_insert_input!

    """upsert condition"""
    on_conflict: ExchangeRates_on_conflict
  ): ExchangeRates

  """
  insert data into the table: "InstagramAuth"
  """
  insert_InstagramAuth(
    """the rows to be inserted"""
    objects: [InstagramAuth_insert_input!]!

    """upsert condition"""
    on_conflict: InstagramAuth_on_conflict
  ): InstagramAuth_mutation_response

  """
  insert a single row into the table: "InstagramAuth"
  """
  insert_InstagramAuth_one(
    """the row to be inserted"""
    object: InstagramAuth_insert_input!

    """upsert condition"""
    on_conflict: InstagramAuth_on_conflict
  ): InstagramAuth

  """
  insert data into the table: "Nft"
  """
  insert_Nft(
    """the rows to be inserted"""
    objects: [Nft_insert_input!]!

    """upsert condition"""
    on_conflict: Nft_on_conflict
  ): Nft_mutation_response

  """
  insert data into the table: "NftDisclosure"
  """
  insert_NftDisclosure(
    """the rows to be inserted"""
    objects: [NftDisclosure_insert_input!]!

    """upsert condition"""
    on_conflict: NftDisclosure_on_conflict
  ): NftDisclosure_mutation_response

  """
  insert data into the table: "NftDisclosureType"
  """
  insert_NftDisclosureType(
    """the rows to be inserted"""
    objects: [NftDisclosureType_insert_input!]!

    """upsert condition"""
    on_conflict: NftDisclosureType_on_conflict
  ): NftDisclosureType_mutation_response

  """
  insert a single row into the table: "NftDisclosureType"
  """
  insert_NftDisclosureType_one(
    """the row to be inserted"""
    object: NftDisclosureType_insert_input!

    """upsert condition"""
    on_conflict: NftDisclosureType_on_conflict
  ): NftDisclosureType

  """
  insert a single row into the table: "NftDisclosure"
  """
  insert_NftDisclosure_one(
    """the row to be inserted"""
    object: NftDisclosure_insert_input!

    """upsert condition"""
    on_conflict: NftDisclosure_on_conflict
  ): NftDisclosure

  """
  insert data into the table: "NftListing"
  """
  insert_NftListing(
    """the rows to be inserted"""
    objects: [NftListing_insert_input!]!

    """upsert condition"""
    on_conflict: NftListing_on_conflict
  ): NftListing_mutation_response

  """
  insert a single row into the table: "NftListing"
  """
  insert_NftListing_one(
    """the row to be inserted"""
    object: NftListing_insert_input!

    """upsert condition"""
    on_conflict: NftListing_on_conflict
  ): NftListing

  """
  insert data into the table: "NftMetadata"
  """
  insert_NftMetadata(
    """the rows to be inserted"""
    objects: [NftMetadata_insert_input!]!

    """upsert condition"""
    on_conflict: NftMetadata_on_conflict
  ): NftMetadata_mutation_response

  """
  insert a single row into the table: "NftMetadata"
  """
  insert_NftMetadata_one(
    """the row to be inserted"""
    object: NftMetadata_insert_input!

    """upsert condition"""
    on_conflict: NftMetadata_on_conflict
  ): NftMetadata

  """
  insert data into the table: "NftStatus"
  """
  insert_NftStatus(
    """the rows to be inserted"""
    objects: [NftStatus_insert_input!]!

    """upsert condition"""
    on_conflict: NftStatus_on_conflict
  ): NftStatus_mutation_response

  """
  insert a single row into the table: "NftStatus"
  """
  insert_NftStatus_one(
    """the row to be inserted"""
    object: NftStatus_insert_input!

    """upsert condition"""
    on_conflict: NftStatus_on_conflict
  ): NftStatus

  """
  insert data into the table: "NftToAttribute"
  """
  insert_NftToAttribute(
    """the rows to be inserted"""
    objects: [NftToAttribute_insert_input!]!

    """upsert condition"""
    on_conflict: NftToAttribute_on_conflict
  ): NftToAttribute_mutation_response

  """
  insert a single row into the table: "NftToAttribute"
  """
  insert_NftToAttribute_one(
    """the row to be inserted"""
    object: NftToAttribute_insert_input!

    """upsert condition"""
    on_conflict: NftToAttribute_on_conflict
  ): NftToAttribute

  """
  insert data into the table: "NftToCollaborator"
  """
  insert_NftToCollaborator(
    """the rows to be inserted"""
    objects: [NftToCollaborator_insert_input!]!

    """upsert condition"""
    on_conflict: NftToCollaborator_on_conflict
  ): NftToCollaborator_mutation_response

  """
  insert a single row into the table: "NftToCollaborator"
  """
  insert_NftToCollaborator_one(
    """the row to be inserted"""
    object: NftToCollaborator_insert_input!

    """upsert condition"""
    on_conflict: NftToCollaborator_on_conflict
  ): NftToCollaborator

  """
  insert data into the table: "NftToTag"
  """
  insert_NftToTag(
    """the rows to be inserted"""
    objects: [NftToTag_insert_input!]!

    """upsert condition"""
    on_conflict: NftToTag_on_conflict
  ): NftToTag_mutation_response

  """
  insert a single row into the table: "NftToTag"
  """
  insert_NftToTag_one(
    """the row to be inserted"""
    object: NftToTag_insert_input!

    """upsert condition"""
    on_conflict: NftToTag_on_conflict
  ): NftToTag

  """
  insert data into the table: "NftTransaction"
  """
  insert_NftTransaction(
    """the rows to be inserted"""
    objects: [NftTransaction_insert_input!]!

    """upsert condition"""
    on_conflict: NftTransaction_on_conflict
  ): NftTransaction_mutation_response

  """
  insert data into the table: "NftTransactionRaw"
  """
  insert_NftTransactionRaw(
    """the rows to be inserted"""
    objects: [NftTransactionRaw_insert_input!]!

    """upsert condition"""
    on_conflict: NftTransactionRaw_on_conflict
  ): NftTransactionRaw_mutation_response

  """
  insert a single row into the table: "NftTransactionRaw"
  """
  insert_NftTransactionRaw_one(
    """the row to be inserted"""
    object: NftTransactionRaw_insert_input!

    """upsert condition"""
    on_conflict: NftTransactionRaw_on_conflict
  ): NftTransactionRaw

  """
  insert data into the table: "NftTransactionSource"
  """
  insert_NftTransactionSource(
    """the rows to be inserted"""
    objects: [NftTransactionSource_insert_input!]!

    """upsert condition"""
    on_conflict: NftTransactionSource_on_conflict
  ): NftTransactionSource_mutation_response

  """
  insert a single row into the table: "NftTransactionSource"
  """
  insert_NftTransactionSource_one(
    """the row to be inserted"""
    object: NftTransactionSource_insert_input!

    """upsert condition"""
    on_conflict: NftTransactionSource_on_conflict
  ): NftTransactionSource

  """
  insert data into the table: "NftTransactionType"
  """
  insert_NftTransactionType(
    """the rows to be inserted"""
    objects: [NftTransactionType_insert_input!]!

    """upsert condition"""
    on_conflict: NftTransactionType_on_conflict
  ): NftTransactionType_mutation_response

  """
  insert a single row into the table: "NftTransactionType"
  """
  insert_NftTransactionType_one(
    """the row to be inserted"""
    object: NftTransactionType_insert_input!

    """upsert condition"""
    on_conflict: NftTransactionType_on_conflict
  ): NftTransactionType

  """
  insert a single row into the table: "NftTransaction"
  """
  insert_NftTransaction_one(
    """the row to be inserted"""
    object: NftTransaction_insert_input!

    """upsert condition"""
    on_conflict: NftTransaction_on_conflict
  ): NftTransaction

  """
  insert a single row into the table: "Nft"
  """
  insert_Nft_one(
    """the row to be inserted"""
    object: Nft_insert_input!

    """upsert condition"""
    on_conflict: Nft_on_conflict
  ): Nft

  """
  insert data into the table: "Notification"
  """
  insert_Notification(
    """the rows to be inserted"""
    objects: [Notification_insert_input!]!

    """upsert condition"""
    on_conflict: Notification_on_conflict
  ): Notification_mutation_response

  """
  insert data into the table: "NotificationChannel"
  """
  insert_NotificationChannel(
    """the rows to be inserted"""
    objects: [NotificationChannel_insert_input!]!

    """upsert condition"""
    on_conflict: NotificationChannel_on_conflict
  ): NotificationChannel_mutation_response

  """
  insert a single row into the table: "NotificationChannel"
  """
  insert_NotificationChannel_one(
    """the row to be inserted"""
    object: NotificationChannel_insert_input!

    """upsert condition"""
    on_conflict: NotificationChannel_on_conflict
  ): NotificationChannel

  """
  insert data into the table: "NotificationType"
  """
  insert_NotificationType(
    """the rows to be inserted"""
    objects: [NotificationType_insert_input!]!

    """upsert condition"""
    on_conflict: NotificationType_on_conflict
  ): NotificationType_mutation_response

  """
  insert a single row into the table: "NotificationType"
  """
  insert_NotificationType_one(
    """the row to be inserted"""
    object: NotificationType_insert_input!

    """upsert condition"""
    on_conflict: NotificationType_on_conflict
  ): NotificationType

  """
  insert data into the table: "NotificationUserPreference"
  """
  insert_NotificationUserPreference(
    """the rows to be inserted"""
    objects: [NotificationUserPreference_insert_input!]!

    """upsert condition"""
    on_conflict: NotificationUserPreference_on_conflict
  ): NotificationUserPreference_mutation_response

  """
  insert a single row into the table: "NotificationUserPreference"
  """
  insert_NotificationUserPreference_one(
    """the row to be inserted"""
    object: NotificationUserPreference_insert_input!

    """upsert condition"""
    on_conflict: NotificationUserPreference_on_conflict
  ): NotificationUserPreference

  """
  insert a single row into the table: "Notification"
  """
  insert_Notification_one(
    """the row to be inserted"""
    object: Notification_insert_input!

    """upsert condition"""
    on_conflict: Notification_on_conflict
  ): Notification

  """
  insert data into the table: "Offer"
  """
  insert_Offer(
    """the rows to be inserted"""
    objects: [Offer_insert_input!]!

    """upsert condition"""
    on_conflict: Offer_on_conflict
  ): Offer_mutation_response

  """
  insert a single row into the table: "Offer"
  """
  insert_Offer_one(
    """the row to be inserted"""
    object: Offer_insert_input!

    """upsert condition"""
    on_conflict: Offer_on_conflict
  ): Offer

  """
  insert data into the table: "Photo"
  """
  insert_Photo(
    """the rows to be inserted"""
    objects: [Photo_insert_input!]!

    """upsert condition"""
    on_conflict: Photo_on_conflict
  ): Photo_mutation_response

  """
  insert a single row into the table: "Photo"
  """
  insert_Photo_one(
    """the row to be inserted"""
    object: Photo_insert_input!

    """upsert condition"""
    on_conflict: Photo_on_conflict
  ): Photo

  """
  insert data into the table: "Poll"
  """
  insert_Poll(
    """the rows to be inserted"""
    objects: [Poll_insert_input!]!

    """upsert condition"""
    on_conflict: Poll_on_conflict
  ): Poll_mutation_response

  """
  insert data into the table: "PollOption"
  """
  insert_PollOption(
    """the rows to be inserted"""
    objects: [PollOption_insert_input!]!

    """upsert condition"""
    on_conflict: PollOption_on_conflict
  ): PollOption_mutation_response

  """
  insert a single row into the table: "PollOption"
  """
  insert_PollOption_one(
    """the row to be inserted"""
    object: PollOption_insert_input!

    """upsert condition"""
    on_conflict: PollOption_on_conflict
  ): PollOption

  """
  insert data into the table: "PollResponse"
  """
  insert_PollResponse(
    """the rows to be inserted"""
    objects: [PollResponse_insert_input!]!

    """upsert condition"""
    on_conflict: PollResponse_on_conflict
  ): PollResponse_mutation_response

  """
  insert a single row into the table: "PollResponse"
  """
  insert_PollResponse_one(
    """the row to be inserted"""
    object: PollResponse_insert_input!

    """upsert condition"""
    on_conflict: PollResponse_on_conflict
  ): PollResponse

  """
  insert a single row into the table: "Poll"
  """
  insert_Poll_one(
    """the row to be inserted"""
    object: Poll_insert_input!

    """upsert condition"""
    on_conflict: Poll_on_conflict
  ): Poll

  """
  insert data into the table: "Post"
  """
  insert_Post(
    """the rows to be inserted"""
    objects: [Post_insert_input!]!

    """upsert condition"""
    on_conflict: Post_on_conflict
  ): Post_mutation_response

  """
  insert data into the table: "PostVisibility"
  """
  insert_PostVisibility(
    """the rows to be inserted"""
    objects: [PostVisibility_insert_input!]!

    """upsert condition"""
    on_conflict: PostVisibility_on_conflict
  ): PostVisibility_mutation_response

  """
  insert a single row into the table: "PostVisibility"
  """
  insert_PostVisibility_one(
    """the row to be inserted"""
    object: PostVisibility_insert_input!

    """upsert condition"""
    on_conflict: PostVisibility_on_conflict
  ): PostVisibility

  """
  insert a single row into the table: "Post"
  """
  insert_Post_one(
    """the row to be inserted"""
    object: Post_insert_input!

    """upsert condition"""
    on_conflict: Post_on_conflict
  ): Post

  """
  insert data into the table: "PriceFunctionType"
  """
  insert_PriceFunctionType(
    """the rows to be inserted"""
    objects: [PriceFunctionType_insert_input!]!

    """upsert condition"""
    on_conflict: PriceFunctionType_on_conflict
  ): PriceFunctionType_mutation_response

  """
  insert a single row into the table: "PriceFunctionType"
  """
  insert_PriceFunctionType_one(
    """the row to be inserted"""
    object: PriceFunctionType_insert_input!

    """upsert condition"""
    on_conflict: PriceFunctionType_on_conflict
  ): PriceFunctionType

  """
  insert data into the table: "Reaction"
  """
  insert_Reaction(
    """the rows to be inserted"""
    objects: [Reaction_insert_input!]!

    """upsert condition"""
    on_conflict: Reaction_on_conflict
  ): Reaction_mutation_response

  """
  insert data into the table: "ReactionType"
  """
  insert_ReactionType(
    """the rows to be inserted"""
    objects: [ReactionType_insert_input!]!

    """upsert condition"""
    on_conflict: ReactionType_on_conflict
  ): ReactionType_mutation_response

  """
  insert a single row into the table: "ReactionType"
  """
  insert_ReactionType_one(
    """the row to be inserted"""
    object: ReactionType_insert_input!

    """upsert condition"""
    on_conflict: ReactionType_on_conflict
  ): ReactionType

  """
  insert a single row into the table: "Reaction"
  """
  insert_Reaction_one(
    """the row to be inserted"""
    object: Reaction_insert_input!

    """upsert condition"""
    on_conflict: Reaction_on_conflict
  ): Reaction

  """
  insert data into the table: "Request"
  """
  insert_Request(
    """the rows to be inserted"""
    objects: [Request_insert_input!]!

    """upsert condition"""
    on_conflict: Request_on_conflict
  ): Request_mutation_response

  """
  insert data into the table: "RequestStatus"
  """
  insert_RequestStatus(
    """the rows to be inserted"""
    objects: [RequestStatus_insert_input!]!

    """upsert condition"""
    on_conflict: RequestStatus_on_conflict
  ): RequestStatus_mutation_response

  """
  insert a single row into the table: "RequestStatus"
  """
  insert_RequestStatus_one(
    """the row to be inserted"""
    object: RequestStatus_insert_input!

    """upsert condition"""
    on_conflict: RequestStatus_on_conflict
  ): RequestStatus

  """
  insert a single row into the table: "Request"
  """
  insert_Request_one(
    """the row to be inserted"""
    object: Request_insert_input!

    """upsert condition"""
    on_conflict: Request_on_conflict
  ): Request

  """
  insert data into the table: "Series"
  """
  insert_Series(
    """the rows to be inserted"""
    objects: [Series_insert_input!]!

    """upsert condition"""
    on_conflict: Series_on_conflict
  ): Series_mutation_response

  """
  insert data into the table: "SeriesType"
  """
  insert_SeriesType(
    """the rows to be inserted"""
    objects: [SeriesType_insert_input!]!

    """upsert condition"""
    on_conflict: SeriesType_on_conflict
  ): SeriesType_mutation_response

  """
  insert a single row into the table: "SeriesType"
  """
  insert_SeriesType_one(
    """the row to be inserted"""
    object: SeriesType_insert_input!

    """upsert condition"""
    on_conflict: SeriesType_on_conflict
  ): SeriesType

  """
  insert a single row into the table: "Series"
  """
  insert_Series_one(
    """the row to be inserted"""
    object: Series_insert_input!

    """upsert condition"""
    on_conflict: Series_on_conflict
  ): Series

  """
  insert data into the table: "Spotlight"
  """
  insert_Spotlight(
    """the rows to be inserted"""
    objects: [Spotlight_insert_input!]!

    """upsert condition"""
    on_conflict: Spotlight_on_conflict
  ): Spotlight_mutation_response

  """
  insert data into the table: "SpotlightHeroUnitLayout"
  """
  insert_SpotlightHeroUnitLayout(
    """the rows to be inserted"""
    objects: [SpotlightHeroUnitLayout_insert_input!]!

    """upsert condition"""
    on_conflict: SpotlightHeroUnitLayout_on_conflict
  ): SpotlightHeroUnitLayout_mutation_response

  """
  insert a single row into the table: "SpotlightHeroUnitLayout"
  """
  insert_SpotlightHeroUnitLayout_one(
    """the row to be inserted"""
    object: SpotlightHeroUnitLayout_insert_input!

    """upsert condition"""
    on_conflict: SpotlightHeroUnitLayout_on_conflict
  ): SpotlightHeroUnitLayout

  """
  insert data into the table: "SpotlightType"
  """
  insert_SpotlightType(
    """the rows to be inserted"""
    objects: [SpotlightType_insert_input!]!

    """upsert condition"""
    on_conflict: SpotlightType_on_conflict
  ): SpotlightType_mutation_response

  """
  insert a single row into the table: "SpotlightType"
  """
  insert_SpotlightType_one(
    """the row to be inserted"""
    object: SpotlightType_insert_input!

    """upsert condition"""
    on_conflict: SpotlightType_on_conflict
  ): SpotlightType

  """
  insert a single row into the table: "Spotlight"
  """
  insert_Spotlight_one(
    """the row to be inserted"""
    object: Spotlight_insert_input!

    """upsert condition"""
    on_conflict: Spotlight_on_conflict
  ): Spotlight

  """
  insert data into the table: "Tag"
  """
  insert_Tag(
    """the rows to be inserted"""
    objects: [Tag_insert_input!]!

    """upsert condition"""
    on_conflict: Tag_on_conflict
  ): Tag_mutation_response

  """
  insert a single row into the table: "Tag"
  """
  insert_Tag_one(
    """the row to be inserted"""
    object: Tag_insert_input!

    """upsert condition"""
    on_conflict: Tag_on_conflict
  ): Tag

  """
  insert data into the table: "TooniesShippingInfo"
  """
  insert_TooniesShippingInfo(
    """the rows to be inserted"""
    objects: [TooniesShippingInfo_insert_input!]!

    """upsert condition"""
    on_conflict: TooniesShippingInfo_on_conflict
  ): TooniesShippingInfo_mutation_response

  """
  insert a single row into the table: "TooniesShippingInfo"
  """
  insert_TooniesShippingInfo_one(
    """the row to be inserted"""
    object: TooniesShippingInfo_insert_input!

    """upsert condition"""
    on_conflict: TooniesShippingInfo_on_conflict
  ): TooniesShippingInfo

  """
  insert data into the table: "TwitterAuth"
  """
  insert_TwitterAuth(
    """the rows to be inserted"""
    objects: [TwitterAuth_insert_input!]!

    """upsert condition"""
    on_conflict: TwitterAuth_on_conflict
  ): TwitterAuth_mutation_response

  """
  insert a single row into the table: "TwitterAuth"
  """
  insert_TwitterAuth_one(
    """the row to be inserted"""
    object: TwitterAuth_insert_input!

    """upsert condition"""
    on_conflict: TwitterAuth_on_conflict
  ): TwitterAuth

  """
  insert data into the table: "Unlockable"
  """
  insert_Unlockable(
    """the rows to be inserted"""
    objects: [Unlockable_insert_input!]!

    """upsert condition"""
    on_conflict: Unlockable_on_conflict
  ): Unlockable_mutation_response

  """
  insert data into the table: "UnlockableWinner"
  """
  insert_UnlockableWinner(
    """the rows to be inserted"""
    objects: [UnlockableWinner_insert_input!]!

    """upsert condition"""
    on_conflict: UnlockableWinner_on_conflict
  ): UnlockableWinner_mutation_response

  """
  insert a single row into the table: "UnlockableWinner"
  """
  insert_UnlockableWinner_one(
    """the row to be inserted"""
    object: UnlockableWinner_insert_input!

    """upsert condition"""
    on_conflict: UnlockableWinner_on_conflict
  ): UnlockableWinner

  """
  insert a single row into the table: "Unlockable"
  """
  insert_Unlockable_one(
    """the row to be inserted"""
    object: Unlockable_insert_input!

    """upsert condition"""
    on_conflict: Unlockable_on_conflict
  ): Unlockable

  """
  insert data into the table: "User"
  """
  insert_User(
    """the rows to be inserted"""
    objects: [User_insert_input!]!

    """upsert condition"""
    on_conflict: User_on_conflict
  ): User_mutation_response

  """
  insert data into the table: "UserFollows"
  """
  insert_UserFollows(
    """the rows to be inserted"""
    objects: [UserFollows_insert_input!]!

    """upsert condition"""
    on_conflict: UserFollows_on_conflict
  ): UserFollows_mutation_response

  """
  insert a single row into the table: "UserFollows"
  """
  insert_UserFollows_one(
    """the row to be inserted"""
    object: UserFollows_insert_input!

    """upsert condition"""
    on_conflict: UserFollows_on_conflict
  ): UserFollows

  """
  insert a single row into the table: "User"
  """
  insert_User_one(
    """the row to be inserted"""
    object: User_insert_input!

    """upsert condition"""
    on_conflict: User_on_conflict
  ): User

  """
  insert data into the table: "Video"
  """
  insert_Video(
    """the rows to be inserted"""
    objects: [Video_insert_input!]!

    """upsert condition"""
    on_conflict: Video_on_conflict
  ): Video_mutation_response

  """
  insert a single row into the table: "Video"
  """
  insert_Video_one(
    """the row to be inserted"""
    object: Video_insert_input!

    """upsert condition"""
    on_conflict: Video_on_conflict
  ): Video

  """
  insert data into the table: "Vote"
  """
  insert_Vote(
    """the rows to be inserted"""
    objects: [Vote_insert_input!]!

    """upsert condition"""
    on_conflict: Vote_on_conflict
  ): Vote_mutation_response

  """
  insert data into the table: "VoteReason"
  """
  insert_VoteReason(
    """the rows to be inserted"""
    objects: [VoteReason_insert_input!]!

    """upsert condition"""
    on_conflict: VoteReason_on_conflict
  ): VoteReason_mutation_response

  """
  insert a single row into the table: "VoteReason"
  """
  insert_VoteReason_one(
    """the row to be inserted"""
    object: VoteReason_insert_input!

    """upsert condition"""
    on_conflict: VoteReason_on_conflict
  ): VoteReason

  """
  insert data into the table: "VoteType"
  """
  insert_VoteType(
    """the rows to be inserted"""
    objects: [VoteType_insert_input!]!

    """upsert condition"""
    on_conflict: VoteType_on_conflict
  ): VoteType_mutation_response

  """
  insert a single row into the table: "VoteType"
  """
  insert_VoteType_one(
    """the row to be inserted"""
    object: VoteType_insert_input!

    """upsert condition"""
    on_conflict: VoteType_on_conflict
  ): VoteType

  """
  insert a single row into the table: "Vote"
  """
  insert_Vote_one(
    """the row to be inserted"""
    object: Vote_insert_input!

    """upsert condition"""
    on_conflict: Vote_on_conflict
  ): Vote

  """
  insert data into the table: "Whitelist"
  """
  insert_Whitelist(
    """the rows to be inserted"""
    objects: [Whitelist_insert_input!]!

    """upsert condition"""
    on_conflict: Whitelist_on_conflict
  ): Whitelist_mutation_response

  """
  insert a single row into the table: "Whitelist"
  """
  insert_Whitelist_one(
    """the row to be inserted"""
    object: Whitelist_insert_input!

    """upsert condition"""
    on_conflict: Whitelist_on_conflict
  ): Whitelist

  """
  insert data into the table: "top_collector_stats"
  """
  insert_top_collector_stats(
    """the rows to be inserted"""
    objects: [top_collector_stats_insert_input!]!
  ): top_collector_stats_mutation_response

  """
  insert a single row into the table: "top_collector_stats"
  """
  insert_top_collector_stats_one(
    """the row to be inserted"""
    object: top_collector_stats_insert_input!
  ): top_collector_stats

  """
  insert data into the table: "top_creator_stats"
  """
  insert_top_creator_stats(
    """the rows to be inserted"""
    objects: [top_creator_stats_insert_input!]!
  ): top_creator_stats_mutation_response

  """
  insert a single row into the table: "top_creator_stats"
  """
  insert_top_creator_stats_one(
    """the row to be inserted"""
    object: top_creator_stats_insert_input!
  ): top_creator_stats

  """
  update data of the table: "ActivityNotification"
  """
  update_ActivityNotification(
    """sets the columns of the filtered rows to the given values"""
    _set: ActivityNotification_set_input

    """filter the rows which have to be updated"""
    where: ActivityNotification_bool_exp!
  ): ActivityNotification_mutation_response

  """
  update single row of the table: "ActivityNotification"
  """
  update_ActivityNotification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ActivityNotification_set_input
    pk_columns: ActivityNotification_pk_columns_input!
  ): ActivityNotification

  """
  update data of the table: "Airdrop"
  """
  update_Airdrop(
    """sets the columns of the filtered rows to the given values"""
    _set: Airdrop_set_input

    """filter the rows which have to be updated"""
    where: Airdrop_bool_exp!
  ): Airdrop_mutation_response

  """
  update data of the table: "AirdropType"
  """
  update_AirdropType(
    """sets the columns of the filtered rows to the given values"""
    _set: AirdropType_set_input

    """filter the rows which have to be updated"""
    where: AirdropType_bool_exp!
  ): AirdropType_mutation_response

  """
  update single row of the table: "AirdropType"
  """
  update_AirdropType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: AirdropType_set_input
    pk_columns: AirdropType_pk_columns_input!
  ): AirdropType

  """
  update single row of the table: "Airdrop"
  """
  update_Airdrop_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Airdrop_set_input
    pk_columns: Airdrop_pk_columns_input!
  ): Airdrop

  """
  update data of the table: "ArtistSubmission"
  """
  update_ArtistSubmission(
    """sets the columns of the filtered rows to the given values"""
    _set: ArtistSubmission_set_input

    """filter the rows which have to be updated"""
    where: ArtistSubmission_bool_exp!
  ): ArtistSubmission_mutation_response

  """
  update data of the table: "ArtistSubmissionStatus"
  """
  update_ArtistSubmissionStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: ArtistSubmissionStatus_set_input

    """filter the rows which have to be updated"""
    where: ArtistSubmissionStatus_bool_exp!
  ): ArtistSubmissionStatus_mutation_response

  """
  update single row of the table: "ArtistSubmissionStatus"
  """
  update_ArtistSubmissionStatus_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ArtistSubmissionStatus_set_input
    pk_columns: ArtistSubmissionStatus_pk_columns_input!
  ): ArtistSubmissionStatus

  """
  update single row of the table: "ArtistSubmission"
  """
  update_ArtistSubmission_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ArtistSubmission_set_input
    pk_columns: ArtistSubmission_pk_columns_input!
  ): ArtistSubmission

  """
  update data of the table: "Asset"
  """
  update_Asset(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Asset_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Asset_set_input

    """filter the rows which have to be updated"""
    where: Asset_bool_exp!
  ): Asset_mutation_response

  """
  update single row of the table: "Asset"
  """
  update_Asset_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Asset_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Asset_set_input
    pk_columns: Asset_pk_columns_input!
  ): Asset

  """
  update data of the table: "Attribute"
  """
  update_Attribute(
    """sets the columns of the filtered rows to the given values"""
    _set: Attribute_set_input

    """filter the rows which have to be updated"""
    where: Attribute_bool_exp!
  ): Attribute_mutation_response

  """
  update single row of the table: "Attribute"
  """
  update_Attribute_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Attribute_set_input
    pk_columns: Attribute_pk_columns_input!
  ): Attribute

  """
  update data of the table: "BonkClaim"
  """
  update_BonkClaim(
    """sets the columns of the filtered rows to the given values"""
    _set: BonkClaim_set_input

    """filter the rows which have to be updated"""
    where: BonkClaim_bool_exp!
  ): BonkClaim_mutation_response

  """
  update single row of the table: "BonkClaim"
  """
  update_BonkClaim_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: BonkClaim_set_input
    pk_columns: BonkClaim_pk_columns_input!
  ): BonkClaim

  """
  update data of the table: "Campaign"
  """
  update_Campaign(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Campaign_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Campaign_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Campaign_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Campaign_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: Campaign_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Campaign_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Campaign_set_input

    """filter the rows which have to be updated"""
    where: Campaign_bool_exp!
  ): Campaign_mutation_response

  """
  update data of the table: "CampaignBenefit"
  """
  update_CampaignBenefit(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignBenefit_set_input

    """filter the rows which have to be updated"""
    where: CampaignBenefit_bool_exp!
  ): CampaignBenefit_mutation_response

  """
  update data of the table: "CampaignBenefitStatus"
  """
  update_CampaignBenefitStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignBenefitStatus_set_input

    """filter the rows which have to be updated"""
    where: CampaignBenefitStatus_bool_exp!
  ): CampaignBenefitStatus_mutation_response

  """
  update single row of the table: "CampaignBenefitStatus"
  """
  update_CampaignBenefitStatus_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignBenefitStatus_set_input
    pk_columns: CampaignBenefitStatus_pk_columns_input!
  ): CampaignBenefitStatus

  """
  update data of the table: "CampaignBenefitToNft"
  """
  update_CampaignBenefitToNft(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignBenefitToNft_set_input

    """filter the rows which have to be updated"""
    where: CampaignBenefitToNft_bool_exp!
  ): CampaignBenefitToNft_mutation_response

  """
  update single row of the table: "CampaignBenefitToNft"
  """
  update_CampaignBenefitToNft_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignBenefitToNft_set_input
    pk_columns: CampaignBenefitToNft_pk_columns_input!
  ): CampaignBenefitToNft

  """
  update single row of the table: "CampaignBenefit"
  """
  update_CampaignBenefit_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignBenefit_set_input
    pk_columns: CampaignBenefit_pk_columns_input!
  ): CampaignBenefit

  """
  update data of the table: "CampaignCategory"
  """
  update_CampaignCategory(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignCategory_set_input

    """filter the rows which have to be updated"""
    where: CampaignCategory_bool_exp!
  ): CampaignCategory_mutation_response

  """
  update single row of the table: "CampaignCategory"
  """
  update_CampaignCategory_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignCategory_set_input
    pk_columns: CampaignCategory_pk_columns_input!
  ): CampaignCategory

  """
  update data of the table: "CampaignColorScheme"
  """
  update_CampaignColorScheme(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignColorScheme_set_input

    """filter the rows which have to be updated"""
    where: CampaignColorScheme_bool_exp!
  ): CampaignColorScheme_mutation_response

  """
  update single row of the table: "CampaignColorScheme"
  """
  update_CampaignColorScheme_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignColorScheme_set_input
    pk_columns: CampaignColorScheme_pk_columns_input!
  ): CampaignColorScheme

  """
  update data of the table: "CampaignFundingTier"
  """
  update_CampaignFundingTier(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CampaignFundingTier_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: CampaignFundingTier_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: CampaignFundingTier_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: CampaignFundingTier_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CampaignFundingTier_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: CampaignFundingTier_set_input

    """filter the rows which have to be updated"""
    where: CampaignFundingTier_bool_exp!
  ): CampaignFundingTier_mutation_response

  """
  update data of the table: "CampaignFundingTierType"
  """
  update_CampaignFundingTierType(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignFundingTierType_set_input

    """filter the rows which have to be updated"""
    where: CampaignFundingTierType_bool_exp!
  ): CampaignFundingTierType_mutation_response

  """
  update single row of the table: "CampaignFundingTierType"
  """
  update_CampaignFundingTierType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignFundingTierType_set_input
    pk_columns: CampaignFundingTierType_pk_columns_input!
  ): CampaignFundingTierType

  """
  update single row of the table: "CampaignFundingTier"
  """
  update_CampaignFundingTier_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CampaignFundingTier_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: CampaignFundingTier_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: CampaignFundingTier_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: CampaignFundingTier_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CampaignFundingTier_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: CampaignFundingTier_set_input
    pk_columns: CampaignFundingTier_pk_columns_input!
  ): CampaignFundingTier

  """
  update data of the table: "CampaignGoalType"
  """
  update_CampaignGoalType(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignGoalType_set_input

    """filter the rows which have to be updated"""
    where: CampaignGoalType_bool_exp!
  ): CampaignGoalType_mutation_response

  """
  update single row of the table: "CampaignGoalType"
  """
  update_CampaignGoalType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignGoalType_set_input
    pk_columns: CampaignGoalType_pk_columns_input!
  ): CampaignGoalType

  """
  update data of the table: "CampaignStatus"
  """
  update_CampaignStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignStatus_set_input

    """filter the rows which have to be updated"""
    where: CampaignStatus_bool_exp!
  ): CampaignStatus_mutation_response

  """
  update single row of the table: "CampaignStatus"
  """
  update_CampaignStatus_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignStatus_set_input
    pk_columns: CampaignStatus_pk_columns_input!
  ): CampaignStatus

  """
  update data of the table: "CampaignTeamMemberRole"
  """
  update_CampaignTeamMemberRole(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignTeamMemberRole_set_input

    """filter the rows which have to be updated"""
    where: CampaignTeamMemberRole_bool_exp!
  ): CampaignTeamMemberRole_mutation_response

  """
  update single row of the table: "CampaignTeamMemberRole"
  """
  update_CampaignTeamMemberRole_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignTeamMemberRole_set_input
    pk_columns: CampaignTeamMemberRole_pk_columns_input!
  ): CampaignTeamMemberRole

  """
  update data of the table: "CampaignToCollaborator"
  """
  update_CampaignToCollaborator(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignToCollaborator_set_input

    """filter the rows which have to be updated"""
    where: CampaignToCollaborator_bool_exp!
  ): CampaignToCollaborator_mutation_response

  """
  update single row of the table: "CampaignToCollaborator"
  """
  update_CampaignToCollaborator_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignToCollaborator_set_input
    pk_columns: CampaignToCollaborator_pk_columns_input!
  ): CampaignToCollaborator

  """
  update data of the table: "CampaignToHolder"
  """
  update_CampaignToHolder(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignToHolder_set_input

    """filter the rows which have to be updated"""
    where: CampaignToHolder_bool_exp!
  ): CampaignToHolder_mutation_response

  """
  update single row of the table: "CampaignToHolder"
  """
  update_CampaignToHolder_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignToHolder_set_input
    pk_columns: CampaignToHolder_pk_columns_input!
  ): CampaignToHolder

  """
  update data of the table: "CampaignToTeamMember"
  """
  update_CampaignToTeamMember(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignToTeamMember_set_input

    """filter the rows which have to be updated"""
    where: CampaignToTeamMember_bool_exp!
  ): CampaignToTeamMember_mutation_response

  """
  update single row of the table: "CampaignToTeamMember"
  """
  update_CampaignToTeamMember_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CampaignToTeamMember_set_input
    pk_columns: CampaignToTeamMember_pk_columns_input!
  ): CampaignToTeamMember

  """
  update single row of the table: "Campaign"
  """
  update_Campaign_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Campaign_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Campaign_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Campaign_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Campaign_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: Campaign_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Campaign_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Campaign_set_input
    pk_columns: Campaign_pk_columns_input!
  ): Campaign

  """
  update data of the table: "CandyMachine"
  """
  update_CandyMachine(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CandyMachine_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: CandyMachine_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: CandyMachine_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: CandyMachine_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: CandyMachine_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CandyMachine_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: CandyMachine_set_input

    """filter the rows which have to be updated"""
    where: CandyMachine_bool_exp!
  ): CandyMachine_mutation_response

  """
  update data of the table: "CandyMachineMerkleAllowlistInfo"
  """
  update_CandyMachineMerkleAllowlistInfo(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CandyMachineMerkleAllowlistInfo_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: CandyMachineMerkleAllowlistInfo_set_input

    """filter the rows which have to be updated"""
    where: CandyMachineMerkleAllowlistInfo_bool_exp!
  ): CandyMachineMerkleAllowlistInfo_mutation_response

  """
  update single row of the table: "CandyMachineMerkleAllowlistInfo"
  """
  update_CandyMachineMerkleAllowlistInfo_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CandyMachineMerkleAllowlistInfo_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: CandyMachineMerkleAllowlistInfo_set_input
    pk_columns: CandyMachineMerkleAllowlistInfo_pk_columns_input!
  ): CandyMachineMerkleAllowlistInfo

  """
  update single row of the table: "CandyMachine"
  """
  update_CandyMachine_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CandyMachine_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: CandyMachine_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: CandyMachine_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: CandyMachine_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: CandyMachine_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CandyMachine_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: CandyMachine_set_input
    pk_columns: CandyMachine_pk_columns_input!
  ): CandyMachine

  """
  update data of the table: "Claim"
  """
  update_Claim(
    """sets the columns of the filtered rows to the given values"""
    _set: Claim_set_input

    """filter the rows which have to be updated"""
    where: Claim_bool_exp!
  ): Claim_mutation_response

  """
  update single row of the table: "Claim"
  """
  update_Claim_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Claim_set_input
    pk_columns: Claim_pk_columns_input!
  ): Claim

  """
  update data of the table: "CollectorSurvey"
  """
  update_CollectorSurvey(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CollectorSurvey_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: CollectorSurvey_set_input

    """filter the rows which have to be updated"""
    where: CollectorSurvey_bool_exp!
  ): CollectorSurvey_mutation_response

  """
  update single row of the table: "CollectorSurvey"
  """
  update_CollectorSurvey_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CollectorSurvey_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: CollectorSurvey_set_input
    pk_columns: CollectorSurvey_pk_columns_input!
  ): CollectorSurvey

  """
  update data of the table: "Comment"
  """
  update_Comment(
    """sets the columns of the filtered rows to the given values"""
    _set: Comment_set_input

    """filter the rows which have to be updated"""
    where: Comment_bool_exp!
  ): Comment_mutation_response

  """
  update single row of the table: "Comment"
  """
  update_Comment_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Comment_set_input
    pk_columns: Comment_pk_columns_input!
  ): Comment

  """
  update data of the table: "CreatorInvite"
  """
  update_CreatorInvite(
    """sets the columns of the filtered rows to the given values"""
    _set: CreatorInvite_set_input

    """filter the rows which have to be updated"""
    where: CreatorInvite_bool_exp!
  ): CreatorInvite_mutation_response

  """
  update data of the table: "CreatorInviteIssueReason"
  """
  update_CreatorInviteIssueReason(
    """sets the columns of the filtered rows to the given values"""
    _set: CreatorInviteIssueReason_set_input

    """filter the rows which have to be updated"""
    where: CreatorInviteIssueReason_bool_exp!
  ): CreatorInviteIssueReason_mutation_response

  """
  update single row of the table: "CreatorInviteIssueReason"
  """
  update_CreatorInviteIssueReason_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CreatorInviteIssueReason_set_input
    pk_columns: CreatorInviteIssueReason_pk_columns_input!
  ): CreatorInviteIssueReason

  """
  update single row of the table: "CreatorInvite"
  """
  update_CreatorInvite_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CreatorInvite_set_input
    pk_columns: CreatorInvite_pk_columns_input!
  ): CreatorInvite

  """
  update data of the table: "CreatorStory"
  """
  update_CreatorStory(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CreatorStory_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: CreatorStory_set_input

    """filter the rows which have to be updated"""
    where: CreatorStory_bool_exp!
  ): CreatorStory_mutation_response

  """
  update single row of the table: "CreatorStory"
  """
  update_CreatorStory_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CreatorStory_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: CreatorStory_set_input
    pk_columns: CreatorStory_pk_columns_input!
  ): CreatorStory

  """
  update data of the table: "CreatorSurvey"
  """
  update_CreatorSurvey(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CreatorSurvey_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: CreatorSurvey_set_input

    """filter the rows which have to be updated"""
    where: CreatorSurvey_bool_exp!
  ): CreatorSurvey_mutation_response

  """
  update single row of the table: "CreatorSurvey"
  """
  update_CreatorSurvey_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CreatorSurvey_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: CreatorSurvey_set_input
    pk_columns: CreatorSurvey_pk_columns_input!
  ): CreatorSurvey

  """
  update data of the table: "Currency"
  """
  update_Currency(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Currency_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Currency_set_input

    """filter the rows which have to be updated"""
    where: Currency_bool_exp!
  ): Currency_mutation_response

  """
  update data of the table: "CurrencyName"
  """
  update_CurrencyName(
    """sets the columns of the filtered rows to the given values"""
    _set: CurrencyName_set_input

    """filter the rows which have to be updated"""
    where: CurrencyName_bool_exp!
  ): CurrencyName_mutation_response

  """
  update single row of the table: "CurrencyName"
  """
  update_CurrencyName_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: CurrencyName_set_input
    pk_columns: CurrencyName_pk_columns_input!
  ): CurrencyName

  """
  update single row of the table: "Currency"
  """
  update_Currency_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Currency_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Currency_set_input
    pk_columns: Currency_pk_columns_input!
  ): Currency

  """
  update data of the table: "DeletedNftTransaction"
  """
  update_DeletedNftTransaction(
    """sets the columns of the filtered rows to the given values"""
    _set: DeletedNftTransaction_set_input

    """filter the rows which have to be updated"""
    where: DeletedNftTransaction_bool_exp!
  ): DeletedNftTransaction_mutation_response

  """
  update single row of the table: "DeletedNftTransaction"
  """
  update_DeletedNftTransaction_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: DeletedNftTransaction_set_input
    pk_columns: DeletedNftTransaction_pk_columns_input!
  ): DeletedNftTransaction

  """
  update data of the table: "Dev"
  """
  update_Dev(
    """sets the columns of the filtered rows to the given values"""
    _set: Dev_set_input

    """filter the rows which have to be updated"""
    where: Dev_bool_exp!
  ): Dev_mutation_response

  """
  update single row of the table: "Dev"
  """
  update_Dev_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Dev_set_input
    pk_columns: Dev_pk_columns_input!
  ): Dev

  """
  update data of the table: "DiscordAuth"
  """
  update_DiscordAuth(
    """sets the columns of the filtered rows to the given values"""
    _set: DiscordAuth_set_input

    """filter the rows which have to be updated"""
    where: DiscordAuth_bool_exp!
  ): DiscordAuth_mutation_response

  """
  update data of the table: "DiscordAuthToDiscordRole"
  """
  update_DiscordAuthToDiscordRole(
    """sets the columns of the filtered rows to the given values"""
    _set: DiscordAuthToDiscordRole_set_input

    """filter the rows which have to be updated"""
    where: DiscordAuthToDiscordRole_bool_exp!
  ): DiscordAuthToDiscordRole_mutation_response

  """
  update single row of the table: "DiscordAuthToDiscordRole"
  """
  update_DiscordAuthToDiscordRole_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: DiscordAuthToDiscordRole_set_input
    pk_columns: DiscordAuthToDiscordRole_pk_columns_input!
  ): DiscordAuthToDiscordRole

  """
  update single row of the table: "DiscordAuth"
  """
  update_DiscordAuth_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: DiscordAuth_set_input
    pk_columns: DiscordAuth_pk_columns_input!
  ): DiscordAuth

  """
  update data of the table: "DiscordRole"
  """
  update_DiscordRole(
    """sets the columns of the filtered rows to the given values"""
    _set: DiscordRole_set_input

    """filter the rows which have to be updated"""
    where: DiscordRole_bool_exp!
  ): DiscordRole_mutation_response

  """
  update single row of the table: "DiscordRole"
  """
  update_DiscordRole_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: DiscordRole_set_input
    pk_columns: DiscordRole_pk_columns_input!
  ): DiscordRole

  """
  update data of the table: "EditionsMerkleAllowlistInfo"
  """
  update_EditionsMerkleAllowlistInfo(
    """increments the numeric columns with given value of the filtered values"""
    _inc: EditionsMerkleAllowlistInfo_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: EditionsMerkleAllowlistInfo_set_input

    """filter the rows which have to be updated"""
    where: EditionsMerkleAllowlistInfo_bool_exp!
  ): EditionsMerkleAllowlistInfo_mutation_response

  """
  update single row of the table: "EditionsMerkleAllowlistInfo"
  """
  update_EditionsMerkleAllowlistInfo_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: EditionsMerkleAllowlistInfo_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: EditionsMerkleAllowlistInfo_set_input
    pk_columns: EditionsMerkleAllowlistInfo_pk_columns_input!
  ): EditionsMerkleAllowlistInfo

  """
  update data of the table: "ExchangeRates"
  """
  update_ExchangeRates(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ExchangeRates_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ExchangeRates_set_input

    """filter the rows which have to be updated"""
    where: ExchangeRates_bool_exp!
  ): ExchangeRates_mutation_response

  """
  update single row of the table: "ExchangeRates"
  """
  update_ExchangeRates_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ExchangeRates_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ExchangeRates_set_input
    pk_columns: ExchangeRates_pk_columns_input!
  ): ExchangeRates

  """
  update data of the table: "InstagramAuth"
  """
  update_InstagramAuth(
    """sets the columns of the filtered rows to the given values"""
    _set: InstagramAuth_set_input

    """filter the rows which have to be updated"""
    where: InstagramAuth_bool_exp!
  ): InstagramAuth_mutation_response

  """
  update single row of the table: "InstagramAuth"
  """
  update_InstagramAuth_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: InstagramAuth_set_input
    pk_columns: InstagramAuth_pk_columns_input!
  ): InstagramAuth

  """
  update data of the table: "Nft"
  """
  update_Nft(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Nft_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Nft_set_input

    """filter the rows which have to be updated"""
    where: Nft_bool_exp!
  ): Nft_mutation_response

  """
  update data of the table: "NftDisclosure"
  """
  update_NftDisclosure(
    """sets the columns of the filtered rows to the given values"""
    _set: NftDisclosure_set_input

    """filter the rows which have to be updated"""
    where: NftDisclosure_bool_exp!
  ): NftDisclosure_mutation_response

  """
  update data of the table: "NftDisclosureType"
  """
  update_NftDisclosureType(
    """sets the columns of the filtered rows to the given values"""
    _set: NftDisclosureType_set_input

    """filter the rows which have to be updated"""
    where: NftDisclosureType_bool_exp!
  ): NftDisclosureType_mutation_response

  """
  update single row of the table: "NftDisclosureType"
  """
  update_NftDisclosureType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NftDisclosureType_set_input
    pk_columns: NftDisclosureType_pk_columns_input!
  ): NftDisclosureType

  """
  update single row of the table: "NftDisclosure"
  """
  update_NftDisclosure_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NftDisclosure_set_input
    pk_columns: NftDisclosure_pk_columns_input!
  ): NftDisclosure

  """
  update data of the table: "NftListing"
  """
  update_NftListing(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: NftListing_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: NftListing_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: NftListing_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: NftListing_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: NftListing_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: NftListing_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftListing_set_input

    """filter the rows which have to be updated"""
    where: NftListing_bool_exp!
  ): NftListing_mutation_response

  """
  update single row of the table: "NftListing"
  """
  update_NftListing_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: NftListing_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: NftListing_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: NftListing_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: NftListing_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: NftListing_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: NftListing_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftListing_set_input
    pk_columns: NftListing_pk_columns_input!
  ): NftListing

  """
  update data of the table: "NftMetadata"
  """
  update_NftMetadata(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: NftMetadata_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: NftMetadata_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: NftMetadata_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: NftMetadata_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: NftMetadata_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: NftMetadata_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftMetadata_set_input

    """filter the rows which have to be updated"""
    where: NftMetadata_bool_exp!
  ): NftMetadata_mutation_response

  """
  update single row of the table: "NftMetadata"
  """
  update_NftMetadata_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: NftMetadata_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: NftMetadata_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: NftMetadata_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: NftMetadata_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: NftMetadata_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: NftMetadata_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftMetadata_set_input
    pk_columns: NftMetadata_pk_columns_input!
  ): NftMetadata

  """
  update data of the table: "NftStatus"
  """
  update_NftStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: NftStatus_set_input

    """filter the rows which have to be updated"""
    where: NftStatus_bool_exp!
  ): NftStatus_mutation_response

  """
  update single row of the table: "NftStatus"
  """
  update_NftStatus_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NftStatus_set_input
    pk_columns: NftStatus_pk_columns_input!
  ): NftStatus

  """
  update data of the table: "NftToAttribute"
  """
  update_NftToAttribute(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NftToAttribute_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftToAttribute_set_input

    """filter the rows which have to be updated"""
    where: NftToAttribute_bool_exp!
  ): NftToAttribute_mutation_response

  """
  update single row of the table: "NftToAttribute"
  """
  update_NftToAttribute_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NftToAttribute_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftToAttribute_set_input
    pk_columns: NftToAttribute_pk_columns_input!
  ): NftToAttribute

  """
  update data of the table: "NftToCollaborator"
  """
  update_NftToCollaborator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NftToCollaborator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftToCollaborator_set_input

    """filter the rows which have to be updated"""
    where: NftToCollaborator_bool_exp!
  ): NftToCollaborator_mutation_response

  """
  update single row of the table: "NftToCollaborator"
  """
  update_NftToCollaborator_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NftToCollaborator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftToCollaborator_set_input
    pk_columns: NftToCollaborator_pk_columns_input!
  ): NftToCollaborator

  """
  update data of the table: "NftToTag"
  """
  update_NftToTag(
    """sets the columns of the filtered rows to the given values"""
    _set: NftToTag_set_input

    """filter the rows which have to be updated"""
    where: NftToTag_bool_exp!
  ): NftToTag_mutation_response

  """
  update single row of the table: "NftToTag"
  """
  update_NftToTag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NftToTag_set_input
    pk_columns: NftToTag_pk_columns_input!
  ): NftToTag

  """
  update data of the table: "NftTransaction"
  """
  update_NftTransaction(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NftTransaction_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftTransaction_set_input

    """filter the rows which have to be updated"""
    where: NftTransaction_bool_exp!
  ): NftTransaction_mutation_response

  """
  update data of the table: "NftTransactionRaw"
  """
  update_NftTransactionRaw(
    """sets the columns of the filtered rows to the given values"""
    _set: NftTransactionRaw_set_input

    """filter the rows which have to be updated"""
    where: NftTransactionRaw_bool_exp!
  ): NftTransactionRaw_mutation_response

  """
  update single row of the table: "NftTransactionRaw"
  """
  update_NftTransactionRaw_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NftTransactionRaw_set_input
    pk_columns: NftTransactionRaw_pk_columns_input!
  ): NftTransactionRaw

  """
  update data of the table: "NftTransactionSource"
  """
  update_NftTransactionSource(
    """sets the columns of the filtered rows to the given values"""
    _set: NftTransactionSource_set_input

    """filter the rows which have to be updated"""
    where: NftTransactionSource_bool_exp!
  ): NftTransactionSource_mutation_response

  """
  update single row of the table: "NftTransactionSource"
  """
  update_NftTransactionSource_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NftTransactionSource_set_input
    pk_columns: NftTransactionSource_pk_columns_input!
  ): NftTransactionSource

  """
  update data of the table: "NftTransactionType"
  """
  update_NftTransactionType(
    """sets the columns of the filtered rows to the given values"""
    _set: NftTransactionType_set_input

    """filter the rows which have to be updated"""
    where: NftTransactionType_bool_exp!
  ): NftTransactionType_mutation_response

  """
  update single row of the table: "NftTransactionType"
  """
  update_NftTransactionType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NftTransactionType_set_input
    pk_columns: NftTransactionType_pk_columns_input!
  ): NftTransactionType

  """
  update single row of the table: "NftTransaction"
  """
  update_NftTransaction_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NftTransaction_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: NftTransaction_set_input
    pk_columns: NftTransaction_pk_columns_input!
  ): NftTransaction

  """
  update single row of the table: "Nft"
  """
  update_Nft_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Nft_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Nft_set_input
    pk_columns: Nft_pk_columns_input!
  ): Nft

  """
  update data of the table: "Notification"
  """
  update_Notification(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Notification_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Notification_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Notification_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Notification_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Notification_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Notification_set_input

    """filter the rows which have to be updated"""
    where: Notification_bool_exp!
  ): Notification_mutation_response

  """
  update data of the table: "NotificationChannel"
  """
  update_NotificationChannel(
    """sets the columns of the filtered rows to the given values"""
    _set: NotificationChannel_set_input

    """filter the rows which have to be updated"""
    where: NotificationChannel_bool_exp!
  ): NotificationChannel_mutation_response

  """
  update single row of the table: "NotificationChannel"
  """
  update_NotificationChannel_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NotificationChannel_set_input
    pk_columns: NotificationChannel_pk_columns_input!
  ): NotificationChannel

  """
  update data of the table: "NotificationType"
  """
  update_NotificationType(
    """sets the columns of the filtered rows to the given values"""
    _set: NotificationType_set_input

    """filter the rows which have to be updated"""
    where: NotificationType_bool_exp!
  ): NotificationType_mutation_response

  """
  update single row of the table: "NotificationType"
  """
  update_NotificationType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NotificationType_set_input
    pk_columns: NotificationType_pk_columns_input!
  ): NotificationType

  """
  update data of the table: "NotificationUserPreference"
  """
  update_NotificationUserPreference(
    """sets the columns of the filtered rows to the given values"""
    _set: NotificationUserPreference_set_input

    """filter the rows which have to be updated"""
    where: NotificationUserPreference_bool_exp!
  ): NotificationUserPreference_mutation_response

  """
  update single row of the table: "NotificationUserPreference"
  """
  update_NotificationUserPreference_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: NotificationUserPreference_set_input
    pk_columns: NotificationUserPreference_pk_columns_input!
  ): NotificationUserPreference

  """
  update single row of the table: "Notification"
  """
  update_Notification_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Notification_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Notification_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Notification_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Notification_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Notification_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Notification_set_input
    pk_columns: Notification_pk_columns_input!
  ): Notification

  """
  update data of the table: "Offer"
  """
  update_Offer(
    """sets the columns of the filtered rows to the given values"""
    _set: Offer_set_input

    """filter the rows which have to be updated"""
    where: Offer_bool_exp!
  ): Offer_mutation_response

  """
  update single row of the table: "Offer"
  """
  update_Offer_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Offer_set_input
    pk_columns: Offer_pk_columns_input!
  ): Offer

  """
  update data of the table: "Photo"
  """
  update_Photo(
    """sets the columns of the filtered rows to the given values"""
    _set: Photo_set_input

    """filter the rows which have to be updated"""
    where: Photo_bool_exp!
  ): Photo_mutation_response

  """
  update single row of the table: "Photo"
  """
  update_Photo_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Photo_set_input
    pk_columns: Photo_pk_columns_input!
  ): Photo

  """
  update data of the table: "Poll"
  """
  update_Poll(
    """sets the columns of the filtered rows to the given values"""
    _set: Poll_set_input

    """filter the rows which have to be updated"""
    where: Poll_bool_exp!
  ): Poll_mutation_response

  """
  update data of the table: "PollOption"
  """
  update_PollOption(
    """sets the columns of the filtered rows to the given values"""
    _set: PollOption_set_input

    """filter the rows which have to be updated"""
    where: PollOption_bool_exp!
  ): PollOption_mutation_response

  """
  update single row of the table: "PollOption"
  """
  update_PollOption_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: PollOption_set_input
    pk_columns: PollOption_pk_columns_input!
  ): PollOption

  """
  update data of the table: "PollResponse"
  """
  update_PollResponse(
    """sets the columns of the filtered rows to the given values"""
    _set: PollResponse_set_input

    """filter the rows which have to be updated"""
    where: PollResponse_bool_exp!
  ): PollResponse_mutation_response

  """
  update single row of the table: "PollResponse"
  """
  update_PollResponse_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: PollResponse_set_input
    pk_columns: PollResponse_pk_columns_input!
  ): PollResponse

  """
  update single row of the table: "Poll"
  """
  update_Poll_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Poll_set_input
    pk_columns: Poll_pk_columns_input!
  ): Poll

  """
  update data of the table: "Post"
  """
  update_Post(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Post_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Post_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Post_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Post_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Post_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Post_set_input

    """filter the rows which have to be updated"""
    where: Post_bool_exp!
  ): Post_mutation_response

  """
  update data of the table: "PostVisibility"
  """
  update_PostVisibility(
    """sets the columns of the filtered rows to the given values"""
    _set: PostVisibility_set_input

    """filter the rows which have to be updated"""
    where: PostVisibility_bool_exp!
  ): PostVisibility_mutation_response

  """
  update single row of the table: "PostVisibility"
  """
  update_PostVisibility_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: PostVisibility_set_input
    pk_columns: PostVisibility_pk_columns_input!
  ): PostVisibility

  """
  update single row of the table: "Post"
  """
  update_Post_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Post_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Post_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Post_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Post_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Post_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Post_set_input
    pk_columns: Post_pk_columns_input!
  ): Post

  """
  update data of the table: "PriceFunctionType"
  """
  update_PriceFunctionType(
    """sets the columns of the filtered rows to the given values"""
    _set: PriceFunctionType_set_input

    """filter the rows which have to be updated"""
    where: PriceFunctionType_bool_exp!
  ): PriceFunctionType_mutation_response

  """
  update single row of the table: "PriceFunctionType"
  """
  update_PriceFunctionType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: PriceFunctionType_set_input
    pk_columns: PriceFunctionType_pk_columns_input!
  ): PriceFunctionType

  """
  update data of the table: "Reaction"
  """
  update_Reaction(
    """sets the columns of the filtered rows to the given values"""
    _set: Reaction_set_input

    """filter the rows which have to be updated"""
    where: Reaction_bool_exp!
  ): Reaction_mutation_response

  """
  update data of the table: "ReactionType"
  """
  update_ReactionType(
    """sets the columns of the filtered rows to the given values"""
    _set: ReactionType_set_input

    """filter the rows which have to be updated"""
    where: ReactionType_bool_exp!
  ): ReactionType_mutation_response

  """
  update single row of the table: "ReactionType"
  """
  update_ReactionType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ReactionType_set_input
    pk_columns: ReactionType_pk_columns_input!
  ): ReactionType

  """
  update single row of the table: "Reaction"
  """
  update_Reaction_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Reaction_set_input
    pk_columns: Reaction_pk_columns_input!
  ): Reaction

  """
  update data of the table: "Request"
  """
  update_Request(
    """sets the columns of the filtered rows to the given values"""
    _set: Request_set_input

    """filter the rows which have to be updated"""
    where: Request_bool_exp!
  ): Request_mutation_response

  """
  update data of the table: "RequestStatus"
  """
  update_RequestStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: RequestStatus_set_input

    """filter the rows which have to be updated"""
    where: RequestStatus_bool_exp!
  ): RequestStatus_mutation_response

  """
  update single row of the table: "RequestStatus"
  """
  update_RequestStatus_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: RequestStatus_set_input
    pk_columns: RequestStatus_pk_columns_input!
  ): RequestStatus

  """
  update single row of the table: "Request"
  """
  update_Request_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Request_set_input
    pk_columns: Request_pk_columns_input!
  ): Request

  """
  update data of the table: "Series"
  """
  update_Series(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Series_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Series_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Series_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Series_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Series_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Series_set_input

    """filter the rows which have to be updated"""
    where: Series_bool_exp!
  ): Series_mutation_response

  """
  update data of the table: "SeriesType"
  """
  update_SeriesType(
    """sets the columns of the filtered rows to the given values"""
    _set: SeriesType_set_input

    """filter the rows which have to be updated"""
    where: SeriesType_bool_exp!
  ): SeriesType_mutation_response

  """
  update single row of the table: "SeriesType"
  """
  update_SeriesType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: SeriesType_set_input
    pk_columns: SeriesType_pk_columns_input!
  ): SeriesType

  """
  update single row of the table: "Series"
  """
  update_Series_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Series_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Series_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Series_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Series_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Series_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Series_set_input
    pk_columns: Series_pk_columns_input!
  ): Series

  """
  update data of the table: "Spotlight"
  """
  update_Spotlight(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Spotlight_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Spotlight_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Spotlight_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Spotlight_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Spotlight_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Spotlight_set_input

    """filter the rows which have to be updated"""
    where: Spotlight_bool_exp!
  ): Spotlight_mutation_response

  """
  update data of the table: "SpotlightHeroUnitLayout"
  """
  update_SpotlightHeroUnitLayout(
    """sets the columns of the filtered rows to the given values"""
    _set: SpotlightHeroUnitLayout_set_input

    """filter the rows which have to be updated"""
    where: SpotlightHeroUnitLayout_bool_exp!
  ): SpotlightHeroUnitLayout_mutation_response

  """
  update single row of the table: "SpotlightHeroUnitLayout"
  """
  update_SpotlightHeroUnitLayout_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: SpotlightHeroUnitLayout_set_input
    pk_columns: SpotlightHeroUnitLayout_pk_columns_input!
  ): SpotlightHeroUnitLayout

  """
  update data of the table: "SpotlightType"
  """
  update_SpotlightType(
    """sets the columns of the filtered rows to the given values"""
    _set: SpotlightType_set_input

    """filter the rows which have to be updated"""
    where: SpotlightType_bool_exp!
  ): SpotlightType_mutation_response

  """
  update single row of the table: "SpotlightType"
  """
  update_SpotlightType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: SpotlightType_set_input
    pk_columns: SpotlightType_pk_columns_input!
  ): SpotlightType

  """
  update single row of the table: "Spotlight"
  """
  update_Spotlight_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Spotlight_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Spotlight_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Spotlight_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Spotlight_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Spotlight_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Spotlight_set_input
    pk_columns: Spotlight_pk_columns_input!
  ): Spotlight

  """
  update data of the table: "Tag"
  """
  update_Tag(
    """sets the columns of the filtered rows to the given values"""
    _set: Tag_set_input

    """filter the rows which have to be updated"""
    where: Tag_bool_exp!
  ): Tag_mutation_response

  """
  update single row of the table: "Tag"
  """
  update_Tag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Tag_set_input
    pk_columns: Tag_pk_columns_input!
  ): Tag

  """
  update data of the table: "TooniesShippingInfo"
  """
  update_TooniesShippingInfo(
    """sets the columns of the filtered rows to the given values"""
    _set: TooniesShippingInfo_set_input

    """filter the rows which have to be updated"""
    where: TooniesShippingInfo_bool_exp!
  ): TooniesShippingInfo_mutation_response

  """
  update single row of the table: "TooniesShippingInfo"
  """
  update_TooniesShippingInfo_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: TooniesShippingInfo_set_input
    pk_columns: TooniesShippingInfo_pk_columns_input!
  ): TooniesShippingInfo

  """
  update data of the table: "TwitterAuth"
  """
  update_TwitterAuth(
    """sets the columns of the filtered rows to the given values"""
    _set: TwitterAuth_set_input

    """filter the rows which have to be updated"""
    where: TwitterAuth_bool_exp!
  ): TwitterAuth_mutation_response

  """
  update single row of the table: "TwitterAuth"
  """
  update_TwitterAuth_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: TwitterAuth_set_input
    pk_columns: TwitterAuth_pk_columns_input!
  ): TwitterAuth

  """
  update data of the table: "Unlockable"
  """
  update_Unlockable(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Unlockable_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Unlockable_set_input

    """filter the rows which have to be updated"""
    where: Unlockable_bool_exp!
  ): Unlockable_mutation_response

  """
  update data of the table: "UnlockableWinner"
  """
  update_UnlockableWinner(
    """sets the columns of the filtered rows to the given values"""
    _set: UnlockableWinner_set_input

    """filter the rows which have to be updated"""
    where: UnlockableWinner_bool_exp!
  ): UnlockableWinner_mutation_response

  """
  update single row of the table: "UnlockableWinner"
  """
  update_UnlockableWinner_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: UnlockableWinner_set_input
    pk_columns: UnlockableWinner_pk_columns_input!
  ): UnlockableWinner

  """
  update single row of the table: "Unlockable"
  """
  update_Unlockable_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Unlockable_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Unlockable_set_input
    pk_columns: Unlockable_pk_columns_input!
  ): Unlockable

  """
  update data of the table: "User"
  """
  update_User(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: User_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: User_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: User_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: User_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: User_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: User_set_input

    """filter the rows which have to be updated"""
    where: User_bool_exp!
  ): User_mutation_response

  """
  update data of the table: "UserFollows"
  """
  update_UserFollows(
    """sets the columns of the filtered rows to the given values"""
    _set: UserFollows_set_input

    """filter the rows which have to be updated"""
    where: UserFollows_bool_exp!
  ): UserFollows_mutation_response

  """
  update single row of the table: "UserFollows"
  """
  update_UserFollows_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserFollows_set_input
    pk_columns: UserFollows_pk_columns_input!
  ): UserFollows

  """
  update single row of the table: "User"
  """
  update_User_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: User_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: User_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: User_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: User_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: User_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: User_set_input
    pk_columns: User_pk_columns_input!
  ): User

  """
  update data of the table: "Video"
  """
  update_Video(
    """sets the columns of the filtered rows to the given values"""
    _set: Video_set_input

    """filter the rows which have to be updated"""
    where: Video_bool_exp!
  ): Video_mutation_response

  """
  update single row of the table: "Video"
  """
  update_Video_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Video_set_input
    pk_columns: Video_pk_columns_input!
  ): Video

  """
  update data of the table: "Vote"
  """
  update_Vote(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Vote_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Vote_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Vote_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Vote_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Vote_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Vote_set_input

    """filter the rows which have to be updated"""
    where: Vote_bool_exp!
  ): Vote_mutation_response

  """
  update data of the table: "VoteReason"
  """
  update_VoteReason(
    """sets the columns of the filtered rows to the given values"""
    _set: VoteReason_set_input

    """filter the rows which have to be updated"""
    where: VoteReason_bool_exp!
  ): VoteReason_mutation_response

  """
  update single row of the table: "VoteReason"
  """
  update_VoteReason_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: VoteReason_set_input
    pk_columns: VoteReason_pk_columns_input!
  ): VoteReason

  """
  update data of the table: "VoteType"
  """
  update_VoteType(
    """sets the columns of the filtered rows to the given values"""
    _set: VoteType_set_input

    """filter the rows which have to be updated"""
    where: VoteType_bool_exp!
  ): VoteType_mutation_response

  """
  update single row of the table: "VoteType"
  """
  update_VoteType_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: VoteType_set_input
    pk_columns: VoteType_pk_columns_input!
  ): VoteType

  """
  update single row of the table: "Vote"
  """
  update_Vote_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Vote_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Vote_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: Vote_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Vote_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Vote_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Vote_set_input
    pk_columns: Vote_pk_columns_input!
  ): Vote

  """
  update data of the table: "Whitelist"
  """
  update_Whitelist(
    """sets the columns of the filtered rows to the given values"""
    _set: Whitelist_set_input

    """filter the rows which have to be updated"""
    where: Whitelist_bool_exp!
  ): Whitelist_mutation_response

  """
  update single row of the table: "Whitelist"
  """
  update_Whitelist_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Whitelist_set_input
    pk_columns: Whitelist_pk_columns_input!
  ): Whitelist

  """
  update data of the table: "top_collector_stats"
  """
  update_top_collector_stats(
    """increments the numeric columns with given value of the filtered values"""
    _inc: top_collector_stats_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: top_collector_stats_set_input

    """filter the rows which have to be updated"""
    where: top_collector_stats_bool_exp!
  ): top_collector_stats_mutation_response

  """
  update data of the table: "top_creator_stats"
  """
  update_top_creator_stats(
    """increments the numeric columns with given value of the filtered values"""
    _inc: top_creator_stats_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: top_creator_stats_set_input

    """filter the rows which have to be updated"""
    where: top_creator_stats_bool_exp!
  ): top_creator_stats_mutation_response
}

"""
columns and relationships of "Nft"
"""
type Nft implements Node {
  """An object relationship"""
  Creator: User!
  auctionCount: Int!
  campaignFundingTierId: uuid
  creatorId: String!
  edition: Int
  hasBeenSold: Boolean!
  id: ID!
  isImported: Boolean!
  isMasterEdition: Boolean!
  isPnft: Boolean!
  masterEdition: String

  """
  If this NFT is a standard edition print this column points to the master edition NFT mint it was created from.
  """
  masterEditionMint: String

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Int
  metadataId: String!
  mint: String!
  ownerId: String!
  priceLastSoldCurrencyId: uuid!
  priceLastSoldForInLamports: bigint
  seriesId: String
  seriesRarityBasisPoints: numeric
  seriesRarityRanking: Int

  """This is the limited edition PDA"""
  standardEdition: String
  status: NftStatus_enum!
  timeCreated: timestamptz!

  """
  Time last edition was sold as a primary sale for a master edition with
  non-zero supply. Does not apply to other types of NFTs.
  """
  timeLastEditionSoldPrimary: timestamptz
}

"""
aggregated selection of "Nft"
"""
type Nft_aggregate {
  aggregate: Nft_aggregate_fields
  nodes: [Nft!]!
}

"""
aggregate fields of "Nft"
"""
type Nft_aggregate_fields {
  avg: Nft_avg_fields
  count(columns: [Nft_select_column!], distinct: Boolean): Int!
  max: Nft_max_fields
  min: Nft_min_fields
  stddev: Nft_stddev_fields
  stddev_pop: Nft_stddev_pop_fields
  stddev_samp: Nft_stddev_samp_fields
  sum: Nft_sum_fields
  var_pop: Nft_var_pop_fields
  var_samp: Nft_var_samp_fields
  variance: Nft_variance_fields
}

"""
order by aggregate values of table "Nft"
"""
input Nft_aggregate_order_by {
  avg: Nft_avg_order_by
  count: order_by
  max: Nft_max_order_by
  min: Nft_min_order_by
  stddev: Nft_stddev_order_by
  stddev_pop: Nft_stddev_pop_order_by
  stddev_samp: Nft_stddev_samp_order_by
  sum: Nft_sum_order_by
  var_pop: Nft_var_pop_order_by
  var_samp: Nft_var_samp_order_by
  variance: Nft_variance_order_by
}

"""
input type for inserting array relation for remote table "Nft"
"""
input Nft_arr_rel_insert_input {
  data: [Nft_insert_input!]!

  """upsert condition"""
  on_conflict: Nft_on_conflict
}

"""aggregate avg on columns"""
type Nft_avg_fields {
  auctionCount: Float
  edition: Float

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Float
  priceLastSoldForInLamports: Float
  seriesRarityBasisPoints: Float
  seriesRarityRanking: Float
}

"""
order by avg() on columns of table "Nft"
"""
input Nft_avg_order_by {
  auctionCount: order_by
  edition: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  priceLastSoldForInLamports: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by
}

"""
Boolean expression to filter rows from the table "Nft". All fields are combined with a logical 'AND'.
"""
input Nft_bool_exp {
  Creator: User_bool_exp
  _and: [Nft_bool_exp!]
  _not: Nft_bool_exp
  _or: [Nft_bool_exp!]
  auctionCount: Int_comparison_exp
  campaignFundingTierId: uuid_comparison_exp
  creatorId: String_comparison_exp
  edition: Int_comparison_exp
  hasBeenSold: Boolean_comparison_exp
  id: String_comparison_exp
  isImported: Boolean_comparison_exp
  isMasterEdition: Boolean_comparison_exp
  isPnft: Boolean_comparison_exp
  masterEdition: String_comparison_exp
  masterEditionMint: String_comparison_exp
  maxSupply: Int_comparison_exp
  metadataId: String_comparison_exp
  mint: String_comparison_exp
  ownerId: String_comparison_exp
  priceLastSoldCurrencyId: uuid_comparison_exp
  priceLastSoldForInLamports: bigint_comparison_exp
  seriesId: String_comparison_exp
  seriesRarityBasisPoints: numeric_comparison_exp
  seriesRarityRanking: Int_comparison_exp
  standardEdition: String_comparison_exp
  status: NftStatus_enum_comparison_exp
  timeCreated: timestamptz_comparison_exp
  timeLastEditionSoldPrimary: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "Nft"
"""
enum Nft_constraint {
  """unique or primary key constraint"""
  Nft_metadataId_key

  """unique or primary key constraint"""
  Nft_mint_key

  """unique or primary key constraint"""
  Nft_pkey
}

"""
input type for incrementing numeric columns in table "Nft"
"""
input Nft_inc_input {
  auctionCount: Int
  edition: Int

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Int
  priceLastSoldForInLamports: bigint
  seriesRarityBasisPoints: numeric
  seriesRarityRanking: Int
}

"""
input type for inserting data into table "Nft"
"""
input Nft_insert_input {
  Creator: User_obj_rel_insert_input
  auctionCount: Int
  campaignFundingTierId: uuid
  creatorId: String
  edition: Int
  hasBeenSold: Boolean
  id: String
  isImported: Boolean
  isMasterEdition: Boolean
  isPnft: Boolean
  masterEdition: String

  """
  If this NFT is a standard edition print this column points to the master edition NFT mint it was created from.
  """
  masterEditionMint: String

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Int
  metadataId: String
  mint: String
  ownerId: String
  priceLastSoldCurrencyId: uuid
  priceLastSoldForInLamports: bigint
  seriesId: String
  seriesRarityBasisPoints: numeric
  seriesRarityRanking: Int

  """This is the limited edition PDA"""
  standardEdition: String
  status: NftStatus_enum
  timeCreated: timestamptz

  """
  Time last edition was sold as a primary sale for a master edition with
  non-zero supply. Does not apply to other types of NFTs.
  """
  timeLastEditionSoldPrimary: timestamptz
}

"""aggregate max on columns"""
type Nft_max_fields {
  auctionCount: Int
  campaignFundingTierId: uuid
  creatorId: String
  edition: Int
  id: String
  masterEdition: String

  """
  If this NFT is a standard edition print this column points to the master edition NFT mint it was created from.
  """
  masterEditionMint: String

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Int
  metadataId: String
  mint: String
  ownerId: String
  priceLastSoldCurrencyId: uuid
  priceLastSoldForInLamports: bigint
  seriesId: String
  seriesRarityBasisPoints: numeric
  seriesRarityRanking: Int

  """This is the limited edition PDA"""
  standardEdition: String
  timeCreated: timestamptz

  """
  Time last edition was sold as a primary sale for a master edition with
  non-zero supply. Does not apply to other types of NFTs.
  """
  timeLastEditionSoldPrimary: timestamptz
}

"""
order by max() on columns of table "Nft"
"""
input Nft_max_order_by {
  auctionCount: order_by
  campaignFundingTierId: order_by
  creatorId: order_by
  edition: order_by
  id: order_by
  masterEdition: order_by

  """
  If this NFT is a standard edition print this column points to the master edition NFT mint it was created from.
  """
  masterEditionMint: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  metadataId: order_by
  mint: order_by
  ownerId: order_by
  priceLastSoldCurrencyId: order_by
  priceLastSoldForInLamports: order_by
  seriesId: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by

  """This is the limited edition PDA"""
  standardEdition: order_by
  timeCreated: order_by

  """
  Time last edition was sold as a primary sale for a master edition with
  non-zero supply. Does not apply to other types of NFTs.
  """
  timeLastEditionSoldPrimary: order_by
}

"""aggregate min on columns"""
type Nft_min_fields {
  auctionCount: Int
  campaignFundingTierId: uuid
  creatorId: String
  edition: Int
  id: String
  masterEdition: String

  """
  If this NFT is a standard edition print this column points to the master edition NFT mint it was created from.
  """
  masterEditionMint: String

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Int
  metadataId: String
  mint: String
  ownerId: String
  priceLastSoldCurrencyId: uuid
  priceLastSoldForInLamports: bigint
  seriesId: String
  seriesRarityBasisPoints: numeric
  seriesRarityRanking: Int

  """This is the limited edition PDA"""
  standardEdition: String
  timeCreated: timestamptz

  """
  Time last edition was sold as a primary sale for a master edition with
  non-zero supply. Does not apply to other types of NFTs.
  """
  timeLastEditionSoldPrimary: timestamptz
}

"""
order by min() on columns of table "Nft"
"""
input Nft_min_order_by {
  auctionCount: order_by
  campaignFundingTierId: order_by
  creatorId: order_by
  edition: order_by
  id: order_by
  masterEdition: order_by

  """
  If this NFT is a standard edition print this column points to the master edition NFT mint it was created from.
  """
  masterEditionMint: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  metadataId: order_by
  mint: order_by
  ownerId: order_by
  priceLastSoldCurrencyId: order_by
  priceLastSoldForInLamports: order_by
  seriesId: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by

  """This is the limited edition PDA"""
  standardEdition: order_by
  timeCreated: order_by

  """
  Time last edition was sold as a primary sale for a master edition with
  non-zero supply. Does not apply to other types of NFTs.
  """
  timeLastEditionSoldPrimary: order_by
}

"""
response of any mutation on the table "Nft"
"""
type Nft_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Nft!]!
}

"""
input type for inserting object relation for remote table "Nft"
"""
input Nft_obj_rel_insert_input {
  data: Nft_insert_input!

  """upsert condition"""
  on_conflict: Nft_on_conflict
}

"""
on_conflict condition type for table "Nft"
"""
input Nft_on_conflict {
  constraint: Nft_constraint!
  update_columns: [Nft_update_column!]! = []
  where: Nft_bool_exp
}

"""Ordering options when selecting data from "Nft"."""
input Nft_order_by {
  Creator: User_order_by
  auctionCount: order_by
  campaignFundingTierId: order_by
  creatorId: order_by
  edition: order_by
  hasBeenSold: order_by
  id: order_by
  isImported: order_by
  isMasterEdition: order_by
  isPnft: order_by
  masterEdition: order_by
  masterEditionMint: order_by
  maxSupply: order_by
  metadataId: order_by
  mint: order_by
  ownerId: order_by
  priceLastSoldCurrencyId: order_by
  priceLastSoldForInLamports: order_by
  seriesId: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by
  standardEdition: order_by
  status: order_by
  timeCreated: order_by
  timeLastEditionSoldPrimary: order_by
}

"""primary key columns input for table: Nft"""
input Nft_pk_columns_input {
  id: String!
}

"""
select columns of table "Nft"
"""
enum Nft_select_column {
  """column name"""
  auctionCount

  """column name"""
  campaignFundingTierId

  """column name"""
  creatorId

  """column name"""
  edition

  """column name"""
  hasBeenSold

  """column name"""
  id

  """column name"""
  isImported

  """column name"""
  isMasterEdition

  """column name"""
  isPnft

  """column name"""
  masterEdition

  """column name"""
  masterEditionMint

  """column name"""
  maxSupply

  """column name"""
  metadataId

  """column name"""
  mint

  """column name"""
  ownerId

  """column name"""
  priceLastSoldCurrencyId

  """column name"""
  priceLastSoldForInLamports

  """column name"""
  seriesId

  """column name"""
  seriesRarityBasisPoints

  """column name"""
  seriesRarityRanking

  """column name"""
  standardEdition

  """column name"""
  status

  """column name"""
  timeCreated

  """column name"""
  timeLastEditionSoldPrimary
}

"""
input type for updating data in table "Nft"
"""
input Nft_set_input {
  auctionCount: Int
  campaignFundingTierId: uuid
  creatorId: String
  edition: Int
  hasBeenSold: Boolean
  id: String
  isImported: Boolean
  isMasterEdition: Boolean
  isPnft: Boolean
  masterEdition: String

  """
  If this NFT is a standard edition print this column points to the master edition NFT mint it was created from.
  """
  masterEditionMint: String

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Int
  metadataId: String
  mint: String
  ownerId: String
  priceLastSoldCurrencyId: uuid
  priceLastSoldForInLamports: bigint
  seriesId: String
  seriesRarityBasisPoints: numeric
  seriesRarityRanking: Int

  """This is the limited edition PDA"""
  standardEdition: String
  status: NftStatus_enum
  timeCreated: timestamptz

  """
  Time last edition was sold as a primary sale for a master edition with
  non-zero supply. Does not apply to other types of NFTs.
  """
  timeLastEditionSoldPrimary: timestamptz
}

"""aggregate stddev on columns"""
type Nft_stddev_fields {
  auctionCount: Float
  edition: Float

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Float
  priceLastSoldForInLamports: Float
  seriesRarityBasisPoints: Float
  seriesRarityRanking: Float
}

"""
order by stddev() on columns of table "Nft"
"""
input Nft_stddev_order_by {
  auctionCount: order_by
  edition: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  priceLastSoldForInLamports: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by
}

"""aggregate stddev_pop on columns"""
type Nft_stddev_pop_fields {
  auctionCount: Float
  edition: Float

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Float
  priceLastSoldForInLamports: Float
  seriesRarityBasisPoints: Float
  seriesRarityRanking: Float
}

"""
order by stddev_pop() on columns of table "Nft"
"""
input Nft_stddev_pop_order_by {
  auctionCount: order_by
  edition: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  priceLastSoldForInLamports: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by
}

"""aggregate stddev_samp on columns"""
type Nft_stddev_samp_fields {
  auctionCount: Float
  edition: Float

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Float
  priceLastSoldForInLamports: Float
  seriesRarityBasisPoints: Float
  seriesRarityRanking: Float
}

"""
order by stddev_samp() on columns of table "Nft"
"""
input Nft_stddev_samp_order_by {
  auctionCount: order_by
  edition: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  priceLastSoldForInLamports: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by
}

"""aggregate sum on columns"""
type Nft_sum_fields {
  auctionCount: Int
  edition: Int

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Int
  priceLastSoldForInLamports: bigint
  seriesRarityBasisPoints: numeric
  seriesRarityRanking: Int
}

"""
order by sum() on columns of table "Nft"
"""
input Nft_sum_order_by {
  auctionCount: order_by
  edition: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  priceLastSoldForInLamports: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by
}

"""
update columns of table "Nft"
"""
enum Nft_update_column {
  """column name"""
  auctionCount

  """column name"""
  campaignFundingTierId

  """column name"""
  creatorId

  """column name"""
  edition

  """column name"""
  hasBeenSold

  """column name"""
  id

  """column name"""
  isImported

  """column name"""
  isMasterEdition

  """column name"""
  isPnft

  """column name"""
  masterEdition

  """column name"""
  masterEditionMint

  """column name"""
  maxSupply

  """column name"""
  metadataId

  """column name"""
  mint

  """column name"""
  ownerId

  """column name"""
  priceLastSoldCurrencyId

  """column name"""
  priceLastSoldForInLamports

  """column name"""
  seriesId

  """column name"""
  seriesRarityBasisPoints

  """column name"""
  seriesRarityRanking

  """column name"""
  standardEdition

  """column name"""
  status

  """column name"""
  timeCreated

  """column name"""
  timeLastEditionSoldPrimary
}

"""aggregate var_pop on columns"""
type Nft_var_pop_fields {
  auctionCount: Float
  edition: Float

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Float
  priceLastSoldForInLamports: Float
  seriesRarityBasisPoints: Float
  seriesRarityRanking: Float
}

"""
order by var_pop() on columns of table "Nft"
"""
input Nft_var_pop_order_by {
  auctionCount: order_by
  edition: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  priceLastSoldForInLamports: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by
}

"""aggregate var_samp on columns"""
type Nft_var_samp_fields {
  auctionCount: Float
  edition: Float

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Float
  priceLastSoldForInLamports: Float
  seriesRarityBasisPoints: Float
  seriesRarityRanking: Float
}

"""
order by var_samp() on columns of table "Nft"
"""
input Nft_var_samp_order_by {
  auctionCount: order_by
  edition: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  priceLastSoldForInLamports: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by
}

"""aggregate variance on columns"""
type Nft_variance_fields {
  auctionCount: Float
  edition: Float

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: Float
  priceLastSoldForInLamports: Float
  seriesRarityBasisPoints: Float
  seriesRarityRanking: Float
}

"""
order by variance() on columns of table "Nft"
"""
input Nft_variance_order_by {
  auctionCount: order_by
  edition: order_by

  """
  The max number of standard editions that can be printed based on a master
  edition. For standard edition NFTs, it is null. For master edition NFTs, null
  means an unlimited number of editions can be printed, and 0 means no editions
  can be printed (the NFT is a true 1/1).
  """
  maxSupply: order_by
  priceLastSoldForInLamports: order_by
  seriesRarityBasisPoints: order_by
  seriesRarityRanking: order_by
}

"""
A Relay connection object on "Nft"
"""
type NftConnection {
  edges: [NftEdge!]!
  pageInfo: PageInfo!
}

"""
columns and relationships of "NftDisclosure"
"""
type NftDisclosure implements Node {
  details: String
  id: ID!
  nftId: String!
  type: NftDisclosureType_enum!
}

"""
Boolean expression to filter rows from the table "NftDisclosure". All fields are combined with a logical 'AND'.
"""
input NftDisclosure_bool_exp {
  _and: [NftDisclosure_bool_exp!]
  _not: NftDisclosure_bool_exp
  _or: [NftDisclosure_bool_exp!]
  details: String_comparison_exp
  id: uuid_comparison_exp
  nftId: String_comparison_exp
  type: NftDisclosureType_enum_comparison_exp
}

"""
unique or primary key constraints on table "NftDisclosure"
"""
enum NftDisclosure_constraint {
  """unique or primary key constraint"""
  NftDisclosure_id_key

  """unique or primary key constraint"""
  NftDisclosure_pkey
}

"""
input type for inserting data into table "NftDisclosure"
"""
input NftDisclosure_insert_input {
  details: String
  id: uuid
  nftId: String
  type: NftDisclosureType_enum
}

"""
response of any mutation on the table "NftDisclosure"
"""
type NftDisclosure_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftDisclosure!]!
}

"""
on_conflict condition type for table "NftDisclosure"
"""
input NftDisclosure_on_conflict {
  constraint: NftDisclosure_constraint!
  update_columns: [NftDisclosure_update_column!]! = []
  where: NftDisclosure_bool_exp
}

"""Ordering options when selecting data from "NftDisclosure"."""
input NftDisclosure_order_by {
  details: order_by
  id: order_by
  nftId: order_by
  type: order_by
}

"""primary key columns input for table: NftDisclosure"""
input NftDisclosure_pk_columns_input {
  nftId: String!
  type: NftDisclosureType_enum!
}

"""
select columns of table "NftDisclosure"
"""
enum NftDisclosure_select_column {
  """column name"""
  details

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  type
}

"""
input type for updating data in table "NftDisclosure"
"""
input NftDisclosure_set_input {
  details: String
  id: uuid
  nftId: String
  type: NftDisclosureType_enum
}

"""
update columns of table "NftDisclosure"
"""
enum NftDisclosure_update_column {
  """column name"""
  details

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  type
}

"""
A Relay connection object on "NftDisclosure"
"""
type NftDisclosureConnection {
  edges: [NftDisclosureEdge!]!
  pageInfo: PageInfo!
}

type NftDisclosureEdge {
  cursor: String!
  node: NftDisclosure!
}

"""
columns and relationships of "NftDisclosureType"
"""
type NftDisclosureType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "NftDisclosureType". All fields are combined with a logical 'AND'.
"""
input NftDisclosureType_bool_exp {
  _and: [NftDisclosureType_bool_exp!]
  _not: NftDisclosureType_bool_exp
  _or: [NftDisclosureType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "NftDisclosureType"
"""
enum NftDisclosureType_constraint {
  """unique or primary key constraint"""
  NftDisclosureType_pkey
}

enum NftDisclosureType_enum {
  AiArt
  Derivative
  Nsfw
}

"""
Boolean expression to compare columns of type "NftDisclosureType_enum". All fields are combined with logical 'AND'.
"""
input NftDisclosureType_enum_comparison_exp {
  _eq: NftDisclosureType_enum
  _in: [NftDisclosureType_enum!]
  _is_null: Boolean
  _neq: NftDisclosureType_enum
  _nin: [NftDisclosureType_enum!]
}

"""
input type for inserting data into table "NftDisclosureType"
"""
input NftDisclosureType_insert_input {
  value: String
}

"""
response of any mutation on the table "NftDisclosureType"
"""
type NftDisclosureType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftDisclosureType!]!
}

"""
on_conflict condition type for table "NftDisclosureType"
"""
input NftDisclosureType_on_conflict {
  constraint: NftDisclosureType_constraint!
  update_columns: [NftDisclosureType_update_column!]! = []
  where: NftDisclosureType_bool_exp
}

"""Ordering options when selecting data from "NftDisclosureType"."""
input NftDisclosureType_order_by {
  value: order_by
}

"""primary key columns input for table: NftDisclosureType"""
input NftDisclosureType_pk_columns_input {
  value: String!
}

"""
select columns of table "NftDisclosureType"
"""
enum NftDisclosureType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "NftDisclosureType"
"""
input NftDisclosureType_set_input {
  value: String
}

"""
update columns of table "NftDisclosureType"
"""
enum NftDisclosureType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "NftDisclosureType"
"""
type NftDisclosureTypeConnection {
  edges: [NftDisclosureTypeEdge!]!
  pageInfo: PageInfo!
}

type NftDisclosureTypeEdge {
  cursor: String!
  node: NftDisclosureType!
}

type NftEdge {
  cursor: String!
  node: Nft!
}

"""
columns and relationships of "NftListing"
"""
type NftListing implements Node {
  """An object relationship"""
  Nft: Nft!

  """An object relationship"""
  PnftForAuction: Nft

  """An object relationship"""
  Unlockable: Unlockable
  antiBotProtectionEnabled: Boolean
  auctionDurationInSeconds: Int!
  auctionEndTime: timestamptz
  currencyId: uuid!
  editionAllowlistEnabled: Boolean!
  editionAllowlistPrice: bigint
  editionAllowlistSaleStartTime: timestamptz
  editionBuyLimitPerAddress: Int
  editionPriceFunctionParams(
    """JSON select path"""
    path: String
  ): jsonb
  editionPriceFunctionStartingPriceInLamports: bigint
  editionPriceFunctionType: PriceFunctionType_enum
  editionPublicSaleStartTime: timestamptz
  id: ID!
  isPnftDropActive: Boolean
  nftId: String!
  pnftIdForAuction: String
  priceInLamports: bigint
  scheduledAuctionTime: timestamptz
  tickSizeConstantInLamports: bigint
  timeCreated: timestamptz!
  timeExtensionDurationInSeconds: Int!
  timeLastAuctionAlmostOverEmailSent: timestamptz
  unlockableId: uuid
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input NftListing_append_input {
  editionPriceFunctionParams: jsonb
}

"""
Boolean expression to filter rows from the table "NftListing". All fields are combined with a logical 'AND'.
"""
input NftListing_bool_exp {
  Nft: Nft_bool_exp
  PnftForAuction: Nft_bool_exp
  Unlockable: Unlockable_bool_exp
  _and: [NftListing_bool_exp!]
  _not: NftListing_bool_exp
  _or: [NftListing_bool_exp!]
  antiBotProtectionEnabled: Boolean_comparison_exp
  auctionDurationInSeconds: Int_comparison_exp
  auctionEndTime: timestamptz_comparison_exp
  currencyId: uuid_comparison_exp
  editionAllowlistEnabled: Boolean_comparison_exp
  editionAllowlistPrice: bigint_comparison_exp
  editionAllowlistSaleStartTime: timestamptz_comparison_exp
  editionBuyLimitPerAddress: Int_comparison_exp
  editionPriceFunctionParams: jsonb_comparison_exp
  editionPriceFunctionStartingPriceInLamports: bigint_comparison_exp
  editionPriceFunctionType: PriceFunctionType_enum_comparison_exp
  editionPublicSaleStartTime: timestamptz_comparison_exp
  id: uuid_comparison_exp
  isPnftDropActive: Boolean_comparison_exp
  nftId: String_comparison_exp
  pnftIdForAuction: String_comparison_exp
  priceInLamports: bigint_comparison_exp
  scheduledAuctionTime: timestamptz_comparison_exp
  tickSizeConstantInLamports: bigint_comparison_exp
  timeCreated: timestamptz_comparison_exp
  timeExtensionDurationInSeconds: Int_comparison_exp
  timeLastAuctionAlmostOverEmailSent: timestamptz_comparison_exp
  unlockableId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "NftListing"
"""
enum NftListing_constraint {
  """unique or primary key constraint"""
  NftListing_id_key

  """unique or primary key constraint"""
  NftListing_nftId_key

  """unique or primary key constraint"""
  NftListing_pkey

  """unique or primary key constraint"""
  NftListing_unlockableId_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input NftListing_delete_at_path_input {
  editionPriceFunctionParams: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input NftListing_delete_elem_input {
  editionPriceFunctionParams: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input NftListing_delete_key_input {
  editionPriceFunctionParams: String
}

"""
input type for incrementing numeric columns in table "NftListing"
"""
input NftListing_inc_input {
  auctionDurationInSeconds: Int
  editionAllowlistPrice: bigint
  editionBuyLimitPerAddress: Int
  editionPriceFunctionStartingPriceInLamports: bigint
  priceInLamports: bigint
  tickSizeConstantInLamports: bigint
  timeExtensionDurationInSeconds: Int
}

"""
input type for inserting data into table "NftListing"
"""
input NftListing_insert_input {
  Nft: Nft_obj_rel_insert_input
  PnftForAuction: Nft_obj_rel_insert_input
  Unlockable: Unlockable_obj_rel_insert_input
  antiBotProtectionEnabled: Boolean
  auctionDurationInSeconds: Int
  auctionEndTime: timestamptz
  currencyId: uuid
  editionAllowlistEnabled: Boolean
  editionAllowlistPrice: bigint
  editionAllowlistSaleStartTime: timestamptz
  editionBuyLimitPerAddress: Int
  editionPriceFunctionParams: jsonb
  editionPriceFunctionStartingPriceInLamports: bigint
  editionPriceFunctionType: PriceFunctionType_enum
  editionPublicSaleStartTime: timestamptz
  id: uuid
  isPnftDropActive: Boolean
  nftId: String
  pnftIdForAuction: String
  priceInLamports: bigint
  scheduledAuctionTime: timestamptz
  tickSizeConstantInLamports: bigint
  timeCreated: timestamptz
  timeExtensionDurationInSeconds: Int
  timeLastAuctionAlmostOverEmailSent: timestamptz
  unlockableId: uuid
}

"""
response of any mutation on the table "NftListing"
"""
type NftListing_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftListing!]!
}

"""
input type for inserting object relation for remote table "NftListing"
"""
input NftListing_obj_rel_insert_input {
  data: NftListing_insert_input!

  """upsert condition"""
  on_conflict: NftListing_on_conflict
}

"""
on_conflict condition type for table "NftListing"
"""
input NftListing_on_conflict {
  constraint: NftListing_constraint!
  update_columns: [NftListing_update_column!]! = []
  where: NftListing_bool_exp
}

"""Ordering options when selecting data from "NftListing"."""
input NftListing_order_by {
  Nft: Nft_order_by
  PnftForAuction: Nft_order_by
  Unlockable: Unlockable_order_by
  antiBotProtectionEnabled: order_by
  auctionDurationInSeconds: order_by
  auctionEndTime: order_by
  currencyId: order_by
  editionAllowlistEnabled: order_by
  editionAllowlistPrice: order_by
  editionAllowlistSaleStartTime: order_by
  editionBuyLimitPerAddress: order_by
  editionPriceFunctionParams: order_by
  editionPriceFunctionStartingPriceInLamports: order_by
  editionPriceFunctionType: order_by
  editionPublicSaleStartTime: order_by
  id: order_by
  isPnftDropActive: order_by
  nftId: order_by
  pnftIdForAuction: order_by
  priceInLamports: order_by
  scheduledAuctionTime: order_by
  tickSizeConstantInLamports: order_by
  timeCreated: order_by
  timeExtensionDurationInSeconds: order_by
  timeLastAuctionAlmostOverEmailSent: order_by
  unlockableId: order_by
}

"""primary key columns input for table: NftListing"""
input NftListing_pk_columns_input {
  nftId: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input NftListing_prepend_input {
  editionPriceFunctionParams: jsonb
}

"""
select columns of table "NftListing"
"""
enum NftListing_select_column {
  """column name"""
  antiBotProtectionEnabled

  """column name"""
  auctionDurationInSeconds

  """column name"""
  auctionEndTime

  """column name"""
  currencyId

  """column name"""
  editionAllowlistEnabled

  """column name"""
  editionAllowlistPrice

  """column name"""
  editionAllowlistSaleStartTime

  """column name"""
  editionBuyLimitPerAddress

  """column name"""
  editionPriceFunctionParams

  """column name"""
  editionPriceFunctionStartingPriceInLamports

  """column name"""
  editionPriceFunctionType

  """column name"""
  editionPublicSaleStartTime

  """column name"""
  id

  """column name"""
  isPnftDropActive

  """column name"""
  nftId

  """column name"""
  pnftIdForAuction

  """column name"""
  priceInLamports

  """column name"""
  scheduledAuctionTime

  """column name"""
  tickSizeConstantInLamports

  """column name"""
  timeCreated

  """column name"""
  timeExtensionDurationInSeconds

  """column name"""
  timeLastAuctionAlmostOverEmailSent

  """column name"""
  unlockableId
}

"""
input type for updating data in table "NftListing"
"""
input NftListing_set_input {
  antiBotProtectionEnabled: Boolean
  auctionDurationInSeconds: Int
  auctionEndTime: timestamptz
  currencyId: uuid
  editionAllowlistEnabled: Boolean
  editionAllowlistPrice: bigint
  editionAllowlistSaleStartTime: timestamptz
  editionBuyLimitPerAddress: Int
  editionPriceFunctionParams: jsonb
  editionPriceFunctionStartingPriceInLamports: bigint
  editionPriceFunctionType: PriceFunctionType_enum
  editionPublicSaleStartTime: timestamptz
  id: uuid
  isPnftDropActive: Boolean
  nftId: String
  pnftIdForAuction: String
  priceInLamports: bigint
  scheduledAuctionTime: timestamptz
  tickSizeConstantInLamports: bigint
  timeCreated: timestamptz
  timeExtensionDurationInSeconds: Int
  timeLastAuctionAlmostOverEmailSent: timestamptz
  unlockableId: uuid
}

"""
update columns of table "NftListing"
"""
enum NftListing_update_column {
  """column name"""
  antiBotProtectionEnabled

  """column name"""
  auctionDurationInSeconds

  """column name"""
  auctionEndTime

  """column name"""
  currencyId

  """column name"""
  editionAllowlistEnabled

  """column name"""
  editionAllowlistPrice

  """column name"""
  editionAllowlistSaleStartTime

  """column name"""
  editionBuyLimitPerAddress

  """column name"""
  editionPriceFunctionParams

  """column name"""
  editionPriceFunctionStartingPriceInLamports

  """column name"""
  editionPriceFunctionType

  """column name"""
  editionPublicSaleStartTime

  """column name"""
  id

  """column name"""
  isPnftDropActive

  """column name"""
  nftId

  """column name"""
  pnftIdForAuction

  """column name"""
  priceInLamports

  """column name"""
  scheduledAuctionTime

  """column name"""
  tickSizeConstantInLamports

  """column name"""
  timeCreated

  """column name"""
  timeExtensionDurationInSeconds

  """column name"""
  timeLastAuctionAlmostOverEmailSent

  """column name"""
  unlockableId
}

"""
A Relay connection object on "NftListing"
"""
type NftListingConnection {
  edges: [NftListingEdge!]!
  pageInfo: PageInfo!
}

type NftListingEdge {
  cursor: String!
  node: NftListing!
}

"""
columns and relationships of "NftMetadata"
"""
type NftMetadata implements Node {
  assetArweaveTxid: String
  assetHeight: Int
  assetWidth: Int
  contentType: String!
  creators(
    """JSON select path"""
    path: String
  ): jsonb
  description: String!
  editionNonce: Int
  id: ID!
  image: String!
  isMutable: Boolean!
  key: Int!
  mint: String!
  name: String!
  nonstandardAssetId: uuid
  sellerFeeBasisPoints: Int!
  symbol: String!
  timeCreated: timestamptz
  updateAuthority: String!
  uri: String!
  videoPlaybackId: String
  videoPreviewPlaybackId: String
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input NftMetadata_append_input {
  creators: jsonb
}

"""
Boolean expression to filter rows from the table "NftMetadata". All fields are combined with a logical 'AND'.
"""
input NftMetadata_bool_exp {
  _and: [NftMetadata_bool_exp!]
  _not: NftMetadata_bool_exp
  _or: [NftMetadata_bool_exp!]
  assetArweaveTxid: String_comparison_exp
  assetHeight: Int_comparison_exp
  assetWidth: Int_comparison_exp
  contentType: String_comparison_exp
  creators: jsonb_comparison_exp
  description: String_comparison_exp
  editionNonce: Int_comparison_exp
  id: String_comparison_exp
  image: String_comparison_exp
  isMutable: Boolean_comparison_exp
  key: Int_comparison_exp
  mint: String_comparison_exp
  name: String_comparison_exp
  nonstandardAssetId: uuid_comparison_exp
  sellerFeeBasisPoints: Int_comparison_exp
  symbol: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  updateAuthority: String_comparison_exp
  uri: String_comparison_exp
  videoPlaybackId: String_comparison_exp
  videoPreviewPlaybackId: String_comparison_exp
}

"""
unique or primary key constraints on table "NftMetadata"
"""
enum NftMetadata_constraint {
  """unique or primary key constraint"""
  NftMetadata_mint_key

  """unique or primary key constraint"""
  NftMetadata_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input NftMetadata_delete_at_path_input {
  creators: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input NftMetadata_delete_elem_input {
  creators: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input NftMetadata_delete_key_input {
  creators: String
}

"""
input type for incrementing numeric columns in table "NftMetadata"
"""
input NftMetadata_inc_input {
  assetHeight: Int
  assetWidth: Int
  editionNonce: Int
  key: Int
  sellerFeeBasisPoints: Int
}

"""
input type for inserting data into table "NftMetadata"
"""
input NftMetadata_insert_input {
  assetArweaveTxid: String
  assetHeight: Int
  assetWidth: Int
  contentType: String
  creators: jsonb
  description: String
  editionNonce: Int
  id: String
  image: String
  isMutable: Boolean
  key: Int
  mint: String
  name: String
  nonstandardAssetId: uuid
  sellerFeeBasisPoints: Int
  symbol: String
  timeCreated: timestamptz
  updateAuthority: String
  uri: String
  videoPlaybackId: String
  videoPreviewPlaybackId: String
}

"""
response of any mutation on the table "NftMetadata"
"""
type NftMetadata_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftMetadata!]!
}

"""
on_conflict condition type for table "NftMetadata"
"""
input NftMetadata_on_conflict {
  constraint: NftMetadata_constraint!
  update_columns: [NftMetadata_update_column!]! = []
  where: NftMetadata_bool_exp
}

"""Ordering options when selecting data from "NftMetadata"."""
input NftMetadata_order_by {
  assetArweaveTxid: order_by
  assetHeight: order_by
  assetWidth: order_by
  contentType: order_by
  creators: order_by
  description: order_by
  editionNonce: order_by
  id: order_by
  image: order_by
  isMutable: order_by
  key: order_by
  mint: order_by
  name: order_by
  nonstandardAssetId: order_by
  sellerFeeBasisPoints: order_by
  symbol: order_by
  timeCreated: order_by
  updateAuthority: order_by
  uri: order_by
  videoPlaybackId: order_by
  videoPreviewPlaybackId: order_by
}

"""primary key columns input for table: NftMetadata"""
input NftMetadata_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input NftMetadata_prepend_input {
  creators: jsonb
}

"""
select columns of table "NftMetadata"
"""
enum NftMetadata_select_column {
  """column name"""
  assetArweaveTxid

  """column name"""
  assetHeight

  """column name"""
  assetWidth

  """column name"""
  contentType

  """column name"""
  creators

  """column name"""
  description

  """column name"""
  editionNonce

  """column name"""
  id

  """column name"""
  image

  """column name"""
  isMutable

  """column name"""
  key

  """column name"""
  mint

  """column name"""
  name

  """column name"""
  nonstandardAssetId

  """column name"""
  sellerFeeBasisPoints

  """column name"""
  symbol

  """column name"""
  timeCreated

  """column name"""
  updateAuthority

  """column name"""
  uri

  """column name"""
  videoPlaybackId

  """column name"""
  videoPreviewPlaybackId
}

"""
input type for updating data in table "NftMetadata"
"""
input NftMetadata_set_input {
  assetArweaveTxid: String
  assetHeight: Int
  assetWidth: Int
  contentType: String
  creators: jsonb
  description: String
  editionNonce: Int
  id: String
  image: String
  isMutable: Boolean
  key: Int
  mint: String
  name: String
  nonstandardAssetId: uuid
  sellerFeeBasisPoints: Int
  symbol: String
  timeCreated: timestamptz
  updateAuthority: String
  uri: String
  videoPlaybackId: String
  videoPreviewPlaybackId: String
}

"""
update columns of table "NftMetadata"
"""
enum NftMetadata_update_column {
  """column name"""
  assetArweaveTxid

  """column name"""
  assetHeight

  """column name"""
  assetWidth

  """column name"""
  contentType

  """column name"""
  creators

  """column name"""
  description

  """column name"""
  editionNonce

  """column name"""
  id

  """column name"""
  image

  """column name"""
  isMutable

  """column name"""
  key

  """column name"""
  mint

  """column name"""
  name

  """column name"""
  nonstandardAssetId

  """column name"""
  sellerFeeBasisPoints

  """column name"""
  symbol

  """column name"""
  timeCreated

  """column name"""
  updateAuthority

  """column name"""
  uri

  """column name"""
  videoPlaybackId

  """column name"""
  videoPreviewPlaybackId
}

"""
A Relay connection object on "NftMetadata"
"""
type NftMetadataConnection {
  edges: [NftMetadataEdge!]!
  pageInfo: PageInfo!
}

type NftMetadataEdge {
  cursor: String!
  node: NftMetadata!
}

"""
columns and relationships of "NftStatus"
"""
type NftStatus implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "NftStatus". All fields are combined with a logical 'AND'.
"""
input NftStatus_bool_exp {
  _and: [NftStatus_bool_exp!]
  _not: NftStatus_bool_exp
  _or: [NftStatus_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "NftStatus"
"""
enum NftStatus_constraint {
  """unique or primary key constraint"""
  NftStatus_pkey
}

enum NftStatus_enum {
  AirdropCompleted
  AirdropInProgress
  Auction
  Burned
  Listed
  ListedEditions
  ListedInstantSale
  ListingScheduled
  Owned
  OwnedStoppedMintingForEditions
  SoldOutEditions
}

"""
Boolean expression to compare columns of type "NftStatus_enum". All fields are combined with logical 'AND'.
"""
input NftStatus_enum_comparison_exp {
  _eq: NftStatus_enum
  _in: [NftStatus_enum!]
  _is_null: Boolean
  _neq: NftStatus_enum
  _nin: [NftStatus_enum!]
}

"""
input type for inserting data into table "NftStatus"
"""
input NftStatus_insert_input {
  value: String
}

"""
response of any mutation on the table "NftStatus"
"""
type NftStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftStatus!]!
}

"""
on_conflict condition type for table "NftStatus"
"""
input NftStatus_on_conflict {
  constraint: NftStatus_constraint!
  update_columns: [NftStatus_update_column!]! = []
  where: NftStatus_bool_exp
}

"""Ordering options when selecting data from "NftStatus"."""
input NftStatus_order_by {
  value: order_by
}

"""primary key columns input for table: NftStatus"""
input NftStatus_pk_columns_input {
  value: String!
}

"""
select columns of table "NftStatus"
"""
enum NftStatus_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "NftStatus"
"""
input NftStatus_set_input {
  value: String
}

"""
update columns of table "NftStatus"
"""
enum NftStatus_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "NftStatus"
"""
type NftStatusConnection {
  edges: [NftStatusEdge!]!
  pageInfo: PageInfo!
}

type NftStatusEdge {
  cursor: String!
  node: NftStatus!
}

"""Mapping of NFTs to metadata attribute objects"""
type NftToAttribute implements Node {
  """An object relationship"""
  Attribute: Attribute!

  """An object relationship"""
  Nft: Nft!
  attributeId: uuid!
  id: ID!
  nftId: String!
  rarityBasisPoints: Int
  seriesId: String
}

"""
Boolean expression to filter rows from the table "NftToAttribute". All fields are combined with a logical 'AND'.
"""
input NftToAttribute_bool_exp {
  Attribute: Attribute_bool_exp
  Nft: Nft_bool_exp
  _and: [NftToAttribute_bool_exp!]
  _not: NftToAttribute_bool_exp
  _or: [NftToAttribute_bool_exp!]
  attributeId: uuid_comparison_exp
  id: uuid_comparison_exp
  nftId: String_comparison_exp
  rarityBasisPoints: Int_comparison_exp
  seriesId: String_comparison_exp
}

"""
unique or primary key constraints on table "NftToAttribute"
"""
enum NftToAttribute_constraint {
  """unique or primary key constraint"""
  NftToAttribute_id_key

  """unique or primary key constraint"""
  NftToAttribute_pkey
}

"""
input type for incrementing numeric columns in table "NftToAttribute"
"""
input NftToAttribute_inc_input {
  rarityBasisPoints: Int
}

"""
input type for inserting data into table "NftToAttribute"
"""
input NftToAttribute_insert_input {
  Attribute: Attribute_obj_rel_insert_input
  Nft: Nft_obj_rel_insert_input
  attributeId: uuid
  id: uuid
  nftId: String
  rarityBasisPoints: Int
  seriesId: String
}

"""
response of any mutation on the table "NftToAttribute"
"""
type NftToAttribute_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftToAttribute!]!
}

"""
on_conflict condition type for table "NftToAttribute"
"""
input NftToAttribute_on_conflict {
  constraint: NftToAttribute_constraint!
  update_columns: [NftToAttribute_update_column!]! = []
  where: NftToAttribute_bool_exp
}

"""Ordering options when selecting data from "NftToAttribute"."""
input NftToAttribute_order_by {
  Attribute: Attribute_order_by
  Nft: Nft_order_by
  attributeId: order_by
  id: order_by
  nftId: order_by
  rarityBasisPoints: order_by
  seriesId: order_by
}

"""primary key columns input for table: NftToAttribute"""
input NftToAttribute_pk_columns_input {
  attributeId: uuid!
  nftId: String!
}

"""
select columns of table "NftToAttribute"
"""
enum NftToAttribute_select_column {
  """column name"""
  attributeId

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  rarityBasisPoints

  """column name"""
  seriesId
}

"""
input type for updating data in table "NftToAttribute"
"""
input NftToAttribute_set_input {
  attributeId: uuid
  id: uuid
  nftId: String
  rarityBasisPoints: Int
  seriesId: String
}

"""
update columns of table "NftToAttribute"
"""
enum NftToAttribute_update_column {
  """column name"""
  attributeId

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  rarityBasisPoints

  """column name"""
  seriesId
}

"""
A Relay connection object on "NftToAttribute"
"""
type NftToAttributeConnection {
  edges: [NftToAttributeEdge!]!
  pageInfo: PageInfo!
}

type NftToAttributeEdge {
  cursor: String!
  node: NftToAttribute!
}

"""
An NFT may have multiple "creators," with whom primary and secondary sales are split. We call these people "collaborators".
"""
type NftToCollaborator implements Node {
  """An object relationship"""
  Request: Request
  collaboratorId: String!
  id: ID!
  nftId: String!
  requestId: uuid
  share: Int!
  timeCreated: timestamptz!
}

"""
Boolean expression to filter rows from the table "NftToCollaborator". All fields are combined with a logical 'AND'.
"""
input NftToCollaborator_bool_exp {
  Request: Request_bool_exp
  _and: [NftToCollaborator_bool_exp!]
  _not: NftToCollaborator_bool_exp
  _or: [NftToCollaborator_bool_exp!]
  collaboratorId: String_comparison_exp
  id: uuid_comparison_exp
  nftId: String_comparison_exp
  requestId: uuid_comparison_exp
  share: Int_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "NftToCollaborator"
"""
enum NftToCollaborator_constraint {
  """unique or primary key constraint"""
  NftToCollaborator_collaboratorId_nftId_key

  """unique or primary key constraint"""
  NftToCollaborator_id_key

  """unique or primary key constraint"""
  NftToCollaborator_pkey

  """unique or primary key constraint"""
  NftToCollaborator_requestId_key
}

"""
input type for incrementing numeric columns in table "NftToCollaborator"
"""
input NftToCollaborator_inc_input {
  share: Int
}

"""
input type for inserting data into table "NftToCollaborator"
"""
input NftToCollaborator_insert_input {
  Request: Request_obj_rel_insert_input
  collaboratorId: String
  id: uuid
  nftId: String
  requestId: uuid
  share: Int
  timeCreated: timestamptz
}

"""
response of any mutation on the table "NftToCollaborator"
"""
type NftToCollaborator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftToCollaborator!]!
}

"""
on_conflict condition type for table "NftToCollaborator"
"""
input NftToCollaborator_on_conflict {
  constraint: NftToCollaborator_constraint!
  update_columns: [NftToCollaborator_update_column!]! = []
  where: NftToCollaborator_bool_exp
}

"""Ordering options when selecting data from "NftToCollaborator"."""
input NftToCollaborator_order_by {
  Request: Request_order_by
  collaboratorId: order_by
  id: order_by
  nftId: order_by
  requestId: order_by
  share: order_by
  timeCreated: order_by
}

"""primary key columns input for table: NftToCollaborator"""
input NftToCollaborator_pk_columns_input {
  collaboratorId: String!
  nftId: String!
}

"""
select columns of table "NftToCollaborator"
"""
enum NftToCollaborator_select_column {
  """column name"""
  collaboratorId

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  requestId

  """column name"""
  share

  """column name"""
  timeCreated
}

"""
input type for updating data in table "NftToCollaborator"
"""
input NftToCollaborator_set_input {
  collaboratorId: String
  id: uuid
  nftId: String
  requestId: uuid
  share: Int
  timeCreated: timestamptz
}

"""
update columns of table "NftToCollaborator"
"""
enum NftToCollaborator_update_column {
  """column name"""
  collaboratorId

  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  requestId

  """column name"""
  share

  """column name"""
  timeCreated
}

"""
A Relay connection object on "NftToCollaborator"
"""
type NftToCollaboratorConnection {
  edges: [NftToCollaboratorEdge!]!
  pageInfo: PageInfo!
}

type NftToCollaboratorEdge {
  cursor: String!
  node: NftToCollaborator!
}

"""
columns and relationships of "NftToTag"
"""
type NftToTag implements Node {
  """An object relationship"""
  Nft: Nft!

  """An object relationship"""
  Tag: Tag!
  id: ID!
  nftId: String!
  tagId: uuid!
}

"""
Boolean expression to filter rows from the table "NftToTag". All fields are combined with a logical 'AND'.
"""
input NftToTag_bool_exp {
  Nft: Nft_bool_exp
  Tag: Tag_bool_exp
  _and: [NftToTag_bool_exp!]
  _not: NftToTag_bool_exp
  _or: [NftToTag_bool_exp!]
  id: uuid_comparison_exp
  nftId: String_comparison_exp
  tagId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "NftToTag"
"""
enum NftToTag_constraint {
  """unique or primary key constraint"""
  NftToTag_id_key

  """unique or primary key constraint"""
  NftToTag_pkey
}

"""
input type for inserting data into table "NftToTag"
"""
input NftToTag_insert_input {
  Nft: Nft_obj_rel_insert_input
  Tag: Tag_obj_rel_insert_input
  id: uuid
  nftId: String
  tagId: uuid
}

"""
response of any mutation on the table "NftToTag"
"""
type NftToTag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftToTag!]!
}

"""
on_conflict condition type for table "NftToTag"
"""
input NftToTag_on_conflict {
  constraint: NftToTag_constraint!
  update_columns: [NftToTag_update_column!]! = []
  where: NftToTag_bool_exp
}

"""Ordering options when selecting data from "NftToTag"."""
input NftToTag_order_by {
  Nft: Nft_order_by
  Tag: Tag_order_by
  id: order_by
  nftId: order_by
  tagId: order_by
}

"""primary key columns input for table: NftToTag"""
input NftToTag_pk_columns_input {
  nftId: String!
  tagId: uuid!
}

"""
select columns of table "NftToTag"
"""
enum NftToTag_select_column {
  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  tagId
}

"""
input type for updating data in table "NftToTag"
"""
input NftToTag_set_input {
  id: uuid
  nftId: String
  tagId: uuid
}

"""
update columns of table "NftToTag"
"""
enum NftToTag_update_column {
  """column name"""
  id

  """column name"""
  nftId

  """column name"""
  tagId
}

"""
A Relay connection object on "NftToTag"
"""
type NftToTagConnection {
  edges: [NftToTagEdge!]!
  pageInfo: PageInfo!
}

type NftToTagEdge {
  cursor: String!
  node: NftToTag!
}

"""
columns and relationships of "NftTransaction"
"""
type NftTransaction implements Node {
  """An object relationship"""
  Creator: User!

  """An object relationship"""
  From: User!

  """An object relationship"""
  Nft: Nft!

  """An object relationship"""
  To: User!
  auctionCount: Int!
  comment: String
  creatorId: String!
  currencyId: uuid!
  fromUserId: String!
  id: ID!
  isCrossmint: Boolean!
  ixIndex: Int!
  ixInnerIndex: Int!
  mint: String!
  price: bigint
  source: NftTransactionSource_enum
  timeCreated: timestamptz!
  toUserId: String!
  txSizeInBytes: Int
  txVersion: String
  txid: String
  type: NftTransactionType_enum!
  usdPrice: numeric
}

"""
Boolean expression to filter rows from the table "NftTransaction". All fields are combined with a logical 'AND'.
"""
input NftTransaction_bool_exp {
  Creator: User_bool_exp
  From: User_bool_exp
  Nft: Nft_bool_exp
  To: User_bool_exp
  _and: [NftTransaction_bool_exp!]
  _not: NftTransaction_bool_exp
  _or: [NftTransaction_bool_exp!]
  auctionCount: Int_comparison_exp
  comment: String_comparison_exp
  creatorId: String_comparison_exp
  currencyId: uuid_comparison_exp
  fromUserId: String_comparison_exp
  id: uuid_comparison_exp
  isCrossmint: Boolean_comparison_exp
  ixIndex: Int_comparison_exp
  ixInnerIndex: Int_comparison_exp
  mint: String_comparison_exp
  price: bigint_comparison_exp
  source: NftTransactionSource_enum_comparison_exp
  timeCreated: timestamptz_comparison_exp
  toUserId: String_comparison_exp
  txSizeInBytes: Int_comparison_exp
  txVersion: String_comparison_exp
  txid: String_comparison_exp
  type: NftTransactionType_enum_comparison_exp
  usdPrice: numeric_comparison_exp
}

"""
unique or primary key constraints on table "NftTransaction"
"""
enum NftTransaction_constraint {
  """unique or primary key constraint"""
  NftTransaction_pkey

  """unique or primary key constraint"""
  NftTransaction_txid_ixIndex_ixInnerIndex_key
}

"""
input type for incrementing numeric columns in table "NftTransaction"
"""
input NftTransaction_inc_input {
  auctionCount: Int
  ixIndex: Int
  ixInnerIndex: Int
  price: bigint
  txSizeInBytes: Int
  usdPrice: numeric
}

"""
input type for inserting data into table "NftTransaction"
"""
input NftTransaction_insert_input {
  Creator: User_obj_rel_insert_input
  From: User_obj_rel_insert_input
  Nft: Nft_obj_rel_insert_input
  To: User_obj_rel_insert_input
  auctionCount: Int
  comment: String
  creatorId: String
  currencyId: uuid
  fromUserId: String
  id: uuid
  isCrossmint: Boolean
  ixIndex: Int
  ixInnerIndex: Int
  mint: String
  price: bigint
  source: NftTransactionSource_enum
  timeCreated: timestamptz
  toUserId: String
  txSizeInBytes: Int
  txVersion: String
  txid: String
  type: NftTransactionType_enum
  usdPrice: numeric
}

"""
response of any mutation on the table "NftTransaction"
"""
type NftTransaction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftTransaction!]!
}

"""
input type for inserting object relation for remote table "NftTransaction"
"""
input NftTransaction_obj_rel_insert_input {
  data: NftTransaction_insert_input!

  """upsert condition"""
  on_conflict: NftTransaction_on_conflict
}

"""
on_conflict condition type for table "NftTransaction"
"""
input NftTransaction_on_conflict {
  constraint: NftTransaction_constraint!
  update_columns: [NftTransaction_update_column!]! = []
  where: NftTransaction_bool_exp
}

"""Ordering options when selecting data from "NftTransaction"."""
input NftTransaction_order_by {
  Creator: User_order_by
  From: User_order_by
  Nft: Nft_order_by
  To: User_order_by
  auctionCount: order_by
  comment: order_by
  creatorId: order_by
  currencyId: order_by
  fromUserId: order_by
  id: order_by
  isCrossmint: order_by
  ixIndex: order_by
  ixInnerIndex: order_by
  mint: order_by
  price: order_by
  source: order_by
  timeCreated: order_by
  toUserId: order_by
  txSizeInBytes: order_by
  txVersion: order_by
  txid: order_by
  type: order_by
  usdPrice: order_by
}

"""primary key columns input for table: NftTransaction"""
input NftTransaction_pk_columns_input {
  id: uuid!
}

"""
select columns of table "NftTransaction"
"""
enum NftTransaction_select_column {
  """column name"""
  auctionCount

  """column name"""
  comment

  """column name"""
  creatorId

  """column name"""
  currencyId

  """column name"""
  fromUserId

  """column name"""
  id

  """column name"""
  isCrossmint

  """column name"""
  ixIndex

  """column name"""
  ixInnerIndex

  """column name"""
  mint

  """column name"""
  price

  """column name"""
  source

  """column name"""
  timeCreated

  """column name"""
  toUserId

  """column name"""
  txSizeInBytes

  """column name"""
  txVersion

  """column name"""
  txid

  """column name"""
  type

  """column name"""
  usdPrice
}

"""
input type for updating data in table "NftTransaction"
"""
input NftTransaction_set_input {
  auctionCount: Int
  comment: String
  creatorId: String
  currencyId: uuid
  fromUserId: String
  id: uuid
  isCrossmint: Boolean
  ixIndex: Int
  ixInnerIndex: Int
  mint: String
  price: bigint
  source: NftTransactionSource_enum
  timeCreated: timestamptz
  toUserId: String
  txSizeInBytes: Int
  txVersion: String
  txid: String
  type: NftTransactionType_enum
  usdPrice: numeric
}

"""
update columns of table "NftTransaction"
"""
enum NftTransaction_update_column {
  """column name"""
  auctionCount

  """column name"""
  comment

  """column name"""
  creatorId

  """column name"""
  currencyId

  """column name"""
  fromUserId

  """column name"""
  id

  """column name"""
  isCrossmint

  """column name"""
  ixIndex

  """column name"""
  ixInnerIndex

  """column name"""
  mint

  """column name"""
  price

  """column name"""
  source

  """column name"""
  timeCreated

  """column name"""
  toUserId

  """column name"""
  txSizeInBytes

  """column name"""
  txVersion

  """column name"""
  txid

  """column name"""
  type

  """column name"""
  usdPrice
}

"""
A Relay connection object on "NftTransaction"
"""
type NftTransactionConnection {
  edges: [NftTransactionEdge!]!
  pageInfo: PageInfo!
}

type NftTransactionEdge {
  cursor: String!
  node: NftTransaction!
}

"""
columns and relationships of "NftTransactionRaw"
"""
type NftTransactionRaw implements Node {
  extraData: String
  id: ID!
  mint: String!
  timeCreated: timestamptz!
  txid: String!
  type: String
}

"""
Boolean expression to filter rows from the table "NftTransactionRaw". All fields are combined with a logical 'AND'.
"""
input NftTransactionRaw_bool_exp {
  _and: [NftTransactionRaw_bool_exp!]
  _not: NftTransactionRaw_bool_exp
  _or: [NftTransactionRaw_bool_exp!]
  extraData: String_comparison_exp
  id: uuid_comparison_exp
  mint: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  txid: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "NftTransactionRaw"
"""
enum NftTransactionRaw_constraint {
  """unique or primary key constraint"""
  NftTransactionRaw_id_key

  """unique or primary key constraint"""
  NftTransactionRaw_pkey
}

"""
input type for inserting data into table "NftTransactionRaw"
"""
input NftTransactionRaw_insert_input {
  extraData: String
  id: uuid
  mint: String
  timeCreated: timestamptz
  txid: String
  type: String
}

"""
response of any mutation on the table "NftTransactionRaw"
"""
type NftTransactionRaw_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftTransactionRaw!]!
}

"""
on_conflict condition type for table "NftTransactionRaw"
"""
input NftTransactionRaw_on_conflict {
  constraint: NftTransactionRaw_constraint!
  update_columns: [NftTransactionRaw_update_column!]! = []
  where: NftTransactionRaw_bool_exp
}

"""Ordering options when selecting data from "NftTransactionRaw"."""
input NftTransactionRaw_order_by {
  extraData: order_by
  id: order_by
  mint: order_by
  timeCreated: order_by
  txid: order_by
  type: order_by
}

"""primary key columns input for table: NftTransactionRaw"""
input NftTransactionRaw_pk_columns_input {
  txid: String!
}

"""
select columns of table "NftTransactionRaw"
"""
enum NftTransactionRaw_select_column {
  """column name"""
  extraData

  """column name"""
  id

  """column name"""
  mint

  """column name"""
  timeCreated

  """column name"""
  txid

  """column name"""
  type
}

"""
input type for updating data in table "NftTransactionRaw"
"""
input NftTransactionRaw_set_input {
  extraData: String
  id: uuid
  mint: String
  timeCreated: timestamptz
  txid: String
  type: String
}

"""
update columns of table "NftTransactionRaw"
"""
enum NftTransactionRaw_update_column {
  """column name"""
  extraData

  """column name"""
  id

  """column name"""
  mint

  """column name"""
  timeCreated

  """column name"""
  txid

  """column name"""
  type
}

"""
A Relay connection object on "NftTransactionRaw"
"""
type NftTransactionRawConnection {
  edges: [NftTransactionRawEdge!]!
  pageInfo: PageInfo!
}

type NftTransactionRawEdge {
  cursor: String!
  node: NftTransactionRaw!
}

"""For imported transactions"""
type NftTransactionSource implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "NftTransactionSource". All fields are combined with a logical 'AND'.
"""
input NftTransactionSource_bool_exp {
  _and: [NftTransactionSource_bool_exp!]
  _not: NftTransactionSource_bool_exp
  _or: [NftTransactionSource_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "NftTransactionSource"
"""
enum NftTransactionSource_constraint {
  """unique or primary key constraint"""
  NftTransactionSource_pkey
}

enum NftTransactionSource_enum {
  ExchangeArt
  Holaplex
}

"""
Boolean expression to compare columns of type "NftTransactionSource_enum". All fields are combined with logical 'AND'.
"""
input NftTransactionSource_enum_comparison_exp {
  _eq: NftTransactionSource_enum
  _in: [NftTransactionSource_enum!]
  _is_null: Boolean
  _neq: NftTransactionSource_enum
  _nin: [NftTransactionSource_enum!]
}

"""
input type for inserting data into table "NftTransactionSource"
"""
input NftTransactionSource_insert_input {
  value: String
}

"""
response of any mutation on the table "NftTransactionSource"
"""
type NftTransactionSource_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftTransactionSource!]!
}

"""
on_conflict condition type for table "NftTransactionSource"
"""
input NftTransactionSource_on_conflict {
  constraint: NftTransactionSource_constraint!
  update_columns: [NftTransactionSource_update_column!]! = []
  where: NftTransactionSource_bool_exp
}

"""Ordering options when selecting data from "NftTransactionSource"."""
input NftTransactionSource_order_by {
  value: order_by
}

"""primary key columns input for table: NftTransactionSource"""
input NftTransactionSource_pk_columns_input {
  value: String!
}

"""
select columns of table "NftTransactionSource"
"""
enum NftTransactionSource_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "NftTransactionSource"
"""
input NftTransactionSource_set_input {
  value: String
}

"""
update columns of table "NftTransactionSource"
"""
enum NftTransactionSource_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "NftTransactionSource"
"""
type NftTransactionSourceConnection {
  edges: [NftTransactionSourceEdge!]!
  pageInfo: PageInfo!
}

type NftTransactionSourceEdge {
  cursor: String!
  node: NftTransactionSource!
}

"""
columns and relationships of "NftTransactionType"
"""
type NftTransactionType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "NftTransactionType". All fields are combined with a logical 'AND'.
"""
input NftTransactionType_bool_exp {
  _and: [NftTransactionType_bool_exp!]
  _not: NftTransactionType_bool_exp
  _or: [NftTransactionType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "NftTransactionType"
"""
enum NftTransactionType_constraint {
  """unique or primary key constraint"""
  NftTransactionType_pkey
}

enum NftTransactionType_enum {
  AuctionWon
  Bid
  Burned
  ChangePriceForEditions
  ClaimedPnft
  Imported
  Listed
  ListedEditions
  ListedInstantSale
  ListingCancelled
  Minted
  Offer
  Refunded
  Sold
  SoldAcceptedOffer
  SoldEditionPrimary
  SoldGenerativeMint
  SoldInstantSale
  StoppedMintingForEditions
  Transferred
}

"""
Boolean expression to compare columns of type "NftTransactionType_enum". All fields are combined with logical 'AND'.
"""
input NftTransactionType_enum_comparison_exp {
  _eq: NftTransactionType_enum
  _in: [NftTransactionType_enum!]
  _is_null: Boolean
  _neq: NftTransactionType_enum
  _nin: [NftTransactionType_enum!]
}

"""
input type for inserting data into table "NftTransactionType"
"""
input NftTransactionType_insert_input {
  value: String
}

"""
response of any mutation on the table "NftTransactionType"
"""
type NftTransactionType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NftTransactionType!]!
}

"""
on_conflict condition type for table "NftTransactionType"
"""
input NftTransactionType_on_conflict {
  constraint: NftTransactionType_constraint!
  update_columns: [NftTransactionType_update_column!]! = []
  where: NftTransactionType_bool_exp
}

"""Ordering options when selecting data from "NftTransactionType"."""
input NftTransactionType_order_by {
  value: order_by
}

"""primary key columns input for table: NftTransactionType"""
input NftTransactionType_pk_columns_input {
  value: String!
}

"""
select columns of table "NftTransactionType"
"""
enum NftTransactionType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "NftTransactionType"
"""
input NftTransactionType_set_input {
  value: String
}

"""
update columns of table "NftTransactionType"
"""
enum NftTransactionType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "NftTransactionType"
"""
type NftTransactionTypeConnection {
  edges: [NftTransactionTypeEdge!]!
  pageInfo: PageInfo!
}

type NftTransactionTypeEdge {
  cursor: String!
  node: NftTransactionType!
}

"""An object with globally unique ID"""
interface Node {
  """A globally unique identifier"""
  id: ID!
}

"""A persistent log of all notifications that we want to send."""
type Notification implements Node {
  data(
    """JSON select path"""
    path: String
  ): jsonb!
  id: ID!
  receiver: String
  sender: String
  timeCreated: timestamptz!
  type: NotificationType_enum!
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input Notification_append_input {
  data: jsonb
}

"""
Boolean expression to filter rows from the table "Notification". All fields are combined with a logical 'AND'.
"""
input Notification_bool_exp {
  _and: [Notification_bool_exp!]
  _not: Notification_bool_exp
  _or: [Notification_bool_exp!]
  data: jsonb_comparison_exp
  id: uuid_comparison_exp
  receiver: String_comparison_exp
  sender: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  type: NotificationType_enum_comparison_exp
}

"""
unique or primary key constraints on table "Notification"
"""
enum Notification_constraint {
  """unique or primary key constraint"""
  Notification_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Notification_delete_at_path_input {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input Notification_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Notification_delete_key_input {
  data: String
}

"""
input type for inserting data into table "Notification"
"""
input Notification_insert_input {
  data: jsonb
  id: uuid
  receiver: String
  sender: String
  timeCreated: timestamptz
  type: NotificationType_enum
}

"""
response of any mutation on the table "Notification"
"""
type Notification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Notification!]!
}

"""
input type for inserting object relation for remote table "Notification"
"""
input Notification_obj_rel_insert_input {
  data: Notification_insert_input!

  """upsert condition"""
  on_conflict: Notification_on_conflict
}

"""
on_conflict condition type for table "Notification"
"""
input Notification_on_conflict {
  constraint: Notification_constraint!
  update_columns: [Notification_update_column!]! = []
  where: Notification_bool_exp
}

"""Ordering options when selecting data from "Notification"."""
input Notification_order_by {
  data: order_by
  id: order_by
  receiver: order_by
  sender: order_by
  timeCreated: order_by
  type: order_by
}

"""primary key columns input for table: Notification"""
input Notification_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input Notification_prepend_input {
  data: jsonb
}

"""
select columns of table "Notification"
"""
enum Notification_select_column {
  """column name"""
  data

  """column name"""
  id

  """column name"""
  receiver

  """column name"""
  sender

  """column name"""
  timeCreated

  """column name"""
  type
}

"""
input type for updating data in table "Notification"
"""
input Notification_set_input {
  data: jsonb
  id: uuid
  receiver: String
  sender: String
  timeCreated: timestamptz
  type: NotificationType_enum
}

"""
update columns of table "Notification"
"""
enum Notification_update_column {
  """column name"""
  data

  """column name"""
  id

  """column name"""
  receiver

  """column name"""
  sender

  """column name"""
  timeCreated

  """column name"""
  type
}

"""
columns and relationships of "NotificationChannel"
"""
type NotificationChannel implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "NotificationChannel". All fields are combined with a logical 'AND'.
"""
input NotificationChannel_bool_exp {
  _and: [NotificationChannel_bool_exp!]
  _not: NotificationChannel_bool_exp
  _or: [NotificationChannel_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "NotificationChannel"
"""
enum NotificationChannel_constraint {
  """unique or primary key constraint"""
  NotificationChannel_pkey
}

enum NotificationChannel_enum {
  ActivityFeed
  Email
}

"""
Boolean expression to compare columns of type "NotificationChannel_enum". All fields are combined with logical 'AND'.
"""
input NotificationChannel_enum_comparison_exp {
  _eq: NotificationChannel_enum
  _in: [NotificationChannel_enum!]
  _is_null: Boolean
  _neq: NotificationChannel_enum
  _nin: [NotificationChannel_enum!]
}

"""
input type for inserting data into table "NotificationChannel"
"""
input NotificationChannel_insert_input {
  value: String
}

"""
response of any mutation on the table "NotificationChannel"
"""
type NotificationChannel_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NotificationChannel!]!
}

"""
on_conflict condition type for table "NotificationChannel"
"""
input NotificationChannel_on_conflict {
  constraint: NotificationChannel_constraint!
  update_columns: [NotificationChannel_update_column!]! = []
  where: NotificationChannel_bool_exp
}

"""Ordering options when selecting data from "NotificationChannel"."""
input NotificationChannel_order_by {
  value: order_by
}

"""primary key columns input for table: NotificationChannel"""
input NotificationChannel_pk_columns_input {
  value: String!
}

"""
select columns of table "NotificationChannel"
"""
enum NotificationChannel_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "NotificationChannel"
"""
input NotificationChannel_set_input {
  value: String
}

"""
update columns of table "NotificationChannel"
"""
enum NotificationChannel_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "NotificationChannel"
"""
type NotificationChannelConnection {
  edges: [NotificationChannelEdge!]!
  pageInfo: PageInfo!
}

type NotificationChannelEdge {
  cursor: String!
  node: NotificationChannel!
}

"""
A Relay connection object on "Notification"
"""
type NotificationConnection {
  edges: [NotificationEdge!]!
  pageInfo: PageInfo!
}

type NotificationEdge {
  cursor: String!
  node: Notification!
}

"""
columns and relationships of "NotificationType"
"""
type NotificationType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "NotificationType". All fields are combined with a logical 'AND'.
"""
input NotificationType_bool_exp {
  _and: [NotificationType_bool_exp!]
  _not: NotificationType_bool_exp
  _or: [NotificationType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "NotificationType"
"""
enum NotificationType_constraint {
  """unique or primary key constraint"""
  NotificationType_pkey
}

enum NotificationType_enum {
  AirdropCompleted
  AirdropGiftReceived
  BidderAuctionAlmostOver
  BidderAuctionExtended
  BidderAuctionSettled
  BidderClaimPnft
  BidderClaimPnftReminder
  BidderLostAuction
  BidderOutbid
  BidderWonAuction
  BonkClaim
  BuyerOfferAccepted
  BuyerOfferExpired
  CampaignAddedAsTeamMember
  CampaignApproved
  CampaignCommunityNewUpdateShared
  CampaignFollowersCampaignPublished
  CampaignGoalReachedXPercent
  CampaignRejected
  CampaignRejectedWithFeedback
  CollabRequest
  CreatorSecondarySale
  FollowerAuctionAlmostOver
  FollowerNewEditionsListed
  FollowerNewPieceListed
  FollowerNewPieceListedSecondary
  FollowerNewPieceScheduled
  FollowerScheduledAuctionIsLive
  InviteReceived
  InvitesConvertedToCreator
  InvitesInviteeAcceptedInvite
  NewFollower
  OwnerAuctionEnded
  OwnerAuctionEndedNoBids
  OwnerAuctionExtended
  OwnerAuctionSettled
  OwnerEditionSold
  OwnerEditionsSoldOut
  OwnerFirstBidReceived
  OwnerGenerativeMintSoldOut
  OwnerOfferReceived
  OwnerOtherBidReceived
  OwnerPieceSoldAsInstantSale
  PnftDropClosed
  UnlockableDeclinedToSharedInfo
  UnlockableInfoShared
  UnlockableShareInfo
  VotingApproved
  VotingBrokeGuidelines
  VotingDuplicate
  VotingRejected
}

"""
Boolean expression to compare columns of type "NotificationType_enum". All fields are combined with logical 'AND'.
"""
input NotificationType_enum_comparison_exp {
  _eq: NotificationType_enum
  _in: [NotificationType_enum!]
  _is_null: Boolean
  _neq: NotificationType_enum
  _nin: [NotificationType_enum!]
}

"""
input type for inserting data into table "NotificationType"
"""
input NotificationType_insert_input {
  value: String
}

"""
response of any mutation on the table "NotificationType"
"""
type NotificationType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NotificationType!]!
}

"""
on_conflict condition type for table "NotificationType"
"""
input NotificationType_on_conflict {
  constraint: NotificationType_constraint!
  update_columns: [NotificationType_update_column!]! = []
  where: NotificationType_bool_exp
}

"""Ordering options when selecting data from "NotificationType"."""
input NotificationType_order_by {
  value: order_by
}

"""primary key columns input for table: NotificationType"""
input NotificationType_pk_columns_input {
  value: String!
}

"""
select columns of table "NotificationType"
"""
enum NotificationType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "NotificationType"
"""
input NotificationType_set_input {
  value: String
}

"""
update columns of table "NotificationType"
"""
enum NotificationType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "NotificationType"
"""
type NotificationTypeConnection {
  edges: [NotificationTypeEdge!]!
  pageInfo: PageInfo!
}

type NotificationTypeEdge {
  cursor: String!
  node: NotificationType!
}

"""
If a row does not exist for a specific
userId/notificationType/notificationChannel combo, it means that the
notification is enabled for that user and channel.
"""
type NotificationUserPreference implements Node {
  enabled: Boolean!
  id: ID!
  notificationChannel: NotificationChannel_enum!
  notificationType: NotificationType_enum!
  userId: String!
}

"""
Boolean expression to filter rows from the table "NotificationUserPreference". All fields are combined with a logical 'AND'.
"""
input NotificationUserPreference_bool_exp {
  _and: [NotificationUserPreference_bool_exp!]
  _not: NotificationUserPreference_bool_exp
  _or: [NotificationUserPreference_bool_exp!]
  enabled: Boolean_comparison_exp
  id: uuid_comparison_exp
  notificationChannel: NotificationChannel_enum_comparison_exp
  notificationType: NotificationType_enum_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "NotificationUserPreference"
"""
enum NotificationUserPreference_constraint {
  """unique or primary key constraint"""
  NotificationUserPreference_id_key

  """unique or primary key constraint"""
  NotificationUserPreference_pkey
}

"""
input type for inserting data into table "NotificationUserPreference"
"""
input NotificationUserPreference_insert_input {
  enabled: Boolean
  id: uuid
  notificationChannel: NotificationChannel_enum
  notificationType: NotificationType_enum
  userId: String
}

"""
response of any mutation on the table "NotificationUserPreference"
"""
type NotificationUserPreference_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [NotificationUserPreference!]!
}

"""
on_conflict condition type for table "NotificationUserPreference"
"""
input NotificationUserPreference_on_conflict {
  constraint: NotificationUserPreference_constraint!
  update_columns: [NotificationUserPreference_update_column!]! = []
  where: NotificationUserPreference_bool_exp
}

"""
Ordering options when selecting data from "NotificationUserPreference".
"""
input NotificationUserPreference_order_by {
  enabled: order_by
  id: order_by
  notificationChannel: order_by
  notificationType: order_by
  userId: order_by
}

"""primary key columns input for table: NotificationUserPreference"""
input NotificationUserPreference_pk_columns_input {
  notificationChannel: NotificationChannel_enum!
  notificationType: NotificationType_enum!
  userId: String!
}

"""
select columns of table "NotificationUserPreference"
"""
enum NotificationUserPreference_select_column {
  """column name"""
  enabled

  """column name"""
  id

  """column name"""
  notificationChannel

  """column name"""
  notificationType

  """column name"""
  userId
}

"""
input type for updating data in table "NotificationUserPreference"
"""
input NotificationUserPreference_set_input {
  enabled: Boolean
  id: uuid
  notificationChannel: NotificationChannel_enum
  notificationType: NotificationType_enum
  userId: String
}

"""
update columns of table "NotificationUserPreference"
"""
enum NotificationUserPreference_update_column {
  """column name"""
  enabled

  """column name"""
  id

  """column name"""
  notificationChannel

  """column name"""
  notificationType

  """column name"""
  userId
}

"""
A Relay connection object on "NotificationUserPreference"
"""
type NotificationUserPreferenceConnection {
  edges: [NotificationUserPreferenceEdge!]!
  pageInfo: PageInfo!
}

type NotificationUserPreferenceEdge {
  cursor: String!
  node: NotificationUserPreference!
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
columns and relationships of "Offer"
"""
type Offer implements Node {
  expirationDate: timestamptz!
  id: ID!
  mint: String!
  nftTransactionId: uuid!
  refundTxid: String
  saleTransactionId: uuid
  timeCreated: timestamptz!
  userId: String!
}

"""
Boolean expression to filter rows from the table "Offer". All fields are combined with a logical 'AND'.
"""
input Offer_bool_exp {
  _and: [Offer_bool_exp!]
  _not: Offer_bool_exp
  _or: [Offer_bool_exp!]
  expirationDate: timestamptz_comparison_exp
  id: uuid_comparison_exp
  mint: String_comparison_exp
  nftTransactionId: uuid_comparison_exp
  refundTxid: String_comparison_exp
  saleTransactionId: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "Offer"
"""
enum Offer_constraint {
  """unique or primary key constraint"""
  Offer_id_key

  """unique or primary key constraint"""
  Offer_nftTransactionId_key

  """unique or primary key constraint"""
  Offer_pkey

  """unique or primary key constraint"""
  Offer_refundTxid_key

  """unique or primary key constraint"""
  Offer_saleTransactionId_key
}

"""
input type for inserting data into table "Offer"
"""
input Offer_insert_input {
  expirationDate: timestamptz
  id: uuid
  mint: String
  nftTransactionId: uuid
  refundTxid: String
  saleTransactionId: uuid
  timeCreated: timestamptz
  userId: String
}

"""
response of any mutation on the table "Offer"
"""
type Offer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Offer!]!
}

"""
on_conflict condition type for table "Offer"
"""
input Offer_on_conflict {
  constraint: Offer_constraint!
  update_columns: [Offer_update_column!]! = []
  where: Offer_bool_exp
}

"""Ordering options when selecting data from "Offer"."""
input Offer_order_by {
  expirationDate: order_by
  id: order_by
  mint: order_by
  nftTransactionId: order_by
  refundTxid: order_by
  saleTransactionId: order_by
  timeCreated: order_by
  userId: order_by
}

"""primary key columns input for table: Offer"""
input Offer_pk_columns_input {
  nftTransactionId: uuid!
}

"""
select columns of table "Offer"
"""
enum Offer_select_column {
  """column name"""
  expirationDate

  """column name"""
  id

  """column name"""
  mint

  """column name"""
  nftTransactionId

  """column name"""
  refundTxid

  """column name"""
  saleTransactionId

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
input type for updating data in table "Offer"
"""
input Offer_set_input {
  expirationDate: timestamptz
  id: uuid
  mint: String
  nftTransactionId: uuid
  refundTxid: String
  saleTransactionId: uuid
  timeCreated: timestamptz
  userId: String
}

"""
update columns of table "Offer"
"""
enum Offer_update_column {
  """column name"""
  expirationDate

  """column name"""
  id

  """column name"""
  mint

  """column name"""
  nftTransactionId

  """column name"""
  refundTxid

  """column name"""
  saleTransactionId

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
A Relay connection object on "Offer"
"""
type OfferConnection {
  edges: [OfferEdge!]!
  pageInfo: PageInfo!
}

type OfferEdge {
  cursor: String!
  node: Offer!
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

"""
columns and relationships of "Photo"
"""
type Photo implements Node {
  description: String
  id: ID!
  photoUrl: String!
  storagePath: String
  timeCreated: timestamptz!
  title: String
  userId: String!
}

"""
Boolean expression to filter rows from the table "Photo". All fields are combined with a logical 'AND'.
"""
input Photo_bool_exp {
  _and: [Photo_bool_exp!]
  _not: Photo_bool_exp
  _or: [Photo_bool_exp!]
  description: String_comparison_exp
  id: uuid_comparison_exp
  photoUrl: String_comparison_exp
  storagePath: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  title: String_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "Photo"
"""
enum Photo_constraint {
  """unique or primary key constraint"""
  Photo_pkey
}

"""
input type for inserting data into table "Photo"
"""
input Photo_insert_input {
  description: String
  id: uuid
  photoUrl: String
  storagePath: String
  timeCreated: timestamptz
  title: String
  userId: String
}

"""
response of any mutation on the table "Photo"
"""
type Photo_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Photo!]!
}

"""
input type for inserting object relation for remote table "Photo"
"""
input Photo_obj_rel_insert_input {
  data: Photo_insert_input!

  """upsert condition"""
  on_conflict: Photo_on_conflict
}

"""
on_conflict condition type for table "Photo"
"""
input Photo_on_conflict {
  constraint: Photo_constraint!
  update_columns: [Photo_update_column!]! = []
  where: Photo_bool_exp
}

"""Ordering options when selecting data from "Photo"."""
input Photo_order_by {
  description: order_by
  id: order_by
  photoUrl: order_by
  storagePath: order_by
  timeCreated: order_by
  title: order_by
  userId: order_by
}

"""primary key columns input for table: Photo"""
input Photo_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Photo"
"""
enum Photo_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  photoUrl

  """column name"""
  storagePath

  """column name"""
  timeCreated

  """column name"""
  title

  """column name"""
  userId
}

"""
input type for updating data in table "Photo"
"""
input Photo_set_input {
  description: String
  id: uuid
  photoUrl: String
  storagePath: String
  timeCreated: timestamptz
  title: String
  userId: String
}

"""
update columns of table "Photo"
"""
enum Photo_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  photoUrl

  """column name"""
  storagePath

  """column name"""
  timeCreated

  """column name"""
  title

  """column name"""
  userId
}

"""
A Relay connection object on "Photo"
"""
type PhotoConnection {
  edges: [PhotoEdge!]!
  pageInfo: PageInfo!
}

type PhotoEdge {
  cursor: String!
  node: Photo!
}

"""Polls that live on the Post table"""
type Poll implements Node {
  id: ID!
  isMultiSelect: Boolean!
}

"""
Boolean expression to filter rows from the table "Poll". All fields are combined with a logical 'AND'.
"""
input Poll_bool_exp {
  _and: [Poll_bool_exp!]
  _not: Poll_bool_exp
  _or: [Poll_bool_exp!]
  id: uuid_comparison_exp
  isMultiSelect: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "Poll"
"""
enum Poll_constraint {
  """unique or primary key constraint"""
  Poll_pkey
}

"""
input type for inserting data into table "Poll"
"""
input Poll_insert_input {
  id: uuid
  isMultiSelect: Boolean
}

"""
response of any mutation on the table "Poll"
"""
type Poll_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Poll!]!
}

"""
on_conflict condition type for table "Poll"
"""
input Poll_on_conflict {
  constraint: Poll_constraint!
  update_columns: [Poll_update_column!]! = []
  where: Poll_bool_exp
}

"""Ordering options when selecting data from "Poll"."""
input Poll_order_by {
  id: order_by
  isMultiSelect: order_by
}

"""primary key columns input for table: Poll"""
input Poll_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Poll"
"""
enum Poll_select_column {
  """column name"""
  id

  """column name"""
  isMultiSelect
}

"""
input type for updating data in table "Poll"
"""
input Poll_set_input {
  id: uuid
  isMultiSelect: Boolean
}

"""
update columns of table "Poll"
"""
enum Poll_update_column {
  """column name"""
  id

  """column name"""
  isMultiSelect
}

"""
A Relay connection object on "Poll"
"""
type PollConnection {
  edges: [PollEdge!]!
  pageInfo: PageInfo!
}

type PollEdge {
  cursor: String!
  node: Poll!
}

"""Option on a Poll"""
type PollOption implements Node {
  id: ID!
  pollId: uuid!
  text: String!
}

"""
Boolean expression to filter rows from the table "PollOption". All fields are combined with a logical 'AND'.
"""
input PollOption_bool_exp {
  _and: [PollOption_bool_exp!]
  _not: PollOption_bool_exp
  _or: [PollOption_bool_exp!]
  id: uuid_comparison_exp
  pollId: uuid_comparison_exp
  text: String_comparison_exp
}

"""
unique or primary key constraints on table "PollOption"
"""
enum PollOption_constraint {
  """unique or primary key constraint"""
  PollOption_pkey
}

"""
input type for inserting data into table "PollOption"
"""
input PollOption_insert_input {
  id: uuid
  pollId: uuid
  text: String
}

"""
response of any mutation on the table "PollOption"
"""
type PollOption_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [PollOption!]!
}

"""
on_conflict condition type for table "PollOption"
"""
input PollOption_on_conflict {
  constraint: PollOption_constraint!
  update_columns: [PollOption_update_column!]! = []
  where: PollOption_bool_exp
}

"""Ordering options when selecting data from "PollOption"."""
input PollOption_order_by {
  id: order_by
  pollId: order_by
  text: order_by
}

"""primary key columns input for table: PollOption"""
input PollOption_pk_columns_input {
  id: uuid!
}

"""
select columns of table "PollOption"
"""
enum PollOption_select_column {
  """column name"""
  id

  """column name"""
  pollId

  """column name"""
  text
}

"""
input type for updating data in table "PollOption"
"""
input PollOption_set_input {
  id: uuid
  pollId: uuid
  text: String
}

"""
update columns of table "PollOption"
"""
enum PollOption_update_column {
  """column name"""
  id

  """column name"""
  pollId

  """column name"""
  text
}

"""
A Relay connection object on "PollOption"
"""
type PollOptionConnection {
  edges: [PollOptionEdge!]!
  pageInfo: PageInfo!
}

type PollOptionEdge {
  cursor: String!
  node: PollOption!
}

"""Responses to a Poll, Responses are tied to PollOptions as well"""
type PollResponse implements Node {
  id: ID!
  pollOptionId: uuid!
  userId: String!
}

"""
Boolean expression to filter rows from the table "PollResponse". All fields are combined with a logical 'AND'.
"""
input PollResponse_bool_exp {
  _and: [PollResponse_bool_exp!]
  _not: PollResponse_bool_exp
  _or: [PollResponse_bool_exp!]
  id: uuid_comparison_exp
  pollOptionId: uuid_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "PollResponse"
"""
enum PollResponse_constraint {
  """unique or primary key constraint"""
  PollResponse_pkey

  """unique or primary key constraint"""
  PollResponse_userId_pollOptionId_key
}

"""
input type for inserting data into table "PollResponse"
"""
input PollResponse_insert_input {
  id: uuid
  pollOptionId: uuid
  userId: String
}

"""
response of any mutation on the table "PollResponse"
"""
type PollResponse_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [PollResponse!]!
}

"""
on_conflict condition type for table "PollResponse"
"""
input PollResponse_on_conflict {
  constraint: PollResponse_constraint!
  update_columns: [PollResponse_update_column!]! = []
  where: PollResponse_bool_exp
}

"""Ordering options when selecting data from "PollResponse"."""
input PollResponse_order_by {
  id: order_by
  pollOptionId: order_by
  userId: order_by
}

"""primary key columns input for table: PollResponse"""
input PollResponse_pk_columns_input {
  id: uuid!
}

"""
select columns of table "PollResponse"
"""
enum PollResponse_select_column {
  """column name"""
  id

  """column name"""
  pollOptionId

  """column name"""
  userId
}

"""
input type for updating data in table "PollResponse"
"""
input PollResponse_set_input {
  id: uuid
  pollOptionId: uuid
  userId: String
}

"""
update columns of table "PollResponse"
"""
enum PollResponse_update_column {
  """column name"""
  id

  """column name"""
  pollOptionId

  """column name"""
  userId
}

"""
A Relay connection object on "PollResponse"
"""
type PollResponseConnection {
  edges: [PollResponseEdge!]!
  pageInfo: PageInfo!
}

type PollResponseEdge {
  cursor: String!
  node: PollResponse!
}

"""
columns and relationships of "Post"
"""
type Post implements Node {
  airdropMasterEditionMint: String
  body: String
  campaignId: uuid
  creatorId: String!
  id: ID!
  link: String
  pollId: uuid
  timeCreated: timestamptz!
  title: String!
  visibility: PostVisibility_enum!
  visibilityFundingTierIds(
    """JSON select path"""
    path: String
  ): jsonb
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input Post_append_input {
  visibilityFundingTierIds: jsonb
}

"""
Boolean expression to filter rows from the table "Post". All fields are combined with a logical 'AND'.
"""
input Post_bool_exp {
  _and: [Post_bool_exp!]
  _not: Post_bool_exp
  _or: [Post_bool_exp!]
  airdropMasterEditionMint: String_comparison_exp
  body: String_comparison_exp
  campaignId: uuid_comparison_exp
  creatorId: String_comparison_exp
  id: uuid_comparison_exp
  link: String_comparison_exp
  pollId: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
  title: String_comparison_exp
  visibility: PostVisibility_enum_comparison_exp
  visibilityFundingTierIds: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "Post"
"""
enum Post_constraint {
  """unique or primary key constraint"""
  Post_PollId_key

  """unique or primary key constraint"""
  Post_airdropMasterEditionMint_key

  """unique or primary key constraint"""
  Post_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Post_delete_at_path_input {
  visibilityFundingTierIds: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input Post_delete_elem_input {
  visibilityFundingTierIds: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Post_delete_key_input {
  visibilityFundingTierIds: String
}

"""
input type for inserting data into table "Post"
"""
input Post_insert_input {
  airdropMasterEditionMint: String
  body: String
  campaignId: uuid
  creatorId: String
  id: uuid
  link: String
  pollId: uuid
  timeCreated: timestamptz
  title: String
  visibility: PostVisibility_enum
  visibilityFundingTierIds: jsonb
}

"""
response of any mutation on the table "Post"
"""
type Post_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Post!]!
}

"""
on_conflict condition type for table "Post"
"""
input Post_on_conflict {
  constraint: Post_constraint!
  update_columns: [Post_update_column!]! = []
  where: Post_bool_exp
}

"""Ordering options when selecting data from "Post"."""
input Post_order_by {
  airdropMasterEditionMint: order_by
  body: order_by
  campaignId: order_by
  creatorId: order_by
  id: order_by
  link: order_by
  pollId: order_by
  timeCreated: order_by
  title: order_by
  visibility: order_by
  visibilityFundingTierIds: order_by
}

"""primary key columns input for table: Post"""
input Post_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input Post_prepend_input {
  visibilityFundingTierIds: jsonb
}

"""
select columns of table "Post"
"""
enum Post_select_column {
  """column name"""
  airdropMasterEditionMint

  """column name"""
  body

  """column name"""
  campaignId

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  link

  """column name"""
  pollId

  """column name"""
  timeCreated

  """column name"""
  title

  """column name"""
  visibility

  """column name"""
  visibilityFundingTierIds
}

"""
input type for updating data in table "Post"
"""
input Post_set_input {
  airdropMasterEditionMint: String
  body: String
  campaignId: uuid
  creatorId: String
  id: uuid
  link: String
  pollId: uuid
  timeCreated: timestamptz
  title: String
  visibility: PostVisibility_enum
  visibilityFundingTierIds: jsonb
}

"""
update columns of table "Post"
"""
enum Post_update_column {
  """column name"""
  airdropMasterEditionMint

  """column name"""
  body

  """column name"""
  campaignId

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  link

  """column name"""
  pollId

  """column name"""
  timeCreated

  """column name"""
  title

  """column name"""
  visibility

  """column name"""
  visibilityFundingTierIds
}

"""
A Relay connection object on "Post"
"""
type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

type PostEdge {
  cursor: String!
  node: Post!
}

"""
columns and relationships of "PostVisibility"
"""
type PostVisibility implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "PostVisibility". All fields are combined with a logical 'AND'.
"""
input PostVisibility_bool_exp {
  _and: [PostVisibility_bool_exp!]
  _not: PostVisibility_bool_exp
  _or: [PostVisibility_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "PostVisibility"
"""
enum PostVisibility_constraint {
  """unique or primary key constraint"""
  PostVisibility_pkey
}

enum PostVisibility_enum {
  CampaignSupportersOnly
  Public
}

"""
Boolean expression to compare columns of type "PostVisibility_enum". All fields are combined with logical 'AND'.
"""
input PostVisibility_enum_comparison_exp {
  _eq: PostVisibility_enum
  _in: [PostVisibility_enum!]
  _is_null: Boolean
  _neq: PostVisibility_enum
  _nin: [PostVisibility_enum!]
}

"""
input type for inserting data into table "PostVisibility"
"""
input PostVisibility_insert_input {
  value: String
}

"""
response of any mutation on the table "PostVisibility"
"""
type PostVisibility_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [PostVisibility!]!
}

"""
on_conflict condition type for table "PostVisibility"
"""
input PostVisibility_on_conflict {
  constraint: PostVisibility_constraint!
  update_columns: [PostVisibility_update_column!]! = []
  where: PostVisibility_bool_exp
}

"""Ordering options when selecting data from "PostVisibility"."""
input PostVisibility_order_by {
  value: order_by
}

"""primary key columns input for table: PostVisibility"""
input PostVisibility_pk_columns_input {
  value: String!
}

"""
select columns of table "PostVisibility"
"""
enum PostVisibility_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "PostVisibility"
"""
input PostVisibility_set_input {
  value: String
}

"""
update columns of table "PostVisibility"
"""
enum PostVisibility_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "PostVisibility"
"""
type PostVisibilityConnection {
  edges: [PostVisibilityEdge!]!
  pageInfo: PageInfo!
}

type PostVisibilityEdge {
  cursor: String!
  node: PostVisibility!
}

"""
columns and relationships of "PriceFunctionType"
"""
type PriceFunctionType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "PriceFunctionType". All fields are combined with a logical 'AND'.
"""
input PriceFunctionType_bool_exp {
  _and: [PriceFunctionType_bool_exp!]
  _not: PriceFunctionType_bool_exp
  _or: [PriceFunctionType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "PriceFunctionType"
"""
enum PriceFunctionType_constraint {
  """unique or primary key constraint"""
  PriceFunctionType_pkey
}

enum PriceFunctionType_enum {
  Constant
  Linear
  Minimum
}

"""
Boolean expression to compare columns of type "PriceFunctionType_enum". All fields are combined with logical 'AND'.
"""
input PriceFunctionType_enum_comparison_exp {
  _eq: PriceFunctionType_enum
  _in: [PriceFunctionType_enum!]
  _is_null: Boolean
  _neq: PriceFunctionType_enum
  _nin: [PriceFunctionType_enum!]
}

"""
input type for inserting data into table "PriceFunctionType"
"""
input PriceFunctionType_insert_input {
  value: String
}

"""
response of any mutation on the table "PriceFunctionType"
"""
type PriceFunctionType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [PriceFunctionType!]!
}

"""
on_conflict condition type for table "PriceFunctionType"
"""
input PriceFunctionType_on_conflict {
  constraint: PriceFunctionType_constraint!
  update_columns: [PriceFunctionType_update_column!]! = []
  where: PriceFunctionType_bool_exp
}

"""Ordering options when selecting data from "PriceFunctionType"."""
input PriceFunctionType_order_by {
  value: order_by
}

"""primary key columns input for table: PriceFunctionType"""
input PriceFunctionType_pk_columns_input {
  value: String!
}

"""
select columns of table "PriceFunctionType"
"""
enum PriceFunctionType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "PriceFunctionType"
"""
input PriceFunctionType_set_input {
  value: String
}

"""
update columns of table "PriceFunctionType"
"""
enum PriceFunctionType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "PriceFunctionType"
"""
type PriceFunctionTypeConnection {
  edges: [PriceFunctionTypeEdge!]!
  pageInfo: PageInfo!
}

type PriceFunctionTypeEdge {
  cursor: String!
  node: PriceFunctionType!
}

type query_root {
  """
  fetch data from the table: "ActivityNotification"
  """
  ActivityNotification_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ActivityNotification_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ActivityNotification_order_by!]

    """filter the rows returned"""
    where: ActivityNotification_bool_exp
  ): ActivityNotificationConnection!

  """
  fetch data from the table: "AirdropType"
  """
  AirdropType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [AirdropType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [AirdropType_order_by!]

    """filter the rows returned"""
    where: AirdropType_bool_exp
  ): AirdropTypeConnection!

  """
  fetch data from the table: "Airdrop"
  """
  Airdrop_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Airdrop_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Airdrop_order_by!]

    """filter the rows returned"""
    where: Airdrop_bool_exp
  ): AirdropConnection!

  """
  fetch data from the table: "ArtistSubmissionStatus"
  """
  ArtistSubmissionStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ArtistSubmissionStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ArtistSubmissionStatus_order_by!]

    """filter the rows returned"""
    where: ArtistSubmissionStatus_bool_exp
  ): ArtistSubmissionStatusConnection!

  """
  fetch data from the table: "ArtistSubmission"
  """
  ArtistSubmission_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ArtistSubmission_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ArtistSubmission_order_by!]

    """filter the rows returned"""
    where: ArtistSubmission_bool_exp
  ): ArtistSubmissionConnection!

  """
  fetch data from the table: "Asset"
  """
  Asset_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Asset_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Asset_order_by!]

    """filter the rows returned"""
    where: Asset_bool_exp
  ): AssetConnection!

  """
  fetch data from the table: "Attribute"
  """
  Attribute_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Attribute_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Attribute_order_by!]

    """filter the rows returned"""
    where: Attribute_bool_exp
  ): AttributeConnection!

  """
  fetch data from the table: "BonkClaim"
  """
  BonkClaim_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [BonkClaim_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [BonkClaim_order_by!]

    """filter the rows returned"""
    where: BonkClaim_bool_exp
  ): BonkClaimConnection!

  """
  fetch data from the table: "CampaignBenefitStatus"
  """
  CampaignBenefitStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignBenefitStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignBenefitStatus_order_by!]

    """filter the rows returned"""
    where: CampaignBenefitStatus_bool_exp
  ): CampaignBenefitStatusConnection!

  """
  fetch data from the table: "CampaignBenefitToNft"
  """
  CampaignBenefitToNft_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignBenefitToNft_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignBenefitToNft_order_by!]

    """filter the rows returned"""
    where: CampaignBenefitToNft_bool_exp
  ): CampaignBenefitToNftConnection!

  """
  fetch data from the table: "CampaignBenefit"
  """
  CampaignBenefit_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignBenefit_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignBenefit_order_by!]

    """filter the rows returned"""
    where: CampaignBenefit_bool_exp
  ): CampaignBenefitConnection!

  """
  fetch data from the table: "CampaignCategory"
  """
  CampaignCategory_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignCategory_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignCategory_order_by!]

    """filter the rows returned"""
    where: CampaignCategory_bool_exp
  ): CampaignCategoryConnection!

  """
  fetch data from the table: "CampaignColorScheme"
  """
  CampaignColorScheme_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignColorScheme_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignColorScheme_order_by!]

    """filter the rows returned"""
    where: CampaignColorScheme_bool_exp
  ): CampaignColorSchemeConnection!

  """
  fetch data from the table: "CampaignFundingTierType"
  """
  CampaignFundingTierType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignFundingTierType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignFundingTierType_order_by!]

    """filter the rows returned"""
    where: CampaignFundingTierType_bool_exp
  ): CampaignFundingTierTypeConnection!

  """
  fetch data from the table: "CampaignFundingTier"
  """
  CampaignFundingTier_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignFundingTier_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignFundingTier_order_by!]

    """filter the rows returned"""
    where: CampaignFundingTier_bool_exp
  ): CampaignFundingTierConnection!

  """
  fetch data from the table: "CampaignGoalType"
  """
  CampaignGoalType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignGoalType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignGoalType_order_by!]

    """filter the rows returned"""
    where: CampaignGoalType_bool_exp
  ): CampaignGoalTypeConnection!

  """
  fetch data from the table: "CampaignStatus"
  """
  CampaignStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignStatus_order_by!]

    """filter the rows returned"""
    where: CampaignStatus_bool_exp
  ): CampaignStatusConnection!

  """
  fetch data from the table: "CampaignTeamMemberRole"
  """
  CampaignTeamMemberRole_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignTeamMemberRole_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignTeamMemberRole_order_by!]

    """filter the rows returned"""
    where: CampaignTeamMemberRole_bool_exp
  ): CampaignTeamMemberRoleConnection!

  """
  fetch data from the table: "CampaignToCollaborator"
  """
  CampaignToCollaborator_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignToCollaborator_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignToCollaborator_order_by!]

    """filter the rows returned"""
    where: CampaignToCollaborator_bool_exp
  ): CampaignToCollaboratorConnection!

  """
  fetch data from the table: "CampaignToHolder"
  """
  CampaignToHolder_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignToHolder_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignToHolder_order_by!]

    """filter the rows returned"""
    where: CampaignToHolder_bool_exp
  ): CampaignToHolderConnection!

  """
  fetch data from the table: "CampaignToTeamMember"
  """
  CampaignToTeamMember_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignToTeamMember_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignToTeamMember_order_by!]

    """filter the rows returned"""
    where: CampaignToTeamMember_bool_exp
  ): CampaignToTeamMemberConnection!

  """
  fetch data from the table: "Campaign"
  """
  Campaign_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Campaign_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Campaign_order_by!]

    """filter the rows returned"""
    where: Campaign_bool_exp
  ): CampaignConnection!

  """
  fetch data from the table: "CandyMachineMerkleAllowlistInfo"
  """
  CandyMachineMerkleAllowlistInfo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CandyMachineMerkleAllowlistInfo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CandyMachineMerkleAllowlistInfo_order_by!]

    """filter the rows returned"""
    where: CandyMachineMerkleAllowlistInfo_bool_exp
  ): CandyMachineMerkleAllowlistInfoConnection!

  """
  fetch data from the table: "CandyMachine"
  """
  CandyMachine_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CandyMachine_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CandyMachine_order_by!]

    """filter the rows returned"""
    where: CandyMachine_bool_exp
  ): CandyMachineConnection!

  """
  fetch data from the table: "Claim"
  """
  Claim_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Claim_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Claim_order_by!]

    """filter the rows returned"""
    where: Claim_bool_exp
  ): ClaimConnection!

  """
  fetch data from the table: "CollectorSurvey"
  """
  CollectorSurvey_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CollectorSurvey_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CollectorSurvey_order_by!]

    """filter the rows returned"""
    where: CollectorSurvey_bool_exp
  ): CollectorSurveyConnection!

  """
  fetch data from the table: "Comment"
  """
  Comment_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Comment_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Comment_order_by!]

    """filter the rows returned"""
    where: Comment_bool_exp
  ): CommentConnection!

  """
  fetch data from the table: "CreatorInviteIssueReason"
  """
  CreatorInviteIssueReason_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CreatorInviteIssueReason_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CreatorInviteIssueReason_order_by!]

    """filter the rows returned"""
    where: CreatorInviteIssueReason_bool_exp
  ): CreatorInviteIssueReasonConnection!

  """
  fetch data from the table: "CreatorInvite"
  """
  CreatorInvite_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CreatorInvite_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CreatorInvite_order_by!]

    """filter the rows returned"""
    where: CreatorInvite_bool_exp
  ): CreatorInviteConnection!

  """
  fetch data from the table: "CreatorStory"
  """
  CreatorStory_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CreatorStory_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CreatorStory_order_by!]

    """filter the rows returned"""
    where: CreatorStory_bool_exp
  ): CreatorStoryConnection!

  """
  fetch data from the table: "CreatorSurvey"
  """
  CreatorSurvey_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CreatorSurvey_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CreatorSurvey_order_by!]

    """filter the rows returned"""
    where: CreatorSurvey_bool_exp
  ): CreatorSurveyConnection!

  """
  fetch data from the table: "CurrencyName"
  """
  CurrencyName_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CurrencyName_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CurrencyName_order_by!]

    """filter the rows returned"""
    where: CurrencyName_bool_exp
  ): CurrencyNameConnection!

  """
  fetch data from the table: "Currency"
  """
  Currency_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Currency_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Currency_order_by!]

    """filter the rows returned"""
    where: Currency_bool_exp
  ): CurrencyConnection!

  """
  fetch data from the table: "DeletedNftTransaction"
  """
  DeletedNftTransaction_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [DeletedNftTransaction_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [DeletedNftTransaction_order_by!]

    """filter the rows returned"""
    where: DeletedNftTransaction_bool_exp
  ): DeletedNftTransactionConnection!

  """
  fetch data from the table: "Dev"
  """
  Dev_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Dev_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Dev_order_by!]

    """filter the rows returned"""
    where: Dev_bool_exp
  ): DevConnection!

  """
  fetch data from the table: "DiscordAuthToDiscordRole"
  """
  DiscordAuthToDiscordRole_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [DiscordAuthToDiscordRole_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [DiscordAuthToDiscordRole_order_by!]

    """filter the rows returned"""
    where: DiscordAuthToDiscordRole_bool_exp
  ): DiscordAuthToDiscordRoleConnection!

  """
  fetch data from the table: "DiscordAuth"
  """
  DiscordAuth_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [DiscordAuth_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [DiscordAuth_order_by!]

    """filter the rows returned"""
    where: DiscordAuth_bool_exp
  ): DiscordAuthConnection!

  """
  fetch data from the table: "DiscordRole"
  """
  DiscordRole_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [DiscordRole_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [DiscordRole_order_by!]

    """filter the rows returned"""
    where: DiscordRole_bool_exp
  ): DiscordRoleConnection!

  """
  fetch data from the table: "EditionsMerkleAllowlistInfo"
  """
  EditionsMerkleAllowlistInfo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [EditionsMerkleAllowlistInfo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [EditionsMerkleAllowlistInfo_order_by!]

    """filter the rows returned"""
    where: EditionsMerkleAllowlistInfo_bool_exp
  ): EditionsMerkleAllowlistInfoConnection!

  """
  fetch data from the table: "ExchangeRates"
  """
  ExchangeRates_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ExchangeRates_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ExchangeRates_order_by!]

    """filter the rows returned"""
    where: ExchangeRates_bool_exp
  ): ExchangeRatesConnection!

  """
  fetch data from the table: "InstagramAuth"
  """
  InstagramAuth_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [InstagramAuth_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [InstagramAuth_order_by!]

    """filter the rows returned"""
    where: InstagramAuth_bool_exp
  ): InstagramAuthConnection!

  """
  fetch data from the table: "NftDisclosureType"
  """
  NftDisclosureType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftDisclosureType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftDisclosureType_order_by!]

    """filter the rows returned"""
    where: NftDisclosureType_bool_exp
  ): NftDisclosureTypeConnection!

  """
  fetch data from the table: "NftDisclosure"
  """
  NftDisclosure_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftDisclosure_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftDisclosure_order_by!]

    """filter the rows returned"""
    where: NftDisclosure_bool_exp
  ): NftDisclosureConnection!

  """
  fetch data from the table: "NftListing"
  """
  NftListing_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftListing_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftListing_order_by!]

    """filter the rows returned"""
    where: NftListing_bool_exp
  ): NftListingConnection!

  """
  fetch data from the table: "NftMetadata"
  """
  NftMetadata_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftMetadata_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftMetadata_order_by!]

    """filter the rows returned"""
    where: NftMetadata_bool_exp
  ): NftMetadataConnection!

  """
  fetch data from the table: "NftStatus"
  """
  NftStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftStatus_order_by!]

    """filter the rows returned"""
    where: NftStatus_bool_exp
  ): NftStatusConnection!

  """
  fetch data from the table: "NftToAttribute"
  """
  NftToAttribute_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftToAttribute_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftToAttribute_order_by!]

    """filter the rows returned"""
    where: NftToAttribute_bool_exp
  ): NftToAttributeConnection!

  """
  fetch data from the table: "NftToCollaborator"
  """
  NftToCollaborator_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftToCollaborator_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftToCollaborator_order_by!]

    """filter the rows returned"""
    where: NftToCollaborator_bool_exp
  ): NftToCollaboratorConnection!

  """
  fetch data from the table: "NftToTag"
  """
  NftToTag_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftToTag_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftToTag_order_by!]

    """filter the rows returned"""
    where: NftToTag_bool_exp
  ): NftToTagConnection!

  """
  fetch data from the table: "NftTransactionRaw"
  """
  NftTransactionRaw_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftTransactionRaw_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftTransactionRaw_order_by!]

    """filter the rows returned"""
    where: NftTransactionRaw_bool_exp
  ): NftTransactionRawConnection!

  """
  fetch data from the table: "NftTransactionSource"
  """
  NftTransactionSource_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftTransactionSource_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftTransactionSource_order_by!]

    """filter the rows returned"""
    where: NftTransactionSource_bool_exp
  ): NftTransactionSourceConnection!

  """
  fetch data from the table: "NftTransactionType"
  """
  NftTransactionType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftTransactionType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftTransactionType_order_by!]

    """filter the rows returned"""
    where: NftTransactionType_bool_exp
  ): NftTransactionTypeConnection!

  """
  fetch data from the table: "NftTransaction"
  """
  NftTransaction_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftTransaction_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftTransaction_order_by!]

    """filter the rows returned"""
    where: NftTransaction_bool_exp
  ): NftTransactionConnection!

  """
  fetch data from the table: "Nft"
  """
  Nft_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Nft_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Nft_order_by!]

    """filter the rows returned"""
    where: Nft_bool_exp
  ): NftConnection!

  """
  fetch data from the table: "NotificationChannel"
  """
  NotificationChannel_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NotificationChannel_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NotificationChannel_order_by!]

    """filter the rows returned"""
    where: NotificationChannel_bool_exp
  ): NotificationChannelConnection!

  """
  fetch data from the table: "NotificationType"
  """
  NotificationType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NotificationType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NotificationType_order_by!]

    """filter the rows returned"""
    where: NotificationType_bool_exp
  ): NotificationTypeConnection!

  """
  fetch data from the table: "NotificationUserPreference"
  """
  NotificationUserPreference_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NotificationUserPreference_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NotificationUserPreference_order_by!]

    """filter the rows returned"""
    where: NotificationUserPreference_bool_exp
  ): NotificationUserPreferenceConnection!

  """
  fetch data from the table: "Notification"
  """
  Notification_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Notification_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Notification_order_by!]

    """filter the rows returned"""
    where: Notification_bool_exp
  ): NotificationConnection!

  """
  fetch data from the table: "Offer"
  """
  Offer_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Offer_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Offer_order_by!]

    """filter the rows returned"""
    where: Offer_bool_exp
  ): OfferConnection!

  """
  fetch data from the table: "Photo"
  """
  Photo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Photo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Photo_order_by!]

    """filter the rows returned"""
    where: Photo_bool_exp
  ): PhotoConnection!

  """
  fetch data from the table: "PollOption"
  """
  PollOption_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [PollOption_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [PollOption_order_by!]

    """filter the rows returned"""
    where: PollOption_bool_exp
  ): PollOptionConnection!

  """
  fetch data from the table: "PollResponse"
  """
  PollResponse_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [PollResponse_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [PollResponse_order_by!]

    """filter the rows returned"""
    where: PollResponse_bool_exp
  ): PollResponseConnection!

  """
  fetch data from the table: "Poll"
  """
  Poll_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Poll_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Poll_order_by!]

    """filter the rows returned"""
    where: Poll_bool_exp
  ): PollConnection!

  """
  fetch data from the table: "PostVisibility"
  """
  PostVisibility_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [PostVisibility_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [PostVisibility_order_by!]

    """filter the rows returned"""
    where: PostVisibility_bool_exp
  ): PostVisibilityConnection!

  """
  fetch data from the table: "Post"
  """
  Post_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Post_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Post_order_by!]

    """filter the rows returned"""
    where: Post_bool_exp
  ): PostConnection!

  """
  fetch data from the table: "PriceFunctionType"
  """
  PriceFunctionType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [PriceFunctionType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [PriceFunctionType_order_by!]

    """filter the rows returned"""
    where: PriceFunctionType_bool_exp
  ): PriceFunctionTypeConnection!

  """
  fetch data from the table: "ReactionType"
  """
  ReactionType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ReactionType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ReactionType_order_by!]

    """filter the rows returned"""
    where: ReactionType_bool_exp
  ): ReactionTypeConnection!

  """
  fetch data from the table: "Reaction"
  """
  Reaction_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Reaction_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Reaction_order_by!]

    """filter the rows returned"""
    where: Reaction_bool_exp
  ): ReactionConnection!

  """
  fetch data from the table: "RequestStatus"
  """
  RequestStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [RequestStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [RequestStatus_order_by!]

    """filter the rows returned"""
    where: RequestStatus_bool_exp
  ): RequestStatusConnection!

  """
  fetch data from the table: "Request"
  """
  Request_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Request_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Request_order_by!]

    """filter the rows returned"""
    where: Request_bool_exp
  ): RequestConnection!

  """
  fetch data from the table: "SeriesType"
  """
  SeriesType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [SeriesType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [SeriesType_order_by!]

    """filter the rows returned"""
    where: SeriesType_bool_exp
  ): SeriesTypeConnection!

  """
  fetch data from the table: "Series"
  """
  Series_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Series_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Series_order_by!]

    """filter the rows returned"""
    where: Series_bool_exp
  ): SeriesConnection!

  """
  fetch data from the table: "SpotlightHeroUnitLayout"
  """
  SpotlightHeroUnitLayout_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [SpotlightHeroUnitLayout_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [SpotlightHeroUnitLayout_order_by!]

    """filter the rows returned"""
    where: SpotlightHeroUnitLayout_bool_exp
  ): SpotlightHeroUnitLayoutConnection!

  """
  fetch data from the table: "SpotlightType"
  """
  SpotlightType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [SpotlightType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [SpotlightType_order_by!]

    """filter the rows returned"""
    where: SpotlightType_bool_exp
  ): SpotlightTypeConnection!

  """
  fetch data from the table: "Spotlight"
  """
  Spotlight_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Spotlight_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Spotlight_order_by!]

    """filter the rows returned"""
    where: Spotlight_bool_exp
  ): SpotlightConnection!

  """
  fetch data from the table: "Tag"
  """
  Tag_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Tag_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Tag_order_by!]

    """filter the rows returned"""
    where: Tag_bool_exp
  ): TagConnection!

  """
  fetch data from the table: "TooniesShippingInfo"
  """
  TooniesShippingInfo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [TooniesShippingInfo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [TooniesShippingInfo_order_by!]

    """filter the rows returned"""
    where: TooniesShippingInfo_bool_exp
  ): TooniesShippingInfoConnection!

  """
  fetch data from the table: "TwitterAuth"
  """
  TwitterAuth_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [TwitterAuth_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [TwitterAuth_order_by!]

    """filter the rows returned"""
    where: TwitterAuth_bool_exp
  ): TwitterAuthConnection!

  """
  fetch data from the table: "UnlockableWinner"
  """
  UnlockableWinner_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [UnlockableWinner_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [UnlockableWinner_order_by!]

    """filter the rows returned"""
    where: UnlockableWinner_bool_exp
  ): UnlockableWinnerConnection!

  """
  fetch data from the table: "Unlockable"
  """
  Unlockable_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Unlockable_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Unlockable_order_by!]

    """filter the rows returned"""
    where: Unlockable_bool_exp
  ): UnlockableConnection!

  """
  fetch data from the table: "UserFollows"
  """
  UserFollows_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [UserFollows_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [UserFollows_order_by!]

    """filter the rows returned"""
    where: UserFollows_bool_exp
  ): UserFollowsConnection!

  """
  fetch data from the table: "User"
  """
  User_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [User_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [User_order_by!]

    """filter the rows returned"""
    where: User_bool_exp
  ): UserConnection!

  """
  fetch data from the table: "Video"
  """
  Video_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Video_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Video_order_by!]

    """filter the rows returned"""
    where: Video_bool_exp
  ): VideoConnection!

  """
  fetch data from the table: "VoteReason"
  """
  VoteReason_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [VoteReason_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [VoteReason_order_by!]

    """filter the rows returned"""
    where: VoteReason_bool_exp
  ): VoteReasonConnection!

  """
  fetch data from the table: "VoteType"
  """
  VoteType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [VoteType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [VoteType_order_by!]

    """filter the rows returned"""
    where: VoteType_bool_exp
  ): VoteTypeConnection!

  """
  fetch data from the table: "Vote"
  """
  Vote_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Vote_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Vote_order_by!]

    """filter the rows returned"""
    where: Vote_bool_exp
  ): VoteConnection!

  """
  fetch data from the table: "Whitelist"
  """
  Whitelist_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Whitelist_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Whitelist_order_by!]

    """filter the rows returned"""
    where: Whitelist_bool_exp
  ): WhitelistConnection!
  node(
    """A globally unique id"""
    id: ID!
  ): Node
}

"""Table that stores various reactions for things posts/comments/etc."""
type Reaction implements Node {
  fromUserId: String!
  id: ID!
  postId: uuid
  timeCreated: timestamptz!
  type: ReactionType_enum!
}

"""
Boolean expression to filter rows from the table "Reaction". All fields are combined with a logical 'AND'.
"""
input Reaction_bool_exp {
  _and: [Reaction_bool_exp!]
  _not: Reaction_bool_exp
  _or: [Reaction_bool_exp!]
  fromUserId: String_comparison_exp
  id: uuid_comparison_exp
  postId: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
  type: ReactionType_enum_comparison_exp
}

"""
unique or primary key constraints on table "Reaction"
"""
enum Reaction_constraint {
  """unique or primary key constraint"""
  Reaction_fromUserId_postId_key

  """unique or primary key constraint"""
  Reaction_pkey
}

"""
input type for inserting data into table "Reaction"
"""
input Reaction_insert_input {
  fromUserId: String
  id: uuid
  postId: uuid
  timeCreated: timestamptz
  type: ReactionType_enum
}

"""
response of any mutation on the table "Reaction"
"""
type Reaction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Reaction!]!
}

"""
on_conflict condition type for table "Reaction"
"""
input Reaction_on_conflict {
  constraint: Reaction_constraint!
  update_columns: [Reaction_update_column!]! = []
  where: Reaction_bool_exp
}

"""Ordering options when selecting data from "Reaction"."""
input Reaction_order_by {
  fromUserId: order_by
  id: order_by
  postId: order_by
  timeCreated: order_by
  type: order_by
}

"""primary key columns input for table: Reaction"""
input Reaction_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Reaction"
"""
enum Reaction_select_column {
  """column name"""
  fromUserId

  """column name"""
  id

  """column name"""
  postId

  """column name"""
  timeCreated

  """column name"""
  type
}

"""
input type for updating data in table "Reaction"
"""
input Reaction_set_input {
  fromUserId: String
  id: uuid
  postId: uuid
  timeCreated: timestamptz
  type: ReactionType_enum
}

"""
update columns of table "Reaction"
"""
enum Reaction_update_column {
  """column name"""
  fromUserId

  """column name"""
  id

  """column name"""
  postId

  """column name"""
  timeCreated

  """column name"""
  type
}

"""
A Relay connection object on "Reaction"
"""
type ReactionConnection {
  edges: [ReactionEdge!]!
  pageInfo: PageInfo!
}

type ReactionEdge {
  cursor: String!
  node: Reaction!
}

"""
columns and relationships of "ReactionType"
"""
type ReactionType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "ReactionType". All fields are combined with a logical 'AND'.
"""
input ReactionType_bool_exp {
  _and: [ReactionType_bool_exp!]
  _not: ReactionType_bool_exp
  _or: [ReactionType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "ReactionType"
"""
enum ReactionType_constraint {
  """unique or primary key constraint"""
  ReactionType_pkey
}

enum ReactionType_enum {
  Like
}

"""
Boolean expression to compare columns of type "ReactionType_enum". All fields are combined with logical 'AND'.
"""
input ReactionType_enum_comparison_exp {
  _eq: ReactionType_enum
  _in: [ReactionType_enum!]
  _is_null: Boolean
  _neq: ReactionType_enum
  _nin: [ReactionType_enum!]
}

"""
input type for inserting data into table "ReactionType"
"""
input ReactionType_insert_input {
  value: String
}

"""
response of any mutation on the table "ReactionType"
"""
type ReactionType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ReactionType!]!
}

"""
on_conflict condition type for table "ReactionType"
"""
input ReactionType_on_conflict {
  constraint: ReactionType_constraint!
  update_columns: [ReactionType_update_column!]! = []
  where: ReactionType_bool_exp
}

"""Ordering options when selecting data from "ReactionType"."""
input ReactionType_order_by {
  value: order_by
}

"""primary key columns input for table: ReactionType"""
input ReactionType_pk_columns_input {
  value: String!
}

"""
select columns of table "ReactionType"
"""
enum ReactionType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "ReactionType"
"""
input ReactionType_set_input {
  value: String
}

"""
update columns of table "ReactionType"
"""
enum ReactionType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "ReactionType"
"""
type ReactionTypeConnection {
  edges: [ReactionTypeEdge!]!
  pageInfo: PageInfo!
}

type ReactionTypeEdge {
  cursor: String!
  node: ReactionType!
}

"""
Tracks requests users make of another (e.g. requesting to add another user as a collaborator on an NFT)
"""
type Request implements Node {
  fromUserId: String!
  id: ID!
  status: RequestStatus_enum!
  timeCreated: timestamptz!
  toUserId: String!
}

"""
Boolean expression to filter rows from the table "Request". All fields are combined with a logical 'AND'.
"""
input Request_bool_exp {
  _and: [Request_bool_exp!]
  _not: Request_bool_exp
  _or: [Request_bool_exp!]
  fromUserId: String_comparison_exp
  id: uuid_comparison_exp
  status: RequestStatus_enum_comparison_exp
  timeCreated: timestamptz_comparison_exp
  toUserId: String_comparison_exp
}

"""
unique or primary key constraints on table "Request"
"""
enum Request_constraint {
  """unique or primary key constraint"""
  Request_pkey
}

"""
input type for inserting data into table "Request"
"""
input Request_insert_input {
  fromUserId: String
  id: uuid
  status: RequestStatus_enum
  timeCreated: timestamptz
  toUserId: String
}

"""
response of any mutation on the table "Request"
"""
type Request_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Request!]!
}

"""
input type for inserting object relation for remote table "Request"
"""
input Request_obj_rel_insert_input {
  data: Request_insert_input!

  """upsert condition"""
  on_conflict: Request_on_conflict
}

"""
on_conflict condition type for table "Request"
"""
input Request_on_conflict {
  constraint: Request_constraint!
  update_columns: [Request_update_column!]! = []
  where: Request_bool_exp
}

"""Ordering options when selecting data from "Request"."""
input Request_order_by {
  fromUserId: order_by
  id: order_by
  status: order_by
  timeCreated: order_by
  toUserId: order_by
}

"""primary key columns input for table: Request"""
input Request_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Request"
"""
enum Request_select_column {
  """column name"""
  fromUserId

  """column name"""
  id

  """column name"""
  status

  """column name"""
  timeCreated

  """column name"""
  toUserId
}

"""
input type for updating data in table "Request"
"""
input Request_set_input {
  fromUserId: String
  id: uuid
  status: RequestStatus_enum
  timeCreated: timestamptz
  toUserId: String
}

"""
update columns of table "Request"
"""
enum Request_update_column {
  """column name"""
  fromUserId

  """column name"""
  id

  """column name"""
  status

  """column name"""
  timeCreated

  """column name"""
  toUserId
}

"""
A Relay connection object on "Request"
"""
type RequestConnection {
  edges: [RequestEdge!]!
  pageInfo: PageInfo!
}

type RequestEdge {
  cursor: String!
  node: Request!
}

"""
columns and relationships of "RequestStatus"
"""
type RequestStatus implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "RequestStatus". All fields are combined with a logical 'AND'.
"""
input RequestStatus_bool_exp {
  _and: [RequestStatus_bool_exp!]
  _not: RequestStatus_bool_exp
  _or: [RequestStatus_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "RequestStatus"
"""
enum RequestStatus_constraint {
  """unique or primary key constraint"""
  RequestStatus_pkey
}

enum RequestStatus_enum {
  Approved
  Pending
  Rejected
}

"""
Boolean expression to compare columns of type "RequestStatus_enum". All fields are combined with logical 'AND'.
"""
input RequestStatus_enum_comparison_exp {
  _eq: RequestStatus_enum
  _in: [RequestStatus_enum!]
  _is_null: Boolean
  _neq: RequestStatus_enum
  _nin: [RequestStatus_enum!]
}

"""
input type for inserting data into table "RequestStatus"
"""
input RequestStatus_insert_input {
  value: String
}

"""
response of any mutation on the table "RequestStatus"
"""
type RequestStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [RequestStatus!]!
}

"""
on_conflict condition type for table "RequestStatus"
"""
input RequestStatus_on_conflict {
  constraint: RequestStatus_constraint!
  update_columns: [RequestStatus_update_column!]! = []
  where: RequestStatus_bool_exp
}

"""Ordering options when selecting data from "RequestStatus"."""
input RequestStatus_order_by {
  value: order_by
}

"""primary key columns input for table: RequestStatus"""
input RequestStatus_pk_columns_input {
  value: String!
}

"""
select columns of table "RequestStatus"
"""
enum RequestStatus_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "RequestStatus"
"""
input RequestStatus_set_input {
  value: String
}

"""
update columns of table "RequestStatus"
"""
enum RequestStatus_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "RequestStatus"
"""
type RequestStatusConnection {
  edges: [RequestStatusEdge!]!
  pageInfo: PageInfo!
}

type RequestStatusEdge {
  cursor: String!
  node: RequestStatus!
}

"""
columns and relationships of "Series"
"""
type Series implements Node {
  """An object relationship"""
  AvatarPhoto: Photo!

  """An object relationship"""
  CoverPhoto: Photo

  """An object relationship"""
  Creator: User!

  """An array relationship"""
  Nfts(
    """distinct select on columns"""
    distinct_on: [Nft_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Nft_order_by!]

    """filter the rows returned"""
    where: Nft_bool_exp
  ): [Nft!]!

  """An aggregate relationship"""
  Nfts_aggregate(
    """distinct select on columns"""
    distinct_on: [Nft_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Nft_order_by!]

    """filter the rows returned"""
    where: Nft_bool_exp
  ): Nft_aggregate!

  """An array relationship connection"""
  Nfts_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Nft_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Nft_order_by!]

    """filter the rows returned"""
    where: Nft_bool_exp
  ): NftConnection!
  avatarPhotoId: uuid!
  coverPhotoId: uuid
  creatorId: String!
  description: String!
  id: ID!

  """An object relationship"""
  logoAsset: Asset
  logoAssetId: uuid
  mint: String!
  name: String!

  """
  A computed field, executes function "series_name_length_fn"
  """
  nameLength: Int
  nftOrder(
    """JSON select path"""
    path: String
  ): jsonb
  slug: String!
  timeCreated: timestamptz!
  timeLastAddedTo: timestamptz
  type: SeriesType_enum!
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input Series_append_input {
  nftOrder: jsonb
}

"""
Boolean expression to filter rows from the table "Series". All fields are combined with a logical 'AND'.
"""
input Series_bool_exp {
  AvatarPhoto: Photo_bool_exp
  CoverPhoto: Photo_bool_exp
  Creator: User_bool_exp
  Nfts: Nft_bool_exp
  _and: [Series_bool_exp!]
  _not: Series_bool_exp
  _or: [Series_bool_exp!]
  avatarPhotoId: uuid_comparison_exp
  coverPhotoId: uuid_comparison_exp
  creatorId: String_comparison_exp
  description: String_comparison_exp
  id: String_comparison_exp
  logoAsset: Asset_bool_exp
  logoAssetId: uuid_comparison_exp
  mint: String_comparison_exp
  name: String_comparison_exp
  nameLength: Int_comparison_exp
  nftOrder: jsonb_comparison_exp
  slug: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  timeLastAddedTo: timestamptz_comparison_exp
  type: SeriesType_enum_comparison_exp
}

"""
unique or primary key constraints on table "Series"
"""
enum Series_constraint {
  """unique or primary key constraint"""
  Series_avatarPhotoId_key

  """unique or primary key constraint"""
  Series_coverPhotoId_key

  """unique or primary key constraint"""
  Series_creatorId_slug_key

  """unique or primary key constraint"""
  Series_mint_key

  """unique or primary key constraint"""
  Series_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Series_delete_at_path_input {
  nftOrder: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input Series_delete_elem_input {
  nftOrder: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Series_delete_key_input {
  nftOrder: String
}

"""
input type for inserting data into table "Series"
"""
input Series_insert_input {
  AvatarPhoto: Photo_obj_rel_insert_input
  CoverPhoto: Photo_obj_rel_insert_input
  Creator: User_obj_rel_insert_input
  Nfts: Nft_arr_rel_insert_input
  avatarPhotoId: uuid
  coverPhotoId: uuid
  creatorId: String
  description: String
  id: String
  logoAsset: Asset_obj_rel_insert_input
  logoAssetId: uuid
  mint: String
  name: String
  nftOrder: jsonb
  slug: String
  timeCreated: timestamptz
  timeLastAddedTo: timestamptz
  type: SeriesType_enum
}

"""
response of any mutation on the table "Series"
"""
type Series_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Series!]!
}

"""
on_conflict condition type for table "Series"
"""
input Series_on_conflict {
  constraint: Series_constraint!
  update_columns: [Series_update_column!]! = []
  where: Series_bool_exp
}

"""Ordering options when selecting data from "Series"."""
input Series_order_by {
  AvatarPhoto: Photo_order_by
  CoverPhoto: Photo_order_by
  Creator: User_order_by
  Nfts_aggregate: Nft_aggregate_order_by
  avatarPhotoId: order_by
  coverPhotoId: order_by
  creatorId: order_by
  description: order_by
  id: order_by
  logoAsset: Asset_order_by
  logoAssetId: order_by
  mint: order_by
  name: order_by
  nameLength: order_by
  nftOrder: order_by
  slug: order_by
  timeCreated: order_by
  timeLastAddedTo: order_by
  type: order_by
}

"""primary key columns input for table: Series"""
input Series_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input Series_prepend_input {
  nftOrder: jsonb
}

"""
select columns of table "Series"
"""
enum Series_select_column {
  """column name"""
  avatarPhotoId

  """column name"""
  coverPhotoId

  """column name"""
  creatorId

  """column name"""
  description

  """column name"""
  id

  """column name"""
  logoAssetId

  """column name"""
  mint

  """column name"""
  name

  """column name"""
  nftOrder

  """column name"""
  slug

  """column name"""
  timeCreated

  """column name"""
  timeLastAddedTo

  """column name"""
  type
}

"""
input type for updating data in table "Series"
"""
input Series_set_input {
  avatarPhotoId: uuid
  coverPhotoId: uuid
  creatorId: String
  description: String
  id: String
  logoAssetId: uuid
  mint: String
  name: String
  nftOrder: jsonb
  slug: String
  timeCreated: timestamptz
  timeLastAddedTo: timestamptz
  type: SeriesType_enum
}

"""
update columns of table "Series"
"""
enum Series_update_column {
  """column name"""
  avatarPhotoId

  """column name"""
  coverPhotoId

  """column name"""
  creatorId

  """column name"""
  description

  """column name"""
  id

  """column name"""
  logoAssetId

  """column name"""
  mint

  """column name"""
  name

  """column name"""
  nftOrder

  """column name"""
  slug

  """column name"""
  timeCreated

  """column name"""
  timeLastAddedTo

  """column name"""
  type
}

"""
A Relay connection object on "Series"
"""
type SeriesConnection {
  edges: [SeriesEdge!]!
  pageInfo: PageInfo!
}

type SeriesEdge {
  cursor: String!
  node: Series!
}

"""
columns and relationships of "SeriesType"
"""
type SeriesType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "SeriesType". All fields are combined with a logical 'AND'.
"""
input SeriesType_bool_exp {
  _and: [SeriesType_bool_exp!]
  _not: SeriesType_bool_exp
  _or: [SeriesType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "SeriesType"
"""
enum SeriesType_constraint {
  """unique or primary key constraint"""
  SeriesType_pkey
}

enum SeriesType_enum {
  GenerativeMint
  UserCurated
}

"""
Boolean expression to compare columns of type "SeriesType_enum". All fields are combined with logical 'AND'.
"""
input SeriesType_enum_comparison_exp {
  _eq: SeriesType_enum
  _in: [SeriesType_enum!]
  _is_null: Boolean
  _neq: SeriesType_enum
  _nin: [SeriesType_enum!]
}

"""
input type for inserting data into table "SeriesType"
"""
input SeriesType_insert_input {
  value: String
}

"""
response of any mutation on the table "SeriesType"
"""
type SeriesType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [SeriesType!]!
}

"""
on_conflict condition type for table "SeriesType"
"""
input SeriesType_on_conflict {
  constraint: SeriesType_constraint!
  update_columns: [SeriesType_update_column!]! = []
  where: SeriesType_bool_exp
}

"""Ordering options when selecting data from "SeriesType"."""
input SeriesType_order_by {
  value: order_by
}

"""primary key columns input for table: SeriesType"""
input SeriesType_pk_columns_input {
  value: String!
}

"""
select columns of table "SeriesType"
"""
enum SeriesType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "SeriesType"
"""
input SeriesType_set_input {
  value: String
}

"""
update columns of table "SeriesType"
"""
enum SeriesType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "SeriesType"
"""
type SeriesTypeConnection {
  edges: [SeriesTypeEdge!]!
  pageInfo: PageInfo!
}

type SeriesTypeEdge {
  cursor: String!
  node: SeriesType!
}

"""
columns and relationships of "Spotlight"
"""
type Spotlight implements Node {
  assetId: uuid
  description: String
  endTime: timestamptz!
  heroUnitLayout: SpotlightHeroUnitLayout_enum!
  id: ID!
  label: String
  objectId: String
  startTime: timestamptz!
  status: String
  title: String
  type: SpotlightType_enum!
  url: String
  userIds(
    """JSON select path"""
    path: String
  ): jsonb
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input Spotlight_append_input {
  userIds: jsonb
}

"""
Boolean expression to filter rows from the table "Spotlight". All fields are combined with a logical 'AND'.
"""
input Spotlight_bool_exp {
  _and: [Spotlight_bool_exp!]
  _not: Spotlight_bool_exp
  _or: [Spotlight_bool_exp!]
  assetId: uuid_comparison_exp
  description: String_comparison_exp
  endTime: timestamptz_comparison_exp
  heroUnitLayout: SpotlightHeroUnitLayout_enum_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  objectId: String_comparison_exp
  startTime: timestamptz_comparison_exp
  status: String_comparison_exp
  title: String_comparison_exp
  type: SpotlightType_enum_comparison_exp
  url: String_comparison_exp
  userIds: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "Spotlight"
"""
enum Spotlight_constraint {
  """unique or primary key constraint"""
  Spotlight_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Spotlight_delete_at_path_input {
  userIds: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input Spotlight_delete_elem_input {
  userIds: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Spotlight_delete_key_input {
  userIds: String
}

"""
input type for inserting data into table "Spotlight"
"""
input Spotlight_insert_input {
  assetId: uuid
  description: String
  endTime: timestamptz
  heroUnitLayout: SpotlightHeroUnitLayout_enum
  id: uuid
  label: String
  objectId: String
  startTime: timestamptz
  status: String
  title: String
  type: SpotlightType_enum
  url: String
  userIds: jsonb
}

"""
response of any mutation on the table "Spotlight"
"""
type Spotlight_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Spotlight!]!
}

"""
on_conflict condition type for table "Spotlight"
"""
input Spotlight_on_conflict {
  constraint: Spotlight_constraint!
  update_columns: [Spotlight_update_column!]! = []
  where: Spotlight_bool_exp
}

"""Ordering options when selecting data from "Spotlight"."""
input Spotlight_order_by {
  assetId: order_by
  description: order_by
  endTime: order_by
  heroUnitLayout: order_by
  id: order_by
  label: order_by
  objectId: order_by
  startTime: order_by
  status: order_by
  title: order_by
  type: order_by
  url: order_by
  userIds: order_by
}

"""primary key columns input for table: Spotlight"""
input Spotlight_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input Spotlight_prepend_input {
  userIds: jsonb
}

"""
select columns of table "Spotlight"
"""
enum Spotlight_select_column {
  """column name"""
  assetId

  """column name"""
  description

  """column name"""
  endTime

  """column name"""
  heroUnitLayout

  """column name"""
  id

  """column name"""
  label

  """column name"""
  objectId

  """column name"""
  startTime

  """column name"""
  status

  """column name"""
  title

  """column name"""
  type

  """column name"""
  url

  """column name"""
  userIds
}

"""
input type for updating data in table "Spotlight"
"""
input Spotlight_set_input {
  assetId: uuid
  description: String
  endTime: timestamptz
  heroUnitLayout: SpotlightHeroUnitLayout_enum
  id: uuid
  label: String
  objectId: String
  startTime: timestamptz
  status: String
  title: String
  type: SpotlightType_enum
  url: String
  userIds: jsonb
}

"""
update columns of table "Spotlight"
"""
enum Spotlight_update_column {
  """column name"""
  assetId

  """column name"""
  description

  """column name"""
  endTime

  """column name"""
  heroUnitLayout

  """column name"""
  id

  """column name"""
  label

  """column name"""
  objectId

  """column name"""
  startTime

  """column name"""
  status

  """column name"""
  title

  """column name"""
  type

  """column name"""
  url

  """column name"""
  userIds
}

"""
A Relay connection object on "Spotlight"
"""
type SpotlightConnection {
  edges: [SpotlightEdge!]!
  pageInfo: PageInfo!
}

type SpotlightEdge {
  cursor: String!
  node: Spotlight!
}

"""
columns and relationships of "SpotlightHeroUnitLayout"
"""
type SpotlightHeroUnitLayout implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "SpotlightHeroUnitLayout". All fields are combined with a logical 'AND'.
"""
input SpotlightHeroUnitLayout_bool_exp {
  _and: [SpotlightHeroUnitLayout_bool_exp!]
  _not: SpotlightHeroUnitLayout_bool_exp
  _or: [SpotlightHeroUnitLayout_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "SpotlightHeroUnitLayout"
"""
enum SpotlightHeroUnitLayout_constraint {
  """unique or primary key constraint"""
  SpotlightHeroUnitLayout_pkey
}

enum SpotlightHeroUnitLayout_enum {
  Standard
  TwoColumnSquareImage
}

"""
Boolean expression to compare columns of type "SpotlightHeroUnitLayout_enum". All fields are combined with logical 'AND'.
"""
input SpotlightHeroUnitLayout_enum_comparison_exp {
  _eq: SpotlightHeroUnitLayout_enum
  _in: [SpotlightHeroUnitLayout_enum!]
  _is_null: Boolean
  _neq: SpotlightHeroUnitLayout_enum
  _nin: [SpotlightHeroUnitLayout_enum!]
}

"""
input type for inserting data into table "SpotlightHeroUnitLayout"
"""
input SpotlightHeroUnitLayout_insert_input {
  value: String
}

"""
response of any mutation on the table "SpotlightHeroUnitLayout"
"""
type SpotlightHeroUnitLayout_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [SpotlightHeroUnitLayout!]!
}

"""
on_conflict condition type for table "SpotlightHeroUnitLayout"
"""
input SpotlightHeroUnitLayout_on_conflict {
  constraint: SpotlightHeroUnitLayout_constraint!
  update_columns: [SpotlightHeroUnitLayout_update_column!]! = []
  where: SpotlightHeroUnitLayout_bool_exp
}

"""Ordering options when selecting data from "SpotlightHeroUnitLayout"."""
input SpotlightHeroUnitLayout_order_by {
  value: order_by
}

"""primary key columns input for table: SpotlightHeroUnitLayout"""
input SpotlightHeroUnitLayout_pk_columns_input {
  value: String!
}

"""
select columns of table "SpotlightHeroUnitLayout"
"""
enum SpotlightHeroUnitLayout_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "SpotlightHeroUnitLayout"
"""
input SpotlightHeroUnitLayout_set_input {
  value: String
}

"""
update columns of table "SpotlightHeroUnitLayout"
"""
enum SpotlightHeroUnitLayout_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "SpotlightHeroUnitLayout"
"""
type SpotlightHeroUnitLayoutConnection {
  edges: [SpotlightHeroUnitLayoutEdge!]!
  pageInfo: PageInfo!
}

type SpotlightHeroUnitLayoutEdge {
  cursor: String!
  node: SpotlightHeroUnitLayout!
}

"""
columns and relationships of "SpotlightType"
"""
type SpotlightType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "SpotlightType". All fields are combined with a logical 'AND'.
"""
input SpotlightType_bool_exp {
  _and: [SpotlightType_bool_exp!]
  _not: SpotlightType_bool_exp
  _or: [SpotlightType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "SpotlightType"
"""
enum SpotlightType_constraint {
  """unique or primary key constraint"""
  SpotlightType_pkey
}

enum SpotlightType_enum {
  Adhoc
  Campaign
  Merchandise
  Nft
  Series
}

"""
Boolean expression to compare columns of type "SpotlightType_enum". All fields are combined with logical 'AND'.
"""
input SpotlightType_enum_comparison_exp {
  _eq: SpotlightType_enum
  _in: [SpotlightType_enum!]
  _is_null: Boolean
  _neq: SpotlightType_enum
  _nin: [SpotlightType_enum!]
}

"""
input type for inserting data into table "SpotlightType"
"""
input SpotlightType_insert_input {
  value: String
}

"""
response of any mutation on the table "SpotlightType"
"""
type SpotlightType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [SpotlightType!]!
}

"""
on_conflict condition type for table "SpotlightType"
"""
input SpotlightType_on_conflict {
  constraint: SpotlightType_constraint!
  update_columns: [SpotlightType_update_column!]! = []
  where: SpotlightType_bool_exp
}

"""Ordering options when selecting data from "SpotlightType"."""
input SpotlightType_order_by {
  value: order_by
}

"""primary key columns input for table: SpotlightType"""
input SpotlightType_pk_columns_input {
  value: String!
}

"""
select columns of table "SpotlightType"
"""
enum SpotlightType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "SpotlightType"
"""
input SpotlightType_set_input {
  value: String
}

"""
update columns of table "SpotlightType"
"""
enum SpotlightType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "SpotlightType"
"""
type SpotlightTypeConnection {
  edges: [SpotlightTypeEdge!]!
  pageInfo: PageInfo!
}

type SpotlightTypeEdge {
  cursor: String!
  node: SpotlightType!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "ActivityNotification"
  """
  ActivityNotification_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ActivityNotification_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ActivityNotification_order_by!]

    """filter the rows returned"""
    where: ActivityNotification_bool_exp
  ): ActivityNotificationConnection!

  """
  fetch data from the table: "AirdropType"
  """
  AirdropType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [AirdropType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [AirdropType_order_by!]

    """filter the rows returned"""
    where: AirdropType_bool_exp
  ): AirdropTypeConnection!

  """
  fetch data from the table: "Airdrop"
  """
  Airdrop_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Airdrop_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Airdrop_order_by!]

    """filter the rows returned"""
    where: Airdrop_bool_exp
  ): AirdropConnection!

  """
  fetch data from the table: "ArtistSubmissionStatus"
  """
  ArtistSubmissionStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ArtistSubmissionStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ArtistSubmissionStatus_order_by!]

    """filter the rows returned"""
    where: ArtistSubmissionStatus_bool_exp
  ): ArtistSubmissionStatusConnection!

  """
  fetch data from the table: "ArtistSubmission"
  """
  ArtistSubmission_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ArtistSubmission_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ArtistSubmission_order_by!]

    """filter the rows returned"""
    where: ArtistSubmission_bool_exp
  ): ArtistSubmissionConnection!

  """
  fetch data from the table: "Asset"
  """
  Asset_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Asset_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Asset_order_by!]

    """filter the rows returned"""
    where: Asset_bool_exp
  ): AssetConnection!

  """
  fetch data from the table: "Attribute"
  """
  Attribute_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Attribute_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Attribute_order_by!]

    """filter the rows returned"""
    where: Attribute_bool_exp
  ): AttributeConnection!

  """
  fetch data from the table: "BonkClaim"
  """
  BonkClaim_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [BonkClaim_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [BonkClaim_order_by!]

    """filter the rows returned"""
    where: BonkClaim_bool_exp
  ): BonkClaimConnection!

  """
  fetch data from the table: "CampaignBenefitStatus"
  """
  CampaignBenefitStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignBenefitStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignBenefitStatus_order_by!]

    """filter the rows returned"""
    where: CampaignBenefitStatus_bool_exp
  ): CampaignBenefitStatusConnection!

  """
  fetch data from the table: "CampaignBenefitToNft"
  """
  CampaignBenefitToNft_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignBenefitToNft_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignBenefitToNft_order_by!]

    """filter the rows returned"""
    where: CampaignBenefitToNft_bool_exp
  ): CampaignBenefitToNftConnection!

  """
  fetch data from the table: "CampaignBenefit"
  """
  CampaignBenefit_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignBenefit_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignBenefit_order_by!]

    """filter the rows returned"""
    where: CampaignBenefit_bool_exp
  ): CampaignBenefitConnection!

  """
  fetch data from the table: "CampaignCategory"
  """
  CampaignCategory_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignCategory_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignCategory_order_by!]

    """filter the rows returned"""
    where: CampaignCategory_bool_exp
  ): CampaignCategoryConnection!

  """
  fetch data from the table: "CampaignColorScheme"
  """
  CampaignColorScheme_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignColorScheme_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignColorScheme_order_by!]

    """filter the rows returned"""
    where: CampaignColorScheme_bool_exp
  ): CampaignColorSchemeConnection!

  """
  fetch data from the table: "CampaignFundingTierType"
  """
  CampaignFundingTierType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignFundingTierType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignFundingTierType_order_by!]

    """filter the rows returned"""
    where: CampaignFundingTierType_bool_exp
  ): CampaignFundingTierTypeConnection!

  """
  fetch data from the table: "CampaignFundingTier"
  """
  CampaignFundingTier_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignFundingTier_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignFundingTier_order_by!]

    """filter the rows returned"""
    where: CampaignFundingTier_bool_exp
  ): CampaignFundingTierConnection!

  """
  fetch data from the table: "CampaignGoalType"
  """
  CampaignGoalType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignGoalType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignGoalType_order_by!]

    """filter the rows returned"""
    where: CampaignGoalType_bool_exp
  ): CampaignGoalTypeConnection!

  """
  fetch data from the table: "CampaignStatus"
  """
  CampaignStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignStatus_order_by!]

    """filter the rows returned"""
    where: CampaignStatus_bool_exp
  ): CampaignStatusConnection!

  """
  fetch data from the table: "CampaignTeamMemberRole"
  """
  CampaignTeamMemberRole_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignTeamMemberRole_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignTeamMemberRole_order_by!]

    """filter the rows returned"""
    where: CampaignTeamMemberRole_bool_exp
  ): CampaignTeamMemberRoleConnection!

  """
  fetch data from the table: "CampaignToCollaborator"
  """
  CampaignToCollaborator_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignToCollaborator_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignToCollaborator_order_by!]

    """filter the rows returned"""
    where: CampaignToCollaborator_bool_exp
  ): CampaignToCollaboratorConnection!

  """
  fetch data from the table: "CampaignToHolder"
  """
  CampaignToHolder_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignToHolder_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignToHolder_order_by!]

    """filter the rows returned"""
    where: CampaignToHolder_bool_exp
  ): CampaignToHolderConnection!

  """
  fetch data from the table: "CampaignToTeamMember"
  """
  CampaignToTeamMember_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CampaignToTeamMember_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CampaignToTeamMember_order_by!]

    """filter the rows returned"""
    where: CampaignToTeamMember_bool_exp
  ): CampaignToTeamMemberConnection!

  """
  fetch data from the table: "Campaign"
  """
  Campaign_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Campaign_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Campaign_order_by!]

    """filter the rows returned"""
    where: Campaign_bool_exp
  ): CampaignConnection!

  """
  fetch data from the table: "CandyMachineMerkleAllowlistInfo"
  """
  CandyMachineMerkleAllowlistInfo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CandyMachineMerkleAllowlistInfo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CandyMachineMerkleAllowlistInfo_order_by!]

    """filter the rows returned"""
    where: CandyMachineMerkleAllowlistInfo_bool_exp
  ): CandyMachineMerkleAllowlistInfoConnection!

  """
  fetch data from the table: "CandyMachine"
  """
  CandyMachine_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CandyMachine_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CandyMachine_order_by!]

    """filter the rows returned"""
    where: CandyMachine_bool_exp
  ): CandyMachineConnection!

  """
  fetch data from the table: "Claim"
  """
  Claim_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Claim_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Claim_order_by!]

    """filter the rows returned"""
    where: Claim_bool_exp
  ): ClaimConnection!

  """
  fetch data from the table: "CollectorSurvey"
  """
  CollectorSurvey_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CollectorSurvey_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CollectorSurvey_order_by!]

    """filter the rows returned"""
    where: CollectorSurvey_bool_exp
  ): CollectorSurveyConnection!

  """
  fetch data from the table: "Comment"
  """
  Comment_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Comment_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Comment_order_by!]

    """filter the rows returned"""
    where: Comment_bool_exp
  ): CommentConnection!

  """
  fetch data from the table: "CreatorInviteIssueReason"
  """
  CreatorInviteIssueReason_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CreatorInviteIssueReason_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CreatorInviteIssueReason_order_by!]

    """filter the rows returned"""
    where: CreatorInviteIssueReason_bool_exp
  ): CreatorInviteIssueReasonConnection!

  """
  fetch data from the table: "CreatorInvite"
  """
  CreatorInvite_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CreatorInvite_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CreatorInvite_order_by!]

    """filter the rows returned"""
    where: CreatorInvite_bool_exp
  ): CreatorInviteConnection!

  """
  fetch data from the table: "CreatorStory"
  """
  CreatorStory_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CreatorStory_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CreatorStory_order_by!]

    """filter the rows returned"""
    where: CreatorStory_bool_exp
  ): CreatorStoryConnection!

  """
  fetch data from the table: "CreatorSurvey"
  """
  CreatorSurvey_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CreatorSurvey_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CreatorSurvey_order_by!]

    """filter the rows returned"""
    where: CreatorSurvey_bool_exp
  ): CreatorSurveyConnection!

  """
  fetch data from the table: "CurrencyName"
  """
  CurrencyName_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [CurrencyName_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [CurrencyName_order_by!]

    """filter the rows returned"""
    where: CurrencyName_bool_exp
  ): CurrencyNameConnection!

  """
  fetch data from the table: "Currency"
  """
  Currency_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Currency_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Currency_order_by!]

    """filter the rows returned"""
    where: Currency_bool_exp
  ): CurrencyConnection!

  """
  fetch data from the table: "DeletedNftTransaction"
  """
  DeletedNftTransaction_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [DeletedNftTransaction_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [DeletedNftTransaction_order_by!]

    """filter the rows returned"""
    where: DeletedNftTransaction_bool_exp
  ): DeletedNftTransactionConnection!

  """
  fetch data from the table: "Dev"
  """
  Dev_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Dev_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Dev_order_by!]

    """filter the rows returned"""
    where: Dev_bool_exp
  ): DevConnection!

  """
  fetch data from the table: "DiscordAuthToDiscordRole"
  """
  DiscordAuthToDiscordRole_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [DiscordAuthToDiscordRole_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [DiscordAuthToDiscordRole_order_by!]

    """filter the rows returned"""
    where: DiscordAuthToDiscordRole_bool_exp
  ): DiscordAuthToDiscordRoleConnection!

  """
  fetch data from the table: "DiscordAuth"
  """
  DiscordAuth_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [DiscordAuth_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [DiscordAuth_order_by!]

    """filter the rows returned"""
    where: DiscordAuth_bool_exp
  ): DiscordAuthConnection!

  """
  fetch data from the table: "DiscordRole"
  """
  DiscordRole_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [DiscordRole_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [DiscordRole_order_by!]

    """filter the rows returned"""
    where: DiscordRole_bool_exp
  ): DiscordRoleConnection!

  """
  fetch data from the table: "EditionsMerkleAllowlistInfo"
  """
  EditionsMerkleAllowlistInfo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [EditionsMerkleAllowlistInfo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [EditionsMerkleAllowlistInfo_order_by!]

    """filter the rows returned"""
    where: EditionsMerkleAllowlistInfo_bool_exp
  ): EditionsMerkleAllowlistInfoConnection!

  """
  fetch data from the table: "ExchangeRates"
  """
  ExchangeRates_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ExchangeRates_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ExchangeRates_order_by!]

    """filter the rows returned"""
    where: ExchangeRates_bool_exp
  ): ExchangeRatesConnection!

  """
  fetch data from the table: "InstagramAuth"
  """
  InstagramAuth_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [InstagramAuth_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [InstagramAuth_order_by!]

    """filter the rows returned"""
    where: InstagramAuth_bool_exp
  ): InstagramAuthConnection!

  """
  fetch data from the table: "NftDisclosureType"
  """
  NftDisclosureType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftDisclosureType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftDisclosureType_order_by!]

    """filter the rows returned"""
    where: NftDisclosureType_bool_exp
  ): NftDisclosureTypeConnection!

  """
  fetch data from the table: "NftDisclosure"
  """
  NftDisclosure_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftDisclosure_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftDisclosure_order_by!]

    """filter the rows returned"""
    where: NftDisclosure_bool_exp
  ): NftDisclosureConnection!

  """
  fetch data from the table: "NftListing"
  """
  NftListing_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftListing_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftListing_order_by!]

    """filter the rows returned"""
    where: NftListing_bool_exp
  ): NftListingConnection!

  """
  fetch data from the table: "NftMetadata"
  """
  NftMetadata_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftMetadata_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftMetadata_order_by!]

    """filter the rows returned"""
    where: NftMetadata_bool_exp
  ): NftMetadataConnection!

  """
  fetch data from the table: "NftStatus"
  """
  NftStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftStatus_order_by!]

    """filter the rows returned"""
    where: NftStatus_bool_exp
  ): NftStatusConnection!

  """
  fetch data from the table: "NftToAttribute"
  """
  NftToAttribute_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftToAttribute_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftToAttribute_order_by!]

    """filter the rows returned"""
    where: NftToAttribute_bool_exp
  ): NftToAttributeConnection!

  """
  fetch data from the table: "NftToCollaborator"
  """
  NftToCollaborator_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftToCollaborator_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftToCollaborator_order_by!]

    """filter the rows returned"""
    where: NftToCollaborator_bool_exp
  ): NftToCollaboratorConnection!

  """
  fetch data from the table: "NftToTag"
  """
  NftToTag_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftToTag_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftToTag_order_by!]

    """filter the rows returned"""
    where: NftToTag_bool_exp
  ): NftToTagConnection!

  """
  fetch data from the table: "NftTransactionRaw"
  """
  NftTransactionRaw_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftTransactionRaw_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftTransactionRaw_order_by!]

    """filter the rows returned"""
    where: NftTransactionRaw_bool_exp
  ): NftTransactionRawConnection!

  """
  fetch data from the table: "NftTransactionSource"
  """
  NftTransactionSource_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftTransactionSource_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftTransactionSource_order_by!]

    """filter the rows returned"""
    where: NftTransactionSource_bool_exp
  ): NftTransactionSourceConnection!

  """
  fetch data from the table: "NftTransactionType"
  """
  NftTransactionType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftTransactionType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftTransactionType_order_by!]

    """filter the rows returned"""
    where: NftTransactionType_bool_exp
  ): NftTransactionTypeConnection!

  """
  fetch data from the table: "NftTransaction"
  """
  NftTransaction_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NftTransaction_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NftTransaction_order_by!]

    """filter the rows returned"""
    where: NftTransaction_bool_exp
  ): NftTransactionConnection!

  """
  fetch data from the table: "Nft"
  """
  Nft_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Nft_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Nft_order_by!]

    """filter the rows returned"""
    where: Nft_bool_exp
  ): NftConnection!

  """
  fetch data from the table: "NotificationChannel"
  """
  NotificationChannel_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NotificationChannel_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NotificationChannel_order_by!]

    """filter the rows returned"""
    where: NotificationChannel_bool_exp
  ): NotificationChannelConnection!

  """
  fetch data from the table: "NotificationType"
  """
  NotificationType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NotificationType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NotificationType_order_by!]

    """filter the rows returned"""
    where: NotificationType_bool_exp
  ): NotificationTypeConnection!

  """
  fetch data from the table: "NotificationUserPreference"
  """
  NotificationUserPreference_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [NotificationUserPreference_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [NotificationUserPreference_order_by!]

    """filter the rows returned"""
    where: NotificationUserPreference_bool_exp
  ): NotificationUserPreferenceConnection!

  """
  fetch data from the table: "Notification"
  """
  Notification_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Notification_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Notification_order_by!]

    """filter the rows returned"""
    where: Notification_bool_exp
  ): NotificationConnection!

  """
  fetch data from the table: "Offer"
  """
  Offer_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Offer_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Offer_order_by!]

    """filter the rows returned"""
    where: Offer_bool_exp
  ): OfferConnection!

  """
  fetch data from the table: "Photo"
  """
  Photo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Photo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Photo_order_by!]

    """filter the rows returned"""
    where: Photo_bool_exp
  ): PhotoConnection!

  """
  fetch data from the table: "PollOption"
  """
  PollOption_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [PollOption_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [PollOption_order_by!]

    """filter the rows returned"""
    where: PollOption_bool_exp
  ): PollOptionConnection!

  """
  fetch data from the table: "PollResponse"
  """
  PollResponse_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [PollResponse_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [PollResponse_order_by!]

    """filter the rows returned"""
    where: PollResponse_bool_exp
  ): PollResponseConnection!

  """
  fetch data from the table: "Poll"
  """
  Poll_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Poll_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Poll_order_by!]

    """filter the rows returned"""
    where: Poll_bool_exp
  ): PollConnection!

  """
  fetch data from the table: "PostVisibility"
  """
  PostVisibility_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [PostVisibility_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [PostVisibility_order_by!]

    """filter the rows returned"""
    where: PostVisibility_bool_exp
  ): PostVisibilityConnection!

  """
  fetch data from the table: "Post"
  """
  Post_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Post_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Post_order_by!]

    """filter the rows returned"""
    where: Post_bool_exp
  ): PostConnection!

  """
  fetch data from the table: "PriceFunctionType"
  """
  PriceFunctionType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [PriceFunctionType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [PriceFunctionType_order_by!]

    """filter the rows returned"""
    where: PriceFunctionType_bool_exp
  ): PriceFunctionTypeConnection!

  """
  fetch data from the table: "ReactionType"
  """
  ReactionType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ReactionType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ReactionType_order_by!]

    """filter the rows returned"""
    where: ReactionType_bool_exp
  ): ReactionTypeConnection!

  """
  fetch data from the table: "Reaction"
  """
  Reaction_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Reaction_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Reaction_order_by!]

    """filter the rows returned"""
    where: Reaction_bool_exp
  ): ReactionConnection!

  """
  fetch data from the table: "RequestStatus"
  """
  RequestStatus_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [RequestStatus_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [RequestStatus_order_by!]

    """filter the rows returned"""
    where: RequestStatus_bool_exp
  ): RequestStatusConnection!

  """
  fetch data from the table: "Request"
  """
  Request_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Request_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Request_order_by!]

    """filter the rows returned"""
    where: Request_bool_exp
  ): RequestConnection!

  """
  fetch data from the table: "SeriesType"
  """
  SeriesType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [SeriesType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [SeriesType_order_by!]

    """filter the rows returned"""
    where: SeriesType_bool_exp
  ): SeriesTypeConnection!

  """
  fetch data from the table: "Series"
  """
  Series_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Series_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Series_order_by!]

    """filter the rows returned"""
    where: Series_bool_exp
  ): SeriesConnection!

  """
  fetch data from the table: "SpotlightHeroUnitLayout"
  """
  SpotlightHeroUnitLayout_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [SpotlightHeroUnitLayout_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [SpotlightHeroUnitLayout_order_by!]

    """filter the rows returned"""
    where: SpotlightHeroUnitLayout_bool_exp
  ): SpotlightHeroUnitLayoutConnection!

  """
  fetch data from the table: "SpotlightType"
  """
  SpotlightType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [SpotlightType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [SpotlightType_order_by!]

    """filter the rows returned"""
    where: SpotlightType_bool_exp
  ): SpotlightTypeConnection!

  """
  fetch data from the table: "Spotlight"
  """
  Spotlight_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Spotlight_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Spotlight_order_by!]

    """filter the rows returned"""
    where: Spotlight_bool_exp
  ): SpotlightConnection!

  """
  fetch data from the table: "Tag"
  """
  Tag_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Tag_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Tag_order_by!]

    """filter the rows returned"""
    where: Tag_bool_exp
  ): TagConnection!

  """
  fetch data from the table: "TooniesShippingInfo"
  """
  TooniesShippingInfo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [TooniesShippingInfo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [TooniesShippingInfo_order_by!]

    """filter the rows returned"""
    where: TooniesShippingInfo_bool_exp
  ): TooniesShippingInfoConnection!

  """
  fetch data from the table: "TwitterAuth"
  """
  TwitterAuth_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [TwitterAuth_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [TwitterAuth_order_by!]

    """filter the rows returned"""
    where: TwitterAuth_bool_exp
  ): TwitterAuthConnection!

  """
  fetch data from the table: "UnlockableWinner"
  """
  UnlockableWinner_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [UnlockableWinner_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [UnlockableWinner_order_by!]

    """filter the rows returned"""
    where: UnlockableWinner_bool_exp
  ): UnlockableWinnerConnection!

  """
  fetch data from the table: "Unlockable"
  """
  Unlockable_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Unlockable_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Unlockable_order_by!]

    """filter the rows returned"""
    where: Unlockable_bool_exp
  ): UnlockableConnection!

  """
  fetch data from the table: "UserFollows"
  """
  UserFollows_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [UserFollows_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [UserFollows_order_by!]

    """filter the rows returned"""
    where: UserFollows_bool_exp
  ): UserFollowsConnection!

  """
  fetch data from the table: "User"
  """
  User_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [User_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [User_order_by!]

    """filter the rows returned"""
    where: User_bool_exp
  ): UserConnection!

  """
  fetch data from the table: "Video"
  """
  Video_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Video_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Video_order_by!]

    """filter the rows returned"""
    where: Video_bool_exp
  ): VideoConnection!

  """
  fetch data from the table: "VoteReason"
  """
  VoteReason_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [VoteReason_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [VoteReason_order_by!]

    """filter the rows returned"""
    where: VoteReason_bool_exp
  ): VoteReasonConnection!

  """
  fetch data from the table: "VoteType"
  """
  VoteType_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [VoteType_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [VoteType_order_by!]

    """filter the rows returned"""
    where: VoteType_bool_exp
  ): VoteTypeConnection!

  """
  fetch data from the table: "Vote"
  """
  Vote_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Vote_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Vote_order_by!]

    """filter the rows returned"""
    where: Vote_bool_exp
  ): VoteConnection!

  """
  fetch data from the table: "Whitelist"
  """
  Whitelist_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [Whitelist_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [Whitelist_order_by!]

    """filter the rows returned"""
    where: Whitelist_bool_exp
  ): WhitelistConnection!
  node(
    """A globally unique id"""
    id: ID!
  ): Node
}

"""
columns and relationships of "Tag"
"""
type Tag implements Node {
  id: ID!
  value: String!

  """
  A computed field, executes function "tag_length_fn"
  """
  valueLength: Int
}

"""
Boolean expression to filter rows from the table "Tag". All fields are combined with a logical 'AND'.
"""
input Tag_bool_exp {
  _and: [Tag_bool_exp!]
  _not: Tag_bool_exp
  _or: [Tag_bool_exp!]
  id: uuid_comparison_exp
  value: String_comparison_exp
  valueLength: Int_comparison_exp
}

"""
unique or primary key constraints on table "Tag"
"""
enum Tag_constraint {
  """unique or primary key constraint"""
  Tag_pkey

  """unique or primary key constraint"""
  Tag_value_key
}

"""
input type for inserting data into table "Tag"
"""
input Tag_insert_input {
  id: uuid
  value: String
}

"""
response of any mutation on the table "Tag"
"""
type Tag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Tag!]!
}

"""
input type for inserting object relation for remote table "Tag"
"""
input Tag_obj_rel_insert_input {
  data: Tag_insert_input!

  """upsert condition"""
  on_conflict: Tag_on_conflict
}

"""
on_conflict condition type for table "Tag"
"""
input Tag_on_conflict {
  constraint: Tag_constraint!
  update_columns: [Tag_update_column!]! = []
  where: Tag_bool_exp
}

"""Ordering options when selecting data from "Tag"."""
input Tag_order_by {
  id: order_by
  value: order_by
  valueLength: order_by
}

"""primary key columns input for table: Tag"""
input Tag_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Tag"
"""
enum Tag_select_column {
  """column name"""
  id

  """column name"""
  value
}

"""
input type for updating data in table "Tag"
"""
input Tag_set_input {
  id: uuid
  value: String
}

"""
update columns of table "Tag"
"""
enum Tag_update_column {
  """column name"""
  id

  """column name"""
  value
}

"""
A Relay connection object on "Tag"
"""
type TagConnection {
  edges: [TagEdge!]!
  pageInfo: PageInfo!
}

type TagEdge {
  cursor: String!
  node: Tag!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "TooniesShippingInfo"
"""
type TooniesShippingInfo implements Node {
  email: String!
  id: ID!
  name: String!
  proofOfOwnershipTokenMint: String!
  shippingAddress: String!
  swappedNftMint: String!
  type: String!
  userId: String!
}

"""
Boolean expression to filter rows from the table "TooniesShippingInfo". All fields are combined with a logical 'AND'.
"""
input TooniesShippingInfo_bool_exp {
  _and: [TooniesShippingInfo_bool_exp!]
  _not: TooniesShippingInfo_bool_exp
  _or: [TooniesShippingInfo_bool_exp!]
  email: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  proofOfOwnershipTokenMint: String_comparison_exp
  shippingAddress: String_comparison_exp
  swappedNftMint: String_comparison_exp
  type: String_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "TooniesShippingInfo"
"""
enum TooniesShippingInfo_constraint {
  """unique or primary key constraint"""
  TooniesShippingInfo_pkey

  """unique or primary key constraint"""
  TooniesShippingInfo_proofOfOwnershipTokenMint_key

  """unique or primary key constraint"""
  TooniesShippingInfo_swappedNftMint_key
}

"""
input type for inserting data into table "TooniesShippingInfo"
"""
input TooniesShippingInfo_insert_input {
  email: String
  id: uuid
  name: String
  proofOfOwnershipTokenMint: String
  shippingAddress: String
  swappedNftMint: String
  type: String
  userId: String
}

"""
response of any mutation on the table "TooniesShippingInfo"
"""
type TooniesShippingInfo_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [TooniesShippingInfo!]!
}

"""
on_conflict condition type for table "TooniesShippingInfo"
"""
input TooniesShippingInfo_on_conflict {
  constraint: TooniesShippingInfo_constraint!
  update_columns: [TooniesShippingInfo_update_column!]! = []
  where: TooniesShippingInfo_bool_exp
}

"""Ordering options when selecting data from "TooniesShippingInfo"."""
input TooniesShippingInfo_order_by {
  email: order_by
  id: order_by
  name: order_by
  proofOfOwnershipTokenMint: order_by
  shippingAddress: order_by
  swappedNftMint: order_by
  type: order_by
  userId: order_by
}

"""primary key columns input for table: TooniesShippingInfo"""
input TooniesShippingInfo_pk_columns_input {
  id: uuid!
}

"""
select columns of table "TooniesShippingInfo"
"""
enum TooniesShippingInfo_select_column {
  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  proofOfOwnershipTokenMint

  """column name"""
  shippingAddress

  """column name"""
  swappedNftMint

  """column name"""
  type

  """column name"""
  userId
}

"""
input type for updating data in table "TooniesShippingInfo"
"""
input TooniesShippingInfo_set_input {
  email: String
  id: uuid
  name: String
  proofOfOwnershipTokenMint: String
  shippingAddress: String
  swappedNftMint: String
  type: String
  userId: String
}

"""
update columns of table "TooniesShippingInfo"
"""
enum TooniesShippingInfo_update_column {
  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  proofOfOwnershipTokenMint

  """column name"""
  shippingAddress

  """column name"""
  swappedNftMint

  """column name"""
  type

  """column name"""
  userId
}

"""
A Relay connection object on "TooniesShippingInfo"
"""
type TooniesShippingInfoConnection {
  edges: [TooniesShippingInfoEdge!]!
  pageInfo: PageInfo!
}

type TooniesShippingInfoEdge {
  cursor: String!
  node: TooniesShippingInfo!
}

"""
columns and relationships of "top_collector_stats"
"""
type top_collector_stats {
  """An object relationship"""
  Collector: User
  collectorId: String
  creatorsSupportedCount: bigint
  nftCount: bigint
  totalPaid: bigint
}

"""
Boolean expression to filter rows from the table "top_collector_stats". All fields are combined with a logical 'AND'.
"""
input top_collector_stats_bool_exp {
  Collector: User_bool_exp
  _and: [top_collector_stats_bool_exp!]
  _not: top_collector_stats_bool_exp
  _or: [top_collector_stats_bool_exp!]
  collectorId: String_comparison_exp
  creatorsSupportedCount: bigint_comparison_exp
  nftCount: bigint_comparison_exp
  totalPaid: bigint_comparison_exp
}

"""
input type for incrementing numeric columns in table "top_collector_stats"
"""
input top_collector_stats_inc_input {
  creatorsSupportedCount: bigint
  nftCount: bigint
  totalPaid: bigint
}

"""
input type for inserting data into table "top_collector_stats"
"""
input top_collector_stats_insert_input {
  Collector: User_obj_rel_insert_input
  collectorId: String
  creatorsSupportedCount: bigint
  nftCount: bigint
  totalPaid: bigint
}

"""
response of any mutation on the table "top_collector_stats"
"""
type top_collector_stats_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [top_collector_stats!]!
}

"""
input type for updating data in table "top_collector_stats"
"""
input top_collector_stats_set_input {
  collectorId: String
  creatorsSupportedCount: bigint
  nftCount: bigint
  totalPaid: bigint
}

"""
columns and relationships of "top_creator_stats"
"""
type top_creator_stats {
  """An object relationship"""
  Creator: User
  collectorCount: bigint
  creatorId: String
  nftCount: bigint
  totalSales: bigint
}

"""
Boolean expression to filter rows from the table "top_creator_stats". All fields are combined with a logical 'AND'.
"""
input top_creator_stats_bool_exp {
  Creator: User_bool_exp
  _and: [top_creator_stats_bool_exp!]
  _not: top_creator_stats_bool_exp
  _or: [top_creator_stats_bool_exp!]
  collectorCount: bigint_comparison_exp
  creatorId: String_comparison_exp
  nftCount: bigint_comparison_exp
  totalSales: bigint_comparison_exp
}

"""
input type for incrementing numeric columns in table "top_creator_stats"
"""
input top_creator_stats_inc_input {
  collectorCount: bigint
  nftCount: bigint
  totalSales: bigint
}

"""
input type for inserting data into table "top_creator_stats"
"""
input top_creator_stats_insert_input {
  Creator: User_obj_rel_insert_input
  collectorCount: bigint
  creatorId: String
  nftCount: bigint
  totalSales: bigint
}

"""
response of any mutation on the table "top_creator_stats"
"""
type top_creator_stats_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [top_creator_stats!]!
}

"""
input type for updating data in table "top_creator_stats"
"""
input top_creator_stats_set_input {
  collectorCount: bigint
  creatorId: String
  nftCount: bigint
  totalSales: bigint
}

"""Auth credentials for linked Twitter accounts"""
type TwitterAuth implements Node {
  accessToken: String
  accessTokenSecret: String
  id: ID!
  requestToken: String
  requestTokenSecret: String
  timeCreated: timestamptz!
  userId: String!
}

"""
Boolean expression to filter rows from the table "TwitterAuth". All fields are combined with a logical 'AND'.
"""
input TwitterAuth_bool_exp {
  _and: [TwitterAuth_bool_exp!]
  _not: TwitterAuth_bool_exp
  _or: [TwitterAuth_bool_exp!]
  accessToken: String_comparison_exp
  accessTokenSecret: String_comparison_exp
  id: uuid_comparison_exp
  requestToken: String_comparison_exp
  requestTokenSecret: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "TwitterAuth"
"""
enum TwitterAuth_constraint {
  """unique or primary key constraint"""
  TwitterAuth_pkey

  """unique or primary key constraint"""
  TwitterAuth_requestToken_key

  """unique or primary key constraint"""
  TwitterAuth_userId_key
}

"""
input type for inserting data into table "TwitterAuth"
"""
input TwitterAuth_insert_input {
  accessToken: String
  accessTokenSecret: String
  id: uuid
  requestToken: String
  requestTokenSecret: String
  timeCreated: timestamptz
  userId: String
}

"""
response of any mutation on the table "TwitterAuth"
"""
type TwitterAuth_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [TwitterAuth!]!
}

"""
on_conflict condition type for table "TwitterAuth"
"""
input TwitterAuth_on_conflict {
  constraint: TwitterAuth_constraint!
  update_columns: [TwitterAuth_update_column!]! = []
  where: TwitterAuth_bool_exp
}

"""Ordering options when selecting data from "TwitterAuth"."""
input TwitterAuth_order_by {
  accessToken: order_by
  accessTokenSecret: order_by
  id: order_by
  requestToken: order_by
  requestTokenSecret: order_by
  timeCreated: order_by
  userId: order_by
}

"""primary key columns input for table: TwitterAuth"""
input TwitterAuth_pk_columns_input {
  userId: String!
}

"""
select columns of table "TwitterAuth"
"""
enum TwitterAuth_select_column {
  """column name"""
  accessToken

  """column name"""
  accessTokenSecret

  """column name"""
  id

  """column name"""
  requestToken

  """column name"""
  requestTokenSecret

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
input type for updating data in table "TwitterAuth"
"""
input TwitterAuth_set_input {
  accessToken: String
  accessTokenSecret: String
  id: uuid
  requestToken: String
  requestTokenSecret: String
  timeCreated: timestamptz
  userId: String
}

"""
update columns of table "TwitterAuth"
"""
enum TwitterAuth_update_column {
  """column name"""
  accessToken

  """column name"""
  accessTokenSecret

  """column name"""
  id

  """column name"""
  requestToken

  """column name"""
  requestTokenSecret

  """column name"""
  timeCreated

  """column name"""
  userId
}

"""
A Relay connection object on "TwitterAuth"
"""
type TwitterAuthConnection {
  edges: [TwitterAuthEdge!]!
  pageInfo: PageInfo!
}

type TwitterAuthEdge {
  cursor: String!
  node: TwitterAuth!
}

"""
Tracks unlockable items which are attached to auctions and instant sales
"""
type Unlockable implements Node {
  """An object relationship"""
  Asset: Asset!

  """An object relationship"""
  NftListing: NftListing

  """An array relationship"""
  UnlockableWinners(
    """distinct select on columns"""
    distinct_on: [UnlockableWinner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [UnlockableWinner_order_by!]

    """filter the rows returned"""
    where: UnlockableWinner_bool_exp
  ): [UnlockableWinner!]!

  """An aggregate relationship"""
  UnlockableWinners_aggregate(
    """distinct select on columns"""
    distinct_on: [UnlockableWinner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [UnlockableWinner_order_by!]

    """filter the rows returned"""
    where: UnlockableWinner_bool_exp
  ): UnlockableWinner_aggregate!

  """An array relationship connection"""
  UnlockableWinners_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [UnlockableWinner_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [UnlockableWinner_order_by!]

    """filter the rows returned"""
    where: UnlockableWinner_bool_exp
  ): UnlockableWinnerConnection!
  activationPriceCurrencyId: uuid!
  activationPriceInLamports: bigint
  assetId: uuid!
  category: String!
  description: String
  id: ID!
  name: String!
  timeCreated: timestamptz!
}

"""
Boolean expression to filter rows from the table "Unlockable". All fields are combined with a logical 'AND'.
"""
input Unlockable_bool_exp {
  Asset: Asset_bool_exp
  NftListing: NftListing_bool_exp
  UnlockableWinners: UnlockableWinner_bool_exp
  _and: [Unlockable_bool_exp!]
  _not: Unlockable_bool_exp
  _or: [Unlockable_bool_exp!]
  activationPriceCurrencyId: uuid_comparison_exp
  activationPriceInLamports: bigint_comparison_exp
  assetId: uuid_comparison_exp
  category: String_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "Unlockable"
"""
enum Unlockable_constraint {
  """unique or primary key constraint"""
  Unlockable_assetId_key

  """unique or primary key constraint"""
  Unlockable_pkey
}

"""
input type for incrementing numeric columns in table "Unlockable"
"""
input Unlockable_inc_input {
  activationPriceInLamports: bigint
}

"""
input type for inserting data into table "Unlockable"
"""
input Unlockable_insert_input {
  Asset: Asset_obj_rel_insert_input
  NftListing: NftListing_obj_rel_insert_input
  UnlockableWinners: UnlockableWinner_arr_rel_insert_input
  activationPriceCurrencyId: uuid
  activationPriceInLamports: bigint
  assetId: uuid
  category: String
  description: String
  id: uuid
  name: String
  timeCreated: timestamptz
}

"""
response of any mutation on the table "Unlockable"
"""
type Unlockable_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Unlockable!]!
}

"""
input type for inserting object relation for remote table "Unlockable"
"""
input Unlockable_obj_rel_insert_input {
  data: Unlockable_insert_input!

  """upsert condition"""
  on_conflict: Unlockable_on_conflict
}

"""
on_conflict condition type for table "Unlockable"
"""
input Unlockable_on_conflict {
  constraint: Unlockable_constraint!
  update_columns: [Unlockable_update_column!]! = []
  where: Unlockable_bool_exp
}

"""Ordering options when selecting data from "Unlockable"."""
input Unlockable_order_by {
  Asset: Asset_order_by
  NftListing: NftListing_order_by
  UnlockableWinners_aggregate: UnlockableWinner_aggregate_order_by
  activationPriceCurrencyId: order_by
  activationPriceInLamports: order_by
  assetId: order_by
  category: order_by
  description: order_by
  id: order_by
  name: order_by
  timeCreated: order_by
}

"""primary key columns input for table: Unlockable"""
input Unlockable_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Unlockable"
"""
enum Unlockable_select_column {
  """column name"""
  activationPriceCurrencyId

  """column name"""
  activationPriceInLamports

  """column name"""
  assetId

  """column name"""
  category

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  timeCreated
}

"""
input type for updating data in table "Unlockable"
"""
input Unlockable_set_input {
  activationPriceCurrencyId: uuid
  activationPriceInLamports: bigint
  assetId: uuid
  category: String
  description: String
  id: uuid
  name: String
  timeCreated: timestamptz
}

"""
update columns of table "Unlockable"
"""
enum Unlockable_update_column {
  """column name"""
  activationPriceCurrencyId

  """column name"""
  activationPriceInLamports

  """column name"""
  assetId

  """column name"""
  category

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  timeCreated
}

"""
A Relay connection object on "Unlockable"
"""
type UnlockableConnection {
  edges: [UnlockableEdge!]!
  pageInfo: PageInfo!
}

type UnlockableEdge {
  cursor: String!
  node: Unlockable!
}

"""
Records recipient information for users who will receive an unlockable item from an auction
"""
type UnlockableWinner implements Node {
  """An object relationship"""
  Unlockable: Unlockable!

  """
  Set to true if the buyer chooses to dismiss the "Share Info" call to action in the UI
  """
  hasBuyerDismissedShareInfoCta: Boolean!

  """
  Set to true if the creator chooses to dismiss the "See Info" call to action in the UI
  """
  hasCreatorDismissedSeeInfoCta: Boolean!
  id: ID!
  timeCreated: timestamptz!
  unlockableId: uuid!
  userEmail: String
  userId: String!
}

"""
aggregated selection of "UnlockableWinner"
"""
type UnlockableWinner_aggregate {
  aggregate: UnlockableWinner_aggregate_fields
  nodes: [UnlockableWinner!]!
}

"""
aggregate fields of "UnlockableWinner"
"""
type UnlockableWinner_aggregate_fields {
  count(columns: [UnlockableWinner_select_column!], distinct: Boolean): Int!
  max: UnlockableWinner_max_fields
  min: UnlockableWinner_min_fields
}

"""
order by aggregate values of table "UnlockableWinner"
"""
input UnlockableWinner_aggregate_order_by {
  count: order_by
  max: UnlockableWinner_max_order_by
  min: UnlockableWinner_min_order_by
}

"""
input type for inserting array relation for remote table "UnlockableWinner"
"""
input UnlockableWinner_arr_rel_insert_input {
  data: [UnlockableWinner_insert_input!]!

  """upsert condition"""
  on_conflict: UnlockableWinner_on_conflict
}

"""
Boolean expression to filter rows from the table "UnlockableWinner". All fields are combined with a logical 'AND'.
"""
input UnlockableWinner_bool_exp {
  Unlockable: Unlockable_bool_exp
  _and: [UnlockableWinner_bool_exp!]
  _not: UnlockableWinner_bool_exp
  _or: [UnlockableWinner_bool_exp!]
  hasBuyerDismissedShareInfoCta: Boolean_comparison_exp
  hasCreatorDismissedSeeInfoCta: Boolean_comparison_exp
  id: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
  unlockableId: uuid_comparison_exp
  userEmail: String_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "UnlockableWinner"
"""
enum UnlockableWinner_constraint {
  """unique or primary key constraint"""
  UnlockableWinner_pkey
}

"""
input type for inserting data into table "UnlockableWinner"
"""
input UnlockableWinner_insert_input {
  Unlockable: Unlockable_obj_rel_insert_input

  """
  Set to true if the buyer chooses to dismiss the "Share Info" call to action in the UI
  """
  hasBuyerDismissedShareInfoCta: Boolean

  """
  Set to true if the creator chooses to dismiss the "See Info" call to action in the UI
  """
  hasCreatorDismissedSeeInfoCta: Boolean
  id: uuid
  timeCreated: timestamptz
  unlockableId: uuid
  userEmail: String
  userId: String
}

"""aggregate max on columns"""
type UnlockableWinner_max_fields {
  id: uuid
  timeCreated: timestamptz
  unlockableId: uuid
  userEmail: String
  userId: String
}

"""
order by max() on columns of table "UnlockableWinner"
"""
input UnlockableWinner_max_order_by {
  id: order_by
  timeCreated: order_by
  unlockableId: order_by
  userEmail: order_by
  userId: order_by
}

"""aggregate min on columns"""
type UnlockableWinner_min_fields {
  id: uuid
  timeCreated: timestamptz
  unlockableId: uuid
  userEmail: String
  userId: String
}

"""
order by min() on columns of table "UnlockableWinner"
"""
input UnlockableWinner_min_order_by {
  id: order_by
  timeCreated: order_by
  unlockableId: order_by
  userEmail: order_by
  userId: order_by
}

"""
response of any mutation on the table "UnlockableWinner"
"""
type UnlockableWinner_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [UnlockableWinner!]!
}

"""
on_conflict condition type for table "UnlockableWinner"
"""
input UnlockableWinner_on_conflict {
  constraint: UnlockableWinner_constraint!
  update_columns: [UnlockableWinner_update_column!]! = []
  where: UnlockableWinner_bool_exp
}

"""Ordering options when selecting data from "UnlockableWinner"."""
input UnlockableWinner_order_by {
  Unlockable: Unlockable_order_by
  hasBuyerDismissedShareInfoCta: order_by
  hasCreatorDismissedSeeInfoCta: order_by
  id: order_by
  timeCreated: order_by
  unlockableId: order_by
  userEmail: order_by
  userId: order_by
}

"""primary key columns input for table: UnlockableWinner"""
input UnlockableWinner_pk_columns_input {
  unlockableId: uuid!
  userId: String!
}

"""
select columns of table "UnlockableWinner"
"""
enum UnlockableWinner_select_column {
  """column name"""
  hasBuyerDismissedShareInfoCta

  """column name"""
  hasCreatorDismissedSeeInfoCta

  """column name"""
  id

  """column name"""
  timeCreated

  """column name"""
  unlockableId

  """column name"""
  userEmail

  """column name"""
  userId
}

"""
input type for updating data in table "UnlockableWinner"
"""
input UnlockableWinner_set_input {
  """
  Set to true if the buyer chooses to dismiss the "Share Info" call to action in the UI
  """
  hasBuyerDismissedShareInfoCta: Boolean

  """
  Set to true if the creator chooses to dismiss the "See Info" call to action in the UI
  """
  hasCreatorDismissedSeeInfoCta: Boolean
  id: uuid
  timeCreated: timestamptz
  unlockableId: uuid
  userEmail: String
  userId: String
}

"""
update columns of table "UnlockableWinner"
"""
enum UnlockableWinner_update_column {
  """column name"""
  hasBuyerDismissedShareInfoCta

  """column name"""
  hasCreatorDismissedSeeInfoCta

  """column name"""
  id

  """column name"""
  timeCreated

  """column name"""
  unlockableId

  """column name"""
  userEmail

  """column name"""
  userId
}

"""
A Relay connection object on "UnlockableWinner"
"""
type UnlockableWinnerConnection {
  edges: [UnlockableWinnerEdge!]!
  pageInfo: PageInfo!
}

type UnlockableWinnerEdge {
  cursor: String!
  node: UnlockableWinner!
}

"""
columns and relationships of "User"
"""
type User implements Node {
  """An array relationship"""
  ArtistSubmissions(
    """distinct select on columns"""
    distinct_on: [ArtistSubmission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ArtistSubmission_order_by!]

    """filter the rows returned"""
    where: ArtistSubmission_bool_exp
  ): [ArtistSubmission!]!

  """An aggregate relationship"""
  ArtistSubmissions_aggregate(
    """distinct select on columns"""
    distinct_on: [ArtistSubmission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ArtistSubmission_order_by!]

    """filter the rows returned"""
    where: ArtistSubmission_bool_exp
  ): ArtistSubmission_aggregate!

  """An array relationship connection"""
  ArtistSubmissions_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [ArtistSubmission_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [ArtistSubmission_order_by!]

    """filter the rows returned"""
    where: ArtistSubmission_bool_exp
  ): ArtistSubmissionConnection!

  """An object relationship"""
  CoverPhoto: Photo

  """An object relationship"""
  CreatorStory: CreatorStory

  """An object relationship"""
  DiscordAuth: DiscordAuth

  """An array relationship"""
  Followed(
    """distinct select on columns"""
    distinct_on: [UserFollows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [UserFollows_order_by!]

    """filter the rows returned"""
    where: UserFollows_bool_exp
  ): [UserFollows!]!

  """An aggregate relationship"""
  Followed_aggregate(
    """distinct select on columns"""
    distinct_on: [UserFollows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [UserFollows_order_by!]

    """filter the rows returned"""
    where: UserFollows_bool_exp
  ): UserFollows_aggregate!

  """An array relationship connection"""
  Followed_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [UserFollows_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [UserFollows_order_by!]

    """filter the rows returned"""
    where: UserFollows_bool_exp
  ): UserFollowsConnection!

  """An array relationship"""
  Followers(
    """distinct select on columns"""
    distinct_on: [UserFollows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [UserFollows_order_by!]

    """filter the rows returned"""
    where: UserFollows_bool_exp
  ): [UserFollows!]!

  """An aggregate relationship"""
  Followers_aggregate(
    """distinct select on columns"""
    distinct_on: [UserFollows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [UserFollows_order_by!]

    """filter the rows returned"""
    where: UserFollows_bool_exp
  ): UserFollows_aggregate!

  """An array relationship connection"""
  Followers_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [UserFollows_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [UserFollows_order_by!]

    """filter the rows returned"""
    where: UserFollows_bool_exp
  ): UserFollowsConnection!

  """An object relationship"""
  ProfilePhoto: Photo
  bio: String
  coverPhotoId: uuid
  discordHandle: String
  displayName: String
  email: String

  """
  DEPRECATED in favor of the NotificationUserPreference table. Please DO NOT USE this column
  """
  emailBlocklist(
    """JSON select path"""
    path: String
  ): jsonb!
  hasCompletedSignup: Boolean!
  hasTakenCollectorSurvey2023: Boolean
  hasTakenCreatorSurvey2023: Boolean

  """
  DEPRECATED in favor of the unseenActivityNotificationsCountForViewer query field. Please DO NOT USE this column
  """
  hasUnseenActivity: Boolean
  id: ID!
  instagramName: String

  """
  A computed field, executes function "is_collector_fn"
  """
  isCollector: Boolean
  isCollector2: Boolean!
  isWhitelisted: Boolean!
  profilePhotoId: uuid
  seriesOrder(
    """JSON select path"""
    path: String
  ): jsonb!
  shouldBlurNsfwContent: Boolean!
  shouldSeeDiscordOnboardingPrompt: Boolean!
  timeCreated: timestamptz!
  twitterName: String
  username: String!

  """
  A computed field, executes function "username_length_fn"
  """
  usernameLength: Int
  websiteUrl: String
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input User_append_input {
  """
  DEPRECATED in favor of the NotificationUserPreference table. Please DO NOT USE this column
  """
  emailBlocklist: jsonb
  seriesOrder: jsonb
}

"""
Boolean expression to filter rows from the table "User". All fields are combined with a logical 'AND'.
"""
input User_bool_exp {
  ArtistSubmissions: ArtistSubmission_bool_exp
  CoverPhoto: Photo_bool_exp
  CreatorStory: CreatorStory_bool_exp
  DiscordAuth: DiscordAuth_bool_exp
  Followed: UserFollows_bool_exp
  Followers: UserFollows_bool_exp
  ProfilePhoto: Photo_bool_exp
  _and: [User_bool_exp!]
  _not: User_bool_exp
  _or: [User_bool_exp!]
  bio: String_comparison_exp
  coverPhotoId: uuid_comparison_exp
  discordHandle: String_comparison_exp
  displayName: String_comparison_exp
  email: String_comparison_exp
  emailBlocklist: jsonb_comparison_exp
  hasCompletedSignup: Boolean_comparison_exp
  hasTakenCollectorSurvey2023: Boolean_comparison_exp
  hasTakenCreatorSurvey2023: Boolean_comparison_exp
  hasUnseenActivity: Boolean_comparison_exp
  id: String_comparison_exp
  instagramName: String_comparison_exp
  isCollector: Boolean_comparison_exp
  isCollector2: Boolean_comparison_exp
  isWhitelisted: Boolean_comparison_exp
  profilePhotoId: uuid_comparison_exp
  seriesOrder: jsonb_comparison_exp
  shouldBlurNsfwContent: Boolean_comparison_exp
  shouldSeeDiscordOnboardingPrompt: Boolean_comparison_exp
  timeCreated: timestamptz_comparison_exp
  twitterName: String_comparison_exp
  username: String_comparison_exp
  usernameLength: Int_comparison_exp
  websiteUrl: String_comparison_exp
}

"""
unique or primary key constraints on table "User"
"""
enum User_constraint {
  """unique or primary key constraint"""
  User_coverPhotoId_key

  """unique or primary key constraint"""
  User_email_key

  """unique or primary key constraint"""
  User_pkey

  """unique or primary key constraint"""
  User_profilePhotoId_key

  """unique or primary key constraint"""
  User_username_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input User_delete_at_path_input {
  """
  DEPRECATED in favor of the NotificationUserPreference table. Please DO NOT USE this column
  """
  emailBlocklist: [String!]
  seriesOrder: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input User_delete_elem_input {
  """
  DEPRECATED in favor of the NotificationUserPreference table. Please DO NOT USE this column
  """
  emailBlocklist: Int
  seriesOrder: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input User_delete_key_input {
  """
  DEPRECATED in favor of the NotificationUserPreference table. Please DO NOT USE this column
  """
  emailBlocklist: String
  seriesOrder: String
}

"""
input type for inserting data into table "User"
"""
input User_insert_input {
  ArtistSubmissions: ArtistSubmission_arr_rel_insert_input
  CoverPhoto: Photo_obj_rel_insert_input
  CreatorStory: CreatorStory_obj_rel_insert_input
  DiscordAuth: DiscordAuth_obj_rel_insert_input
  Followed: UserFollows_arr_rel_insert_input
  Followers: UserFollows_arr_rel_insert_input
  ProfilePhoto: Photo_obj_rel_insert_input
  bio: String
  coverPhotoId: uuid
  discordHandle: String
  displayName: String
  email: String

  """
  DEPRECATED in favor of the NotificationUserPreference table. Please DO NOT USE this column
  """
  emailBlocklist: jsonb
  hasCompletedSignup: Boolean
  hasTakenCollectorSurvey2023: Boolean
  hasTakenCreatorSurvey2023: Boolean

  """
  DEPRECATED in favor of the unseenActivityNotificationsCountForViewer query field. Please DO NOT USE this column
  """
  hasUnseenActivity: Boolean
  id: String
  instagramName: String
  isCollector2: Boolean
  isWhitelisted: Boolean
  profilePhotoId: uuid
  seriesOrder: jsonb
  shouldBlurNsfwContent: Boolean
  shouldSeeDiscordOnboardingPrompt: Boolean
  timeCreated: timestamptz
  twitterName: String
  username: String
  websiteUrl: String
}

"""
response of any mutation on the table "User"
"""
type User_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [User!]!
}

"""
input type for inserting object relation for remote table "User"
"""
input User_obj_rel_insert_input {
  data: User_insert_input!

  """upsert condition"""
  on_conflict: User_on_conflict
}

"""
on_conflict condition type for table "User"
"""
input User_on_conflict {
  constraint: User_constraint!
  update_columns: [User_update_column!]! = []
  where: User_bool_exp
}

"""Ordering options when selecting data from "User"."""
input User_order_by {
  ArtistSubmissions_aggregate: ArtistSubmission_aggregate_order_by
  CoverPhoto: Photo_order_by
  CreatorStory: CreatorStory_order_by
  DiscordAuth: DiscordAuth_order_by
  Followed_aggregate: UserFollows_aggregate_order_by
  Followers_aggregate: UserFollows_aggregate_order_by
  ProfilePhoto: Photo_order_by
  bio: order_by
  coverPhotoId: order_by
  discordHandle: order_by
  displayName: order_by
  email: order_by
  emailBlocklist: order_by
  hasCompletedSignup: order_by
  hasTakenCollectorSurvey2023: order_by
  hasTakenCreatorSurvey2023: order_by
  hasUnseenActivity: order_by
  id: order_by
  instagramName: order_by
  isCollector: order_by
  isCollector2: order_by
  isWhitelisted: order_by
  profilePhotoId: order_by
  seriesOrder: order_by
  shouldBlurNsfwContent: order_by
  shouldSeeDiscordOnboardingPrompt: order_by
  timeCreated: order_by
  twitterName: order_by
  username: order_by
  usernameLength: order_by
  websiteUrl: order_by
}

"""primary key columns input for table: User"""
input User_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input User_prepend_input {
  """
  DEPRECATED in favor of the NotificationUserPreference table. Please DO NOT USE this column
  """
  emailBlocklist: jsonb
  seriesOrder: jsonb
}

"""
select columns of table "User"
"""
enum User_select_column {
  """column name"""
  bio

  """column name"""
  coverPhotoId

  """column name"""
  discordHandle

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailBlocklist

  """column name"""
  hasCompletedSignup

  """column name"""
  hasTakenCollectorSurvey2023

  """column name"""
  hasTakenCreatorSurvey2023

  """column name"""
  hasUnseenActivity

  """column name"""
  id

  """column name"""
  instagramName

  """column name"""
  isCollector2

  """column name"""
  isWhitelisted

  """column name"""
  profilePhotoId

  """column name"""
  seriesOrder

  """column name"""
  shouldBlurNsfwContent

  """column name"""
  shouldSeeDiscordOnboardingPrompt

  """column name"""
  timeCreated

  """column name"""
  twitterName

  """column name"""
  username

  """column name"""
  websiteUrl
}

"""
input type for updating data in table "User"
"""
input User_set_input {
  bio: String
  coverPhotoId: uuid
  discordHandle: String
  displayName: String
  email: String

  """
  DEPRECATED in favor of the NotificationUserPreference table. Please DO NOT USE this column
  """
  emailBlocklist: jsonb
  hasCompletedSignup: Boolean
  hasTakenCollectorSurvey2023: Boolean
  hasTakenCreatorSurvey2023: Boolean

  """
  DEPRECATED in favor of the unseenActivityNotificationsCountForViewer query field. Please DO NOT USE this column
  """
  hasUnseenActivity: Boolean
  id: String
  instagramName: String
  isCollector2: Boolean
  isWhitelisted: Boolean
  profilePhotoId: uuid
  seriesOrder: jsonb
  shouldBlurNsfwContent: Boolean
  shouldSeeDiscordOnboardingPrompt: Boolean
  timeCreated: timestamptz
  twitterName: String
  username: String
  websiteUrl: String
}

"""
update columns of table "User"
"""
enum User_update_column {
  """column name"""
  bio

  """column name"""
  coverPhotoId

  """column name"""
  discordHandle

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailBlocklist

  """column name"""
  hasCompletedSignup

  """column name"""
  hasTakenCollectorSurvey2023

  """column name"""
  hasTakenCreatorSurvey2023

  """column name"""
  hasUnseenActivity

  """column name"""
  id

  """column name"""
  instagramName

  """column name"""
  isCollector2

  """column name"""
  isWhitelisted

  """column name"""
  profilePhotoId

  """column name"""
  seriesOrder

  """column name"""
  shouldBlurNsfwContent

  """column name"""
  shouldSeeDiscordOnboardingPrompt

  """column name"""
  timeCreated

  """column name"""
  twitterName

  """column name"""
  username

  """column name"""
  websiteUrl
}

"""
A Relay connection object on "User"
"""
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String!
  node: User!
}

"""
columns and relationships of "UserFollows"
"""
type UserFollows implements Node {
  """An object relationship"""
  Followed: User!

  """An object relationship"""
  Follower: User!
  followedId: String!
  followerId: String!
  id: ID!
  timeCreated: timestamptz!
}

"""
aggregated selection of "UserFollows"
"""
type UserFollows_aggregate {
  aggregate: UserFollows_aggregate_fields
  nodes: [UserFollows!]!
}

"""
aggregate fields of "UserFollows"
"""
type UserFollows_aggregate_fields {
  count(columns: [UserFollows_select_column!], distinct: Boolean): Int!
  max: UserFollows_max_fields
  min: UserFollows_min_fields
}

"""
order by aggregate values of table "UserFollows"
"""
input UserFollows_aggregate_order_by {
  count: order_by
  max: UserFollows_max_order_by
  min: UserFollows_min_order_by
}

"""
input type for inserting array relation for remote table "UserFollows"
"""
input UserFollows_arr_rel_insert_input {
  data: [UserFollows_insert_input!]!

  """upsert condition"""
  on_conflict: UserFollows_on_conflict
}

"""
Boolean expression to filter rows from the table "UserFollows". All fields are combined with a logical 'AND'.
"""
input UserFollows_bool_exp {
  Followed: User_bool_exp
  Follower: User_bool_exp
  _and: [UserFollows_bool_exp!]
  _not: UserFollows_bool_exp
  _or: [UserFollows_bool_exp!]
  followedId: String_comparison_exp
  followerId: String_comparison_exp
  id: uuid_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "UserFollows"
"""
enum UserFollows_constraint {
  """unique or primary key constraint"""
  UserFollows_followedId_followerId_key

  """unique or primary key constraint"""
  UserFollows_pkey
}

"""
input type for inserting data into table "UserFollows"
"""
input UserFollows_insert_input {
  Followed: User_obj_rel_insert_input
  Follower: User_obj_rel_insert_input
  followedId: String
  followerId: String
  id: uuid
  timeCreated: timestamptz
}

"""aggregate max on columns"""
type UserFollows_max_fields {
  followedId: String
  followerId: String
  id: uuid
  timeCreated: timestamptz
}

"""
order by max() on columns of table "UserFollows"
"""
input UserFollows_max_order_by {
  followedId: order_by
  followerId: order_by
  id: order_by
  timeCreated: order_by
}

"""aggregate min on columns"""
type UserFollows_min_fields {
  followedId: String
  followerId: String
  id: uuid
  timeCreated: timestamptz
}

"""
order by min() on columns of table "UserFollows"
"""
input UserFollows_min_order_by {
  followedId: order_by
  followerId: order_by
  id: order_by
  timeCreated: order_by
}

"""
response of any mutation on the table "UserFollows"
"""
type UserFollows_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [UserFollows!]!
}

"""
on_conflict condition type for table "UserFollows"
"""
input UserFollows_on_conflict {
  constraint: UserFollows_constraint!
  update_columns: [UserFollows_update_column!]! = []
  where: UserFollows_bool_exp
}

"""Ordering options when selecting data from "UserFollows"."""
input UserFollows_order_by {
  Followed: User_order_by
  Follower: User_order_by
  followedId: order_by
  followerId: order_by
  id: order_by
  timeCreated: order_by
}

"""primary key columns input for table: UserFollows"""
input UserFollows_pk_columns_input {
  id: uuid!
}

"""
select columns of table "UserFollows"
"""
enum UserFollows_select_column {
  """column name"""
  followedId

  """column name"""
  followerId

  """column name"""
  id

  """column name"""
  timeCreated
}

"""
input type for updating data in table "UserFollows"
"""
input UserFollows_set_input {
  followedId: String
  followerId: String
  id: uuid
  timeCreated: timestamptz
}

"""
update columns of table "UserFollows"
"""
enum UserFollows_update_column {
  """column name"""
  followedId

  """column name"""
  followerId

  """column name"""
  id

  """column name"""
  timeCreated
}

"""
A Relay connection object on "UserFollows"
"""
type UserFollowsConnection {
  edges: [UserFollowsEdge!]!
  pageInfo: PageInfo!
}

type UserFollowsEdge {
  cursor: String!
  node: UserFollows!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "Video"
"""
type Video implements Node {
  id: ID!
  playbackId: String!
  status: String!
  timeCreated: timestamptz
}

"""
Boolean expression to filter rows from the table "Video". All fields are combined with a logical 'AND'.
"""
input Video_bool_exp {
  _and: [Video_bool_exp!]
  _not: Video_bool_exp
  _or: [Video_bool_exp!]
  id: uuid_comparison_exp
  playbackId: String_comparison_exp
  status: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "Video"
"""
enum Video_constraint {
  """unique or primary key constraint"""
  Video_pkey

  """unique or primary key constraint"""
  Video_playbackId_key
}

"""
input type for inserting data into table "Video"
"""
input Video_insert_input {
  id: uuid
  playbackId: String
  status: String
  timeCreated: timestamptz
}

"""
response of any mutation on the table "Video"
"""
type Video_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Video!]!
}

"""
on_conflict condition type for table "Video"
"""
input Video_on_conflict {
  constraint: Video_constraint!
  update_columns: [Video_update_column!]! = []
  where: Video_bool_exp
}

"""Ordering options when selecting data from "Video"."""
input Video_order_by {
  id: order_by
  playbackId: order_by
  status: order_by
  timeCreated: order_by
}

"""primary key columns input for table: Video"""
input Video_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Video"
"""
enum Video_select_column {
  """column name"""
  id

  """column name"""
  playbackId

  """column name"""
  status

  """column name"""
  timeCreated
}

"""
input type for updating data in table "Video"
"""
input Video_set_input {
  id: uuid
  playbackId: String
  status: String
  timeCreated: timestamptz
}

"""
update columns of table "Video"
"""
enum Video_update_column {
  """column name"""
  id

  """column name"""
  playbackId

  """column name"""
  status

  """column name"""
  timeCreated
}

"""
A Relay connection object on "Video"
"""
type VideoConnection {
  edges: [VideoEdge!]!
  pageInfo: PageInfo!
}

type VideoEdge {
  cursor: String!
  node: Video!
}

"""
columns and relationships of "Vote"
"""
type Vote implements Node {
  """An object relationship"""
  ArtistSubmission: ArtistSubmission!

  """An object relationship"""
  User: User!
  artistSubmissionId: uuid!
  id: ID!
  reason: VoteReason_enum
  reportReasons(
    """JSON select path"""
    path: String
  ): jsonb
  timeCreated: timestamptz!
  userId: String!
  voteType: VoteType_enum!
}

"""
aggregated selection of "Vote"
"""
type Vote_aggregate {
  aggregate: Vote_aggregate_fields
  nodes: [Vote!]!
}

"""
aggregate fields of "Vote"
"""
type Vote_aggregate_fields {
  count(columns: [Vote_select_column!], distinct: Boolean): Int!
  max: Vote_max_fields
  min: Vote_min_fields
}

"""
order by aggregate values of table "Vote"
"""
input Vote_aggregate_order_by {
  count: order_by
  max: Vote_max_order_by
  min: Vote_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input Vote_append_input {
  reportReasons: jsonb
}

"""
input type for inserting array relation for remote table "Vote"
"""
input Vote_arr_rel_insert_input {
  data: [Vote_insert_input!]!

  """upsert condition"""
  on_conflict: Vote_on_conflict
}

"""
Boolean expression to filter rows from the table "Vote". All fields are combined with a logical 'AND'.
"""
input Vote_bool_exp {
  ArtistSubmission: ArtistSubmission_bool_exp
  User: User_bool_exp
  _and: [Vote_bool_exp!]
  _not: Vote_bool_exp
  _or: [Vote_bool_exp!]
  artistSubmissionId: uuid_comparison_exp
  id: uuid_comparison_exp
  reason: VoteReason_enum_comparison_exp
  reportReasons: jsonb_comparison_exp
  timeCreated: timestamptz_comparison_exp
  userId: String_comparison_exp
  voteType: VoteType_enum_comparison_exp
}

"""
unique or primary key constraints on table "Vote"
"""
enum Vote_constraint {
  """unique or primary key constraint"""
  Vote_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Vote_delete_at_path_input {
  reportReasons: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input Vote_delete_elem_input {
  reportReasons: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Vote_delete_key_input {
  reportReasons: String
}

"""
input type for inserting data into table "Vote"
"""
input Vote_insert_input {
  ArtistSubmission: ArtistSubmission_obj_rel_insert_input
  User: User_obj_rel_insert_input
  artistSubmissionId: uuid
  id: uuid
  reason: VoteReason_enum
  reportReasons: jsonb
  timeCreated: timestamptz
  userId: String
  voteType: VoteType_enum
}

"""aggregate max on columns"""
type Vote_max_fields {
  artistSubmissionId: uuid
  id: uuid
  timeCreated: timestamptz
  userId: String
}

"""
order by max() on columns of table "Vote"
"""
input Vote_max_order_by {
  artistSubmissionId: order_by
  id: order_by
  timeCreated: order_by
  userId: order_by
}

"""aggregate min on columns"""
type Vote_min_fields {
  artistSubmissionId: uuid
  id: uuid
  timeCreated: timestamptz
  userId: String
}

"""
order by min() on columns of table "Vote"
"""
input Vote_min_order_by {
  artistSubmissionId: order_by
  id: order_by
  timeCreated: order_by
  userId: order_by
}

"""
response of any mutation on the table "Vote"
"""
type Vote_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Vote!]!
}

"""
on_conflict condition type for table "Vote"
"""
input Vote_on_conflict {
  constraint: Vote_constraint!
  update_columns: [Vote_update_column!]! = []
  where: Vote_bool_exp
}

"""Ordering options when selecting data from "Vote"."""
input Vote_order_by {
  ArtistSubmission: ArtistSubmission_order_by
  User: User_order_by
  artistSubmissionId: order_by
  id: order_by
  reason: order_by
  reportReasons: order_by
  timeCreated: order_by
  userId: order_by
  voteType: order_by
}

"""primary key columns input for table: Vote"""
input Vote_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input Vote_prepend_input {
  reportReasons: jsonb
}

"""
select columns of table "Vote"
"""
enum Vote_select_column {
  """column name"""
  artistSubmissionId

  """column name"""
  id

  """column name"""
  reason

  """column name"""
  reportReasons

  """column name"""
  timeCreated

  """column name"""
  userId

  """column name"""
  voteType
}

"""
input type for updating data in table "Vote"
"""
input Vote_set_input {
  artistSubmissionId: uuid
  id: uuid
  reason: VoteReason_enum
  reportReasons: jsonb
  timeCreated: timestamptz
  userId: String
  voteType: VoteType_enum
}

"""
update columns of table "Vote"
"""
enum Vote_update_column {
  """column name"""
  artistSubmissionId

  """column name"""
  id

  """column name"""
  reason

  """column name"""
  reportReasons

  """column name"""
  timeCreated

  """column name"""
  userId

  """column name"""
  voteType
}

"""
A Relay connection object on "Vote"
"""
type VoteConnection {
  edges: [VoteEdge!]!
  pageInfo: PageInfo!
}

type VoteEdge {
  cursor: String!
  node: Vote!
}

"""Reason for making a vote"""
type VoteReason implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "VoteReason". All fields are combined with a logical 'AND'.
"""
input VoteReason_bool_exp {
  _and: [VoteReason_bool_exp!]
  _not: VoteReason_bool_exp
  _or: [VoteReason_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "VoteReason"
"""
enum VoteReason_constraint {
  """unique or primary key constraint"""
  VoteReason_pkey
}

enum VoteReason_enum {
  BreaksGuidelines
  Duplicate
  LowQuality
  VoteFailed
}

"""
Boolean expression to compare columns of type "VoteReason_enum". All fields are combined with logical 'AND'.
"""
input VoteReason_enum_comparison_exp {
  _eq: VoteReason_enum
  _in: [VoteReason_enum!]
  _is_null: Boolean
  _neq: VoteReason_enum
  _nin: [VoteReason_enum!]
}

"""
input type for inserting data into table "VoteReason"
"""
input VoteReason_insert_input {
  value: String
}

"""
response of any mutation on the table "VoteReason"
"""
type VoteReason_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [VoteReason!]!
}

"""
on_conflict condition type for table "VoteReason"
"""
input VoteReason_on_conflict {
  constraint: VoteReason_constraint!
  update_columns: [VoteReason_update_column!]! = []
  where: VoteReason_bool_exp
}

"""Ordering options when selecting data from "VoteReason"."""
input VoteReason_order_by {
  value: order_by
}

"""primary key columns input for table: VoteReason"""
input VoteReason_pk_columns_input {
  value: String!
}

"""
select columns of table "VoteReason"
"""
enum VoteReason_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "VoteReason"
"""
input VoteReason_set_input {
  value: String
}

"""
update columns of table "VoteReason"
"""
enum VoteReason_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "VoteReason"
"""
type VoteReasonConnection {
  edges: [VoteReasonEdge!]!
  pageInfo: PageInfo!
}

type VoteReasonEdge {
  cursor: String!
  node: VoteReason!
}

"""
columns and relationships of "VoteType"
"""
type VoteType implements Node {
  id: ID!
  value: String!
}

"""
Boolean expression to filter rows from the table "VoteType". All fields are combined with a logical 'AND'.
"""
input VoteType_bool_exp {
  _and: [VoteType_bool_exp!]
  _not: VoteType_bool_exp
  _or: [VoteType_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "VoteType"
"""
enum VoteType_constraint {
  """unique or primary key constraint"""
  VoteType_pkey
}

enum VoteType_enum {
  Approve
  PrescreenApprove
  PrescreenReject
  Reject
  ReportSubmission
  Skip
  Upvote
}

"""
Boolean expression to compare columns of type "VoteType_enum". All fields are combined with logical 'AND'.
"""
input VoteType_enum_comparison_exp {
  _eq: VoteType_enum
  _in: [VoteType_enum!]
  _is_null: Boolean
  _neq: VoteType_enum
  _nin: [VoteType_enum!]
}

"""
input type for inserting data into table "VoteType"
"""
input VoteType_insert_input {
  value: String
}

"""
response of any mutation on the table "VoteType"
"""
type VoteType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [VoteType!]!
}

"""
on_conflict condition type for table "VoteType"
"""
input VoteType_on_conflict {
  constraint: VoteType_constraint!
  update_columns: [VoteType_update_column!]! = []
  where: VoteType_bool_exp
}

"""Ordering options when selecting data from "VoteType"."""
input VoteType_order_by {
  value: order_by
}

"""primary key columns input for table: VoteType"""
input VoteType_pk_columns_input {
  value: String!
}

"""
select columns of table "VoteType"
"""
enum VoteType_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "VoteType"
"""
input VoteType_set_input {
  value: String
}

"""
update columns of table "VoteType"
"""
enum VoteType_update_column {
  """column name"""
  value
}

"""
A Relay connection object on "VoteType"
"""
type VoteTypeConnection {
  edges: [VoteTypeEdge!]!
  pageInfo: PageInfo!
}

type VoteTypeEdge {
  cursor: String!
  node: VoteType!
}

"""
columns and relationships of "Whitelist"
"""
type Whitelist implements Node {
  address: String!
  id: ID!
  timeCreated: timestamptz
}

"""
Boolean expression to filter rows from the table "Whitelist". All fields are combined with a logical 'AND'.
"""
input Whitelist_bool_exp {
  _and: [Whitelist_bool_exp!]
  _not: Whitelist_bool_exp
  _or: [Whitelist_bool_exp!]
  address: String_comparison_exp
  timeCreated: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "Whitelist"
"""
enum Whitelist_constraint {
  """unique or primary key constraint"""
  Whitelist_pkey
}

"""
input type for inserting data into table "Whitelist"
"""
input Whitelist_insert_input {
  address: String
  timeCreated: timestamptz
}

"""
response of any mutation on the table "Whitelist"
"""
type Whitelist_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Whitelist!]!
}

"""
on_conflict condition type for table "Whitelist"
"""
input Whitelist_on_conflict {
  constraint: Whitelist_constraint!
  update_columns: [Whitelist_update_column!]! = []
  where: Whitelist_bool_exp
}

"""Ordering options when selecting data from "Whitelist"."""
input Whitelist_order_by {
  address: order_by
  timeCreated: order_by
}

"""primary key columns input for table: Whitelist"""
input Whitelist_pk_columns_input {
  address: String!
}

"""
select columns of table "Whitelist"
"""
enum Whitelist_select_column {
  """column name"""
  address

  """column name"""
  timeCreated
}

"""
input type for updating data in table "Whitelist"
"""
input Whitelist_set_input {
  address: String
  timeCreated: timestamptz
}

"""
update columns of table "Whitelist"
"""
enum Whitelist_update_column {
  """column name"""
  address

  """column name"""
  timeCreated
}

"""
A Relay connection object on "Whitelist"
"""
type WhitelistConnection {
  edges: [WhitelistEdge!]!
  pageInfo: PageInfo!
}

type WhitelistEdge {
  cursor: String!
  node: Whitelist!
}

